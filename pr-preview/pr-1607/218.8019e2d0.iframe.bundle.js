"use strict";(self.webpackChunklayerswap=self.webpackChunklayerswap||[]).push([[218],{"./node_modules/viem/_esm/actions/public/estimateContractGas.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{W:()=>estimateContractGas});var _accounts_utils_parseAccount_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/viem/_esm/accounts/utils/parseAccount.js"),_utils_abi_encodeFunctionData_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/viem/_esm/utils/abi/encodeFunctionData.js"),_utils_errors_getContractError_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/viem/_esm/utils/errors/getContractError.js"),_utils_getAction_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/viem/_esm/utils/getAction.js"),_estimateGas_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/viem/_esm/actions/public/estimateGas.js");async function estimateContractGas(client,parameters){const{abi,address,args,functionName,dataSuffix,...request}=parameters,data=(0,_utils_abi_encodeFunctionData_js__WEBPACK_IMPORTED_MODULE_1__.p)({abi,args,functionName});try{return await(0,_utils_getAction_js__WEBPACK_IMPORTED_MODULE_3__.T)(client,_estimateGas_js__WEBPACK_IMPORTED_MODULE_4__.Q,"estimateGas")({data:`${data}${dataSuffix?dataSuffix.replace("0x",""):""}`,to:address,...request})}catch(error){const account=request.account?(0,_accounts_utils_parseAccount_js__WEBPACK_IMPORTED_MODULE_0__.J)(request.account):void 0;throw(0,_utils_errors_getContractError_js__WEBPACK_IMPORTED_MODULE_2__.j)(error,{abi,address,args,docsPath:"/docs/contract/estimateContractGas",functionName,sender:account?.address})}}},"./node_modules/viem/_esm/actions/public/getProof.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{l:()=>getProof});var toHex=__webpack_require__("./node_modules/viem/_esm/utils/encoding/toHex.js"),fromHex=__webpack_require__("./node_modules/viem/_esm/utils/encoding/fromHex.js");async function getProof(client,{address,blockNumber,blockTag:blockTag_,storageKeys}){const blockTag=blockTag_??"latest",blockNumberHex=void 0!==blockNumber?(0,toHex.cK)(blockNumber):void 0;return function formatProof(proof){return{...proof,balance:proof.balance?BigInt(proof.balance):void 0,nonce:proof.nonce?(0,fromHex.ME)(proof.nonce):void 0,storageProof:proof.storageProof?(storageProof=proof.storageProof,storageProof.map(proof=>({...proof,value:BigInt(proof.value)}))):void 0};var storageProof}(await client.request({method:"eth_getProof",params:[address,storageKeys,blockNumberHex||blockTag]}))}},"./node_modules/viem/_esm/clients/createPublicClient.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{l:()=>createPublicClient});var createClient=__webpack_require__("./node_modules/viem/_esm/clients/createClient.js"),abis=__webpack_require__("./node_modules/viem/_esm/constants/abis.js"),decodeFunctionResult=__webpack_require__("./node_modules/viem/_esm/utils/abi/decodeFunctionResult.js"),encodeFunctionData=__webpack_require__("./node_modules/viem/_esm/utils/abi/encodeFunctionData.js"),getChainContractAddress=__webpack_require__("./node_modules/viem/_esm/utils/chain/getChainContractAddress.js"),trim=__webpack_require__("./node_modules/viem/_esm/utils/data/trim.js"),toHex=__webpack_require__("./node_modules/viem/_esm/utils/encoding/toHex.js"),base=__webpack_require__("./node_modules/viem/_esm/errors/base.js"),contract=__webpack_require__("./node_modules/viem/_esm/errors/contract.js");function isNullUniversalResolverError(err){if(!(err instanceof base.C))return!1;const cause=err.walk(e=>e instanceof contract.M);return cause instanceof contract.M&&("HttpError"===cause.data?.errorName||("ResolverError"===cause.data?.errorName||("ResolverNotContract"===cause.data?.errorName||("ResolverNotFound"===cause.data?.errorName||("ReverseAddressMismatch"===cause.data?.errorName||"UnsupportedResolverProfile"===cause.data?.errorName)))))}var localBatchGatewayRequest=__webpack_require__("./node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js"),concat=__webpack_require__("./node_modules/viem/_esm/utils/data/concat.js"),toBytes=__webpack_require__("./node_modules/viem/_esm/utils/encoding/toBytes.js"),keccak256=__webpack_require__("./node_modules/viem/_esm/utils/hash/keccak256.js"),isHex=__webpack_require__("./node_modules/viem/_esm/utils/data/isHex.js");function encodedLabelToLabelhash(label){if(66!==label.length)return null;if(0!==label.indexOf("["))return null;if(65!==label.indexOf("]"))return null;const hash=`0x${label.slice(1,65)}`;return(0,isHex.q)(hash)?hash:null}function namehash(name){let result=new Uint8Array(32).fill(0);if(!name)return(0,toHex.My)(result);const labels=name.split(".");for(let i=labels.length-1;i>=0;i-=1){const hashFromEncodedLabel=encodedLabelToLabelhash(labels[i]),hashed=hashFromEncodedLabel?(0,toBytes.ZJ)(hashFromEncodedLabel):(0,keccak256.S)((0,toBytes.Af)(labels[i]),"bytes");result=(0,keccak256.S)((0,concat.xW)([result,hashed]),"bytes")}return(0,toHex.My)(result)}function encodeLabelhash(hash){return`[${hash.slice(2)}]`}function labelhash(label){const result=new Uint8Array(32).fill(0);return label?encodedLabelToLabelhash(label)||(0,keccak256.S)((0,toBytes.Af)(label)):(0,toHex.My)(result)}function packetToBytes(packet){const value=packet.replace(/^\.|\.$/gm,"");if(0===value.length)return new Uint8Array(1);const bytes=new Uint8Array((0,toBytes.Af)(value).byteLength+2);let offset=0;const list=value.split(".");for(let i=0;i<list.length;i++){let encoded=(0,toBytes.Af)(list[i]);encoded.byteLength>255&&(encoded=(0,toBytes.Af)(encodeLabelhash(labelhash(list[i])))),bytes[offset]=encoded.length,bytes.set(encoded,offset+1),offset+=encoded.length+1}return bytes.byteLength!==offset+1?bytes.slice(0,offset+1):bytes}var getAction=__webpack_require__("./node_modules/viem/_esm/utils/getAction.js"),readContract=__webpack_require__("./node_modules/viem/_esm/actions/public/readContract.js");class EnsAvatarInvalidMetadataError extends base.C{constructor({data}){super("Unable to extract image from metadata. The metadata may be malformed or invalid.",{metaMessages:["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.","",`Provided data: ${JSON.stringify(data)}`],name:"EnsAvatarInvalidMetadataError"})}}class EnsAvatarInvalidNftUriError extends base.C{constructor({reason}){super(`ENS NFT avatar URI is invalid. ${reason}`,{name:"EnsAvatarInvalidNftUriError"})}}class EnsAvatarUriResolutionError extends base.C{constructor({uri}){super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`,{name:"EnsAvatarUriResolutionError"})}}class EnsAvatarUnsupportedNamespaceError extends base.C{constructor({namespace}){super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`,{name:"EnsAvatarUnsupportedNamespaceError"})}}base.C;const networkRegex=/(?<protocol>https?:\/\/[^/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,ipfsHashRegex=/^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,base64Regex=/^data:([a-zA-Z\-/+]*);base64,([^"].*)/,dataURIRegex=/^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;function getGateway(custom,defaultGateway){return custom?custom.endsWith("/")?custom.slice(0,-1):custom:defaultGateway}function resolveAvatarUri({uri,gatewayUrls}){const isEncoded=base64Regex.test(uri);if(isEncoded)return{uri,isOnChain:!0,isEncoded};const ipfsGateway=getGateway(gatewayUrls?.ipfs,"https://ipfs.io"),arweaveGateway=getGateway(gatewayUrls?.arweave,"https://arweave.net"),networkRegexMatch=uri.match(networkRegex),{protocol,subpath,target,subtarget=""}=networkRegexMatch?.groups||{},isIPNS="ipns:/"===protocol||"ipns/"===subpath,isIPFS="ipfs:/"===protocol||"ipfs/"===subpath||ipfsHashRegex.test(uri);if(uri.startsWith("http")&&!isIPNS&&!isIPFS){let replacedUri=uri;return gatewayUrls?.arweave&&(replacedUri=uri.replace(/https:\/\/arweave.net/g,gatewayUrls?.arweave)),{uri:replacedUri,isOnChain:!1,isEncoded:!1}}if((isIPNS||isIPFS)&&target)return{uri:`${ipfsGateway}/${isIPNS?"ipns":"ipfs"}/${target}${subtarget}`,isOnChain:!1,isEncoded:!1};if("ar:/"===protocol&&target)return{uri:`${arweaveGateway}/${target}${subtarget||""}`,isOnChain:!1,isEncoded:!1};let parsedUri=uri.replace(dataURIRegex,"");if(parsedUri.startsWith("<svg")&&(parsedUri=`data:image/svg+xml;base64,${btoa(parsedUri)}`),parsedUri.startsWith("data:")||parsedUri.startsWith("{"))return{uri:parsedUri,isOnChain:!0,isEncoded:!1};throw new EnsAvatarUriResolutionError({uri})}function getJsonImage(data){if("object"!=typeof data||!("image"in data)&&!("image_url"in data)&&!("image_data"in data))throw new EnsAvatarInvalidMetadataError({data});return data.image||data.image_url||data.image_data}async function parseAvatarUri({gatewayUrls,uri}){const{uri:resolvedURI,isOnChain}=resolveAvatarUri({uri,gatewayUrls});if(isOnChain)return resolvedURI;const isImage=await async function isImageUri(uri){try{const res=await fetch(uri,{method:"HEAD"});if(200===res.status){const contentType=res.headers.get("content-type");return contentType?.startsWith("image/")}return!1}catch(error){return("object"!=typeof error||void 0===error.response)&&!!Object.hasOwn(globalThis,"Image")&&new Promise(resolve=>{const img=new Image;img.onload=()=>{resolve(!0)},img.onerror=()=>{resolve(!1)},img.src=uri})}}(resolvedURI);if(isImage)return resolvedURI;throw new EnsAvatarUriResolutionError({uri})}async function parseAvatarRecord(client,{gatewayUrls,record}){return/eip155:/i.test(record)?async function parseNftAvatarUri(client,{gatewayUrls,record}){const nft=function parseNftUri(uri_){let uri=uri_;uri.startsWith("did:nft:")&&(uri=uri.replace("did:nft:","").replace(/_/g,"/"));const[reference,asset_namespace,tokenID]=uri.split("/"),[eip_namespace,chainID]=reference.split(":"),[erc_namespace,contractAddress]=asset_namespace.split(":");if(!eip_namespace||"eip155"!==eip_namespace.toLowerCase())throw new EnsAvatarInvalidNftUriError({reason:"Only EIP-155 supported"});if(!chainID)throw new EnsAvatarInvalidNftUriError({reason:"Chain ID not found"});if(!contractAddress)throw new EnsAvatarInvalidNftUriError({reason:"Contract address not found"});if(!tokenID)throw new EnsAvatarInvalidNftUriError({reason:"Token ID not found"});if(!erc_namespace)throw new EnsAvatarInvalidNftUriError({reason:"ERC namespace not found"});return{chainID:Number.parseInt(chainID,10),namespace:erc_namespace.toLowerCase(),contractAddress,tokenID}}(record),nftUri=await async function getNftTokenUri(client,{nft}){if("erc721"===nft.namespace)return(0,readContract.J)(client,{address:nft.contractAddress,abi:[{name:"tokenURI",type:"function",stateMutability:"view",inputs:[{name:"tokenId",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"tokenURI",args:[BigInt(nft.tokenID)]});if("erc1155"===nft.namespace)return(0,readContract.J)(client,{address:nft.contractAddress,abi:[{name:"uri",type:"function",stateMutability:"view",inputs:[{name:"_id",type:"uint256"}],outputs:[{name:"",type:"string"}]}],functionName:"uri",args:[BigInt(nft.tokenID)]});throw new EnsAvatarUnsupportedNamespaceError({namespace:nft.namespace})}(client,{nft}),{uri:resolvedNftUri,isOnChain,isEncoded}=resolveAvatarUri({uri:nftUri,gatewayUrls});if(isOnChain&&(resolvedNftUri.includes("data:application/json;base64,")||resolvedNftUri.startsWith("{"))){const encodedJson=isEncoded?atob(resolvedNftUri.replace("data:application/json;base64,","")):resolvedNftUri;return parseAvatarUri({uri:getJsonImage(JSON.parse(encodedJson)),gatewayUrls})}let uriTokenId=nft.tokenID;"erc1155"===nft.namespace&&(uriTokenId=uriTokenId.replace("0x","").padStart(64,"0"));return async function getMetadataAvatarUri({gatewayUrls,uri}){try{const res=await fetch(uri).then(res=>res.json());return await parseAvatarUri({gatewayUrls,uri:getJsonImage(res)})}catch{throw new EnsAvatarUriResolutionError({uri})}}({gatewayUrls,uri:resolvedNftUri.replace(/(?:0x)?{id}/,uriTokenId)})}(client,{gatewayUrls,record}):parseAvatarUri({uri:record,gatewayUrls})}async function getEnsText(client,parameters){const{blockNumber,blockTag,key,name,gatewayUrls,strict}=parameters,{chain}=client,universalResolverAddress=(()=>{if(parameters.universalResolverAddress)return parameters.universalResolverAddress;if(!chain)throw new Error("client chain not configured. universalResolverAddress is required.");return(0,getChainContractAddress.M)({blockNumber,chain,contract:"ensUniversalResolver"})})(),tlds=chain?.ensTlds;if(tlds&&!tlds.some(tld=>name.endsWith(tld)))return null;try{const readContractParameters={address:universalResolverAddress,abi:abis.Ag,args:[(0,toHex.nj)(packetToBytes(name)),(0,encodeFunctionData.p)({abi:abis.SJ,functionName:"text",args:[namehash(name),key]}),gatewayUrls??[localBatchGatewayRequest.J]],functionName:"resolveWithGateways",blockNumber,blockTag},readContractAction=(0,getAction.T)(client,readContract.J,"readContract"),res=await readContractAction(readContractParameters);if("0x"===res[0])return null;const record=(0,decodeFunctionResult.e)({abi:abis.SJ,functionName:"text",data:res[0]});return""===record?null:record}catch(err){if(strict)throw err;if(isNullUniversalResolverError(err))return null;throw err}}var call=__webpack_require__("./node_modules/viem/_esm/actions/public/call.js"),parseAccount=__webpack_require__("./node_modules/viem/_esm/accounts/utils/parseAccount.js"),getCallError=__webpack_require__("./node_modules/viem/_esm/utils/errors/getCallError.js"),extract=__webpack_require__("./node_modules/viem/_esm/utils/formatters/extract.js"),transactionRequest=__webpack_require__("./node_modules/viem/_esm/utils/formatters/transactionRequest.js"),assertRequest=__webpack_require__("./node_modules/viem/_esm/utils/transaction/assertRequest.js");async function createAccessList(client,args){const{account:account_=client.account,blockNumber,blockTag="latest",blobs,data,gas,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,to,value,...rest}=args,account=account_?(0,parseAccount.J)(account_):void 0;try{(0,assertRequest.c)(args);const block=("bigint"==typeof blockNumber?(0,toHex.cK)(blockNumber):void 0)||blockTag,chainFormat=client.chain?.formatters?.transactionRequest?.format,request=(chainFormat||transactionRequest.Bv)({...(0,extract.o)(rest,{format:chainFormat}),account,blobs,data,gas,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,to,value},"createAccessList"),response=await client.request({method:"eth_createAccessList",params:[request,block]});return{accessList:response.accessList,gasUsed:BigInt(response.gasUsed)}}catch(err){throw(0,getCallError.d)(err,{...args,account,chain:client.chain})}}function createFilterRequestScope(client,{method}){const requestMap={};return"fallback"===client.transport.type&&client.transport.onResponse?.(({method:method_,response:id,status,transport})=>{"success"===status&&method===method_&&(requestMap[id]=transport.request)}),id=>requestMap[id]||client.request}var errors_abi=__webpack_require__("./node_modules/viem/_esm/errors/abi.js");class FilterTypeNotSupportedError extends base.C{constructor(type){super(`Filter type "${type}" is not supported.`,{name:"FilterTypeNotSupportedError"})}}var toEventSelector=__webpack_require__("./node_modules/viem/_esm/utils/hash/toEventSelector.js"),encodeAbiParameters=__webpack_require__("./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"),formatAbiItem=__webpack_require__("./node_modules/viem/_esm/utils/abi/formatAbiItem.js"),getAbiItem=__webpack_require__("./node_modules/viem/_esm/utils/abi/getAbiItem.js");const docsPath="/docs/contract/encodeEventTopics";function encodeEventTopics(parameters){const{abi,eventName,args}=parameters;let abiItem=abi[0];if(eventName){const item=(0,getAbiItem.iY)({abi,name:eventName});if(!item)throw new errors_abi.M_(eventName,{docsPath});abiItem=item}if("event"!==abiItem.type)throw new errors_abi.M_(void 0,{docsPath});const definition=(0,formatAbiItem.B)(abiItem),signature=(0,toEventSelector.h)(definition);let topics=[];if(args&&"inputs"in abiItem){const indexedInputs=abiItem.inputs?.filter(param=>"indexed"in param&&param.indexed),args_=Array.isArray(args)?args:Object.values(args).length>0?indexedInputs?.map(x=>args[x.name])??[]:[];args_.length>0&&(topics=indexedInputs?.map((param,i)=>Array.isArray(args_[i])?args_[i].map((_,j)=>encodeArg({param,value:args_[i][j]})):void 0!==args_[i]&&null!==args_[i]?encodeArg({param,value:args_[i]}):null)??[])}return[signature,...topics]}function encodeArg({param,value}){if("string"===param.type||"bytes"===param.type)return(0,keccak256.S)((0,toBytes.ZJ)(value));if("tuple"===param.type||param.type.match(/^(.*)\[(\d+)?\]$/))throw new FilterTypeNotSupportedError(param.type);return(0,encodeAbiParameters.h)([param],[value])}async function createContractEventFilter(client,parameters){const{address,abi,args,eventName,fromBlock,strict,toBlock}=parameters,getRequest=createFilterRequestScope(client,{method:"eth_newFilter"}),topics=eventName?encodeEventTopics({abi,args,eventName}):void 0,id=await client.request({method:"eth_newFilter",params:[{address,fromBlock:"bigint"==typeof fromBlock?(0,toHex.cK)(fromBlock):fromBlock,toBlock:"bigint"==typeof toBlock?(0,toHex.cK)(toBlock):toBlock,topics}]});return{abi,args,eventName,id,request:getRequest(id),strict:Boolean(strict),type:"event"}}async function createEventFilter(client,{address,args,event,events:events_,fromBlock,strict,toBlock}={}){const events=events_??(event?[event]:void 0),getRequest=createFilterRequestScope(client,{method:"eth_newFilter"});let topics=[];if(events){const encoded=events.flatMap(event=>encodeEventTopics({abi:[event],eventName:event.name,args}));topics=[encoded],event&&(topics=topics[0])}const id=await client.request({method:"eth_newFilter",params:[{address,fromBlock:"bigint"==typeof fromBlock?(0,toHex.cK)(fromBlock):fromBlock,toBlock:"bigint"==typeof toBlock?(0,toHex.cK)(toBlock):toBlock,...topics.length?{topics}:{}}]});return{abi:events,args,eventName:event?event.name:void 0,fromBlock,id,request:getRequest(id),strict:Boolean(strict),toBlock,type:"event"}}async function createPendingTransactionFilter(client){const getRequest=createFilterRequestScope(client,{method:"eth_newPendingTransactionFilter"}),id=await client.request({method:"eth_newPendingTransactionFilter"});return{id,request:getRequest(id),type:"transaction"}}var estimateContractGas=__webpack_require__("./node_modules/viem/_esm/actions/public/estimateContractGas.js"),estimateFeesPerGas=__webpack_require__("./node_modules/viem/_esm/actions/public/estimateFeesPerGas.js"),estimateGas=__webpack_require__("./node_modules/viem/_esm/actions/public/estimateGas.js"),estimateMaxPriorityFeePerGas=__webpack_require__("./node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js"),getBalance=__webpack_require__("./node_modules/viem/_esm/actions/public/getBalance.js");var getBlock=__webpack_require__("./node_modules/viem/_esm/actions/public/getBlock.js"),getBlockNumber=__webpack_require__("./node_modules/viem/_esm/actions/public/getBlockNumber.js"),fromHex=__webpack_require__("./node_modules/viem/_esm/utils/encoding/fromHex.js");var getChainId=__webpack_require__("./node_modules/viem/_esm/actions/public/getChainId.js");async function getCode(client,{address,blockNumber,blockTag="latest"}){const blockNumberHex=void 0!==blockNumber?(0,toHex.cK)(blockNumber):void 0,hex=await client.request({method:"eth_getCode",params:[address,blockNumberHex||blockTag]},{dedupe:Boolean(blockNumberHex)});if("0x"!==hex)return hex}var isAddressEqual=__webpack_require__("./node_modules/viem/_esm/utils/address/isAddressEqual.js"),cursor=__webpack_require__("./node_modules/viem/_esm/errors/cursor.js"),size=__webpack_require__("./node_modules/viem/_esm/utils/data/size.js"),decodeAbiParameters=__webpack_require__("./node_modules/viem/_esm/utils/abi/decodeAbiParameters.js");const decodeEventLog_docsPath="/docs/contract/decodeEventLog";function decodeEventLog(parameters){const{abi,data,strict:strict_,topics}=parameters,strict=strict_??!0,[signature,...argTopics]=topics;if(!signature)throw new errors_abi._z({docsPath:decodeEventLog_docsPath});const abiItem=abi.find(x=>"event"===x.type&&signature===(0,toEventSelector.h)((0,formatAbiItem.B)(x)));if(!abiItem||!("name"in abiItem)||"event"!==abiItem.type)throw new errors_abi.kE(signature,{docsPath:decodeEventLog_docsPath});const{name,inputs}=abiItem,isUnnamed=inputs?.some(x=>!("name"in x&&x.name)),args=isUnnamed?[]:{},indexedInputs=inputs.map((x,i)=>[x,i]).filter(([x])=>"indexed"in x&&x.indexed);for(let i=0;i<indexedInputs.length;i++){const[param,argIndex]=indexedInputs[i],topic=argTopics[i];if(!topic)throw new errors_abi.l3({abiItem,param});args[isUnnamed?argIndex:param.name||argIndex]=decodeTopic({param,value:topic})}const nonIndexedInputs=inputs.filter(x=>!("indexed"in x&&x.indexed));if(nonIndexedInputs.length>0)if(data&&"0x"!==data)try{const decodedData=(0,decodeAbiParameters.n)(nonIndexedInputs,data);if(decodedData)if(isUnnamed)for(let i=0;i<inputs.length;i++)args[i]=args[i]??decodedData.shift();else for(let i=0;i<nonIndexedInputs.length;i++)args[nonIndexedInputs[i].name]=decodedData[i]}catch(err){if(strict){if(err instanceof errors_abi.Iy||err instanceof cursor.SK)throw new errors_abi.fo({abiItem,data,params:nonIndexedInputs,size:(0,size.E)(data)});throw err}}else if(strict)throw new errors_abi.fo({abiItem,data:"0x",params:nonIndexedInputs,size:0});return{eventName:name,args:Object.values(args).length>0?args:void 0}}function decodeTopic({param,value}){if("string"===param.type||"bytes"===param.type||"tuple"===param.type||param.type.match(/^(.*)\[(\d+)?\]$/))return value;return((0,decodeAbiParameters.n)([param],value)||[])[0]}function parseEventLogs(parameters){const{abi,args,logs,strict=!0}=parameters,eventName=(()=>{if(parameters.eventName)return Array.isArray(parameters.eventName)?parameters.eventName:[parameters.eventName]})();return logs.map(log=>{try{const abiItem=abi.find(abiItem=>"event"===abiItem.type&&log.topics[0]===(0,toEventSelector.h)(abiItem));if(!abiItem)return null;const event=decodeEventLog({...log,abi:[abiItem],strict});return eventName&&!eventName.includes(event.eventName)?null:function includesArgs(parameters){const{args,inputs,matchArgs}=parameters;if(!matchArgs)return!0;if(!args)return!1;function isEqual(input,value,arg){try{return"address"===input.type?(0,isAddressEqual.h)(value,arg):"string"===input.type||"bytes"===input.type?(0,keccak256.S)((0,toBytes.ZJ)(value))===arg:value===arg}catch{return!1}}if(Array.isArray(args)&&Array.isArray(matchArgs))return matchArgs.every((value,index)=>{if(null==value)return!0;const input=inputs[index];if(!input)return!1;return(Array.isArray(value)?value:[value]).some(value=>isEqual(input,value,args[index]))});return"object"==typeof args&&!Array.isArray(args)&&"object"==typeof matchArgs&&!Array.isArray(matchArgs)&&Object.entries(matchArgs).every(([key,value])=>{if(null==value)return!0;const input=inputs.find(input=>input.name===key);if(!input)return!1;return(Array.isArray(value)?value:[value]).some(value=>isEqual(input,value,args[key]))})}({args:event.args,inputs:abiItem.inputs,matchArgs:args})?{...event,...log}:null}catch(err){let eventName,isUnnamed;if(err instanceof errors_abi.kE)return null;if(err instanceof errors_abi.fo||err instanceof errors_abi.l3){if(strict)return null;eventName=err.abiItem.name,isUnnamed=err.abiItem.inputs?.some(x=>!("name"in x&&x.name))}return{...log,args:isUnnamed?[]:{},eventName}}}).filter(Boolean)}var formatters_log=__webpack_require__("./node_modules/viem/_esm/utils/formatters/log.js");async function getLogs(client,{address,blockHash,fromBlock,toBlock,event,events:events_,args,strict:strict_}={}){const strict=strict_??!1,events=events_??(event?[event]:void 0);let logs,topics=[];if(events){const encoded=events.flatMap(event=>encodeEventTopics({abi:[event],eventName:event.name,args:events_?void 0:args}));topics=[encoded],event&&(topics=topics[0])}logs=blockHash?await client.request({method:"eth_getLogs",params:[{address,topics,blockHash}]}):await client.request({method:"eth_getLogs",params:[{address,topics,fromBlock:"bigint"==typeof fromBlock?(0,toHex.cK)(fromBlock):fromBlock,toBlock:"bigint"==typeof toBlock?(0,toHex.cK)(toBlock):toBlock}]});const formattedLogs=logs.map(log=>(0,formatters_log.e)(log));return events?parseEventLogs({abi:events,args,logs:formattedLogs,strict}):formattedLogs}async function getContractEvents(client,parameters){const{abi,address,args,blockHash,eventName,fromBlock,toBlock,strict}=parameters,event=eventName?(0,getAbiItem.iY)({abi,name:eventName}):void 0,events=event?void 0:abi.filter(x=>"event"===x.type);return(0,getAction.T)(client,getLogs,"getLogs")({address,args,blockHash,event,events,fromBlock,toBlock,strict})}class Eip712DomainNotFoundError extends base.C{constructor({address}){super(`No EIP-712 domain found on contract "${address}".`,{metaMessages:["Ensure that:",`- The contract is deployed at the address "${address}".`,"- `eip712Domain()` function exists on the contract.","- `eip712Domain()` function matches signature to ERC-5267 specification."],name:"Eip712DomainNotFoundError"})}}const abi=[{inputs:[],name:"eip712Domain",outputs:[{name:"fields",type:"bytes1"},{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"},{name:"salt",type:"bytes32"},{name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function"}];async function getFeeHistory(client,{blockCount,blockNumber,blockTag="latest",rewardPercentiles}){const blockNumberHex="bigint"==typeof blockNumber?(0,toHex.cK)(blockNumber):void 0;return function formatFeeHistory(feeHistory){return{baseFeePerGas:feeHistory.baseFeePerGas.map(value=>BigInt(value)),gasUsedRatio:feeHistory.gasUsedRatio,oldestBlock:BigInt(feeHistory.oldestBlock),reward:feeHistory.reward?.map(reward=>reward.map(value=>BigInt(value)))}}(await client.request({method:"eth_feeHistory",params:[(0,toHex.cK)(blockCount),blockNumberHex||blockTag,rewardPercentiles]},{dedupe:Boolean(blockNumberHex)}))}async function getFilterChanges(_client,{filter}){const strict="strict"in filter&&filter.strict,logs=await filter.request({method:"eth_getFilterChanges",params:[filter.id]});if("string"==typeof logs[0])return logs;const formattedLogs=logs.map(log=>(0,formatters_log.e)(log));return"abi"in filter&&filter.abi?parseEventLogs({abi:filter.abi,logs:formattedLogs,strict}):formattedLogs}var getGasPrice=__webpack_require__("./node_modules/viem/_esm/actions/public/getGasPrice.js"),getProof=__webpack_require__("./node_modules/viem/_esm/actions/public/getProof.js");var getTransaction=__webpack_require__("./node_modules/viem/_esm/actions/public/getTransaction.js");var getTransactionCount=__webpack_require__("./node_modules/viem/_esm/actions/public/getTransactionCount.js"),getTransactionReceipt=__webpack_require__("./node_modules/viem/_esm/actions/public/getTransactionReceipt.js"),multicall=__webpack_require__("./node_modules/viem/_esm/actions/public/multicall.js"),BlockOverrides=__webpack_require__("./node_modules/ox/_esm/core/BlockOverrides.js"),node=__webpack_require__("./node_modules/viem/_esm/errors/node.js"),getContractError=__webpack_require__("./node_modules/viem/_esm/utils/errors/getContractError.js"),getNodeError=__webpack_require__("./node_modules/viem/_esm/utils/errors/getNodeError.js"),formatters_block=__webpack_require__("./node_modules/viem/_esm/utils/formatters/block.js"),stateOverride=__webpack_require__("./node_modules/viem/_esm/utils/stateOverride.js");async function simulateBlocks(client,parameters){const{blockNumber,blockTag=client.experimental_blockTag??"latest",blocks,returnFullTransactions,traceTransfers,validation}=parameters;try{const blockStateCalls=[];for(const block of blocks){const blockOverrides=block.blockOverrides?BlockOverrides.J(block.blockOverrides):void 0,calls=block.calls.map(call_=>{const call=call_,account=call.account?(0,parseAccount.J)(call.account):void 0,data=call.abi?(0,encodeFunctionData.p)(call):call.data,request={...call,account,data:call.dataSuffix?(0,concat.xW)([data||"0x",call.dataSuffix]):data,from:call.from??account?.address};return(0,assertRequest.c)(request),(0,transactionRequest.Bv)(request)}),stateOverrides=block.stateOverrides?(0,stateOverride.yH)(block.stateOverrides):void 0;blockStateCalls.push({blockOverrides,calls,stateOverrides})}const block=("bigint"==typeof blockNumber?(0,toHex.cK)(blockNumber):void 0)||blockTag;return(await client.request({method:"eth_simulateV1",params:[{blockStateCalls,returnFullTransactions,traceTransfers,validation},block]})).map((block,i)=>({...(0,formatters_block.$)(block),calls:block.calls.map((call,j)=>{const{abi,args,functionName,to}=blocks[i].calls[j],data=call.error?.data??call.returnData,gasUsed=BigInt(call.gasUsed),logs=call.logs?.map(log=>(0,formatters_log.e)(log)),status="0x1"===call.status?"success":"failure",result=abi&&"success"===status&&"0x"!==data?(0,decodeFunctionResult.e)({abi,data,functionName}):null,error=(()=>{if("success"===status)return;let error;return"0x"===call.error?.data?error=new errors_abi.O:call.error&&(error=new contract.$S(call.error)),error?(0,getContractError.j)(error,{abi:abi??[],address:to??"0x",args,functionName:functionName??"<unknown>"}):void 0})();return{data,gasUsed,logs,status,..."success"===status?{result}:{error}}})}))}catch(e){const cause=e,error=(0,getNodeError.l)(cause,{});if(error instanceof node.RM)throw cause;throw error}}class BaseError extends Error{constructor(shortMessage,args={}){const details=args.cause instanceof BaseError?args.cause.details:args.cause?.message?args.cause.message:args.details,docsPath=args.cause instanceof BaseError&&args.cause.docsPath||args.docsPath;super([shortMessage||"An error occurred.","",...args.metaMessages?[...args.metaMessages,""]:[],...docsPath?[`Docs: https://abitype.dev${docsPath}`]:[],...details?[`Details: ${details}`]:[],"Version: abitype@1.1.1"].join("\n")),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiTypeError"}),args.cause&&(this.cause=args.cause),this.details=details,this.docsPath=docsPath,this.metaMessages=args.metaMessages,this.shortMessage=shortMessage}}class InvalidAbiItemError extends BaseError{constructor({signature}){super("Failed to parse ABI item.",{details:`parseAbiItem(${JSON.stringify(signature,null,2)})`,docsPath:"/api/human#parseabiitem-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiItemError"})}}class UnknownTypeError extends BaseError{constructor({type}){super("Unknown type.",{metaMessages:[`Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownTypeError"})}}class UnknownSolidityTypeError extends BaseError{constructor({type}){super("Unknown type.",{metaMessages:[`Type "${type}" is not a valid ABI type.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSolidityTypeError"})}}function execTyped(regex,string){const match=regex.exec(string);return match?.groups}const bytesRegex=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,integerRegex=/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,isTupleRegex=/^\(.+?\).*?$/,errorSignatureRegex=/^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;const eventSignatureRegex=/^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;const functionSignatureRegex=/^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;const structSignatureRegex=/^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;function isStructSignature(signature){return structSignatureRegex.test(signature)}function execStructSignature(signature){return execTyped(structSignatureRegex,signature)}const constructorSignatureRegex=/^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;const fallbackSignatureRegex=/^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;const receiveSignatureRegex=/^receive\(\) external payable$/;const modifiers=new Set(["memory","indexed","storage","calldata"]),eventModifiers=new Set(["indexed"]),functionModifiers=new Set(["calldata","memory","storage"]);class InvalidAbiParametersError extends BaseError{constructor({params}){super("Failed to parse ABI parameters.",{details:`parseAbiParameters(${JSON.stringify(params,null,2)})`,docsPath:"/api/human#parseabiparameters-1"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiParametersError"})}}class InvalidParameterError extends BaseError{constructor({param}){super("Invalid ABI parameter.",{details:param}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParameterError"})}}class SolidityProtectedKeywordError extends BaseError{constructor({param,name}){super("Invalid ABI parameter.",{details:param,metaMessages:[`"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SolidityProtectedKeywordError"})}}class InvalidModifierError extends BaseError{constructor({param,type,modifier}){super("Invalid ABI parameter.",{details:param,metaMessages:[`Modifier "${modifier}" not allowed${type?` in "${type}" type`:""}.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidModifierError"})}}class InvalidFunctionModifierError extends BaseError{constructor({param,type,modifier}){super("Invalid ABI parameter.",{details:param,metaMessages:[`Modifier "${modifier}" not allowed${type?` in "${type}" type`:""}.`,`Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidFunctionModifierError"})}}class InvalidAbiTypeParameterError extends BaseError{constructor({abiParameter}){super("Invalid ABI parameter.",{details:JSON.stringify(abiParameter,null,2),metaMessages:["ABI parameter type is invalid."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiTypeParameterError"})}}class InvalidSignatureError extends BaseError{constructor({signature,type}){super(`Invalid ${type} signature.`,{details:signature}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSignatureError"})}}class UnknownSignatureError extends BaseError{constructor({signature}){super("Unknown signature.",{details:signature}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"UnknownSignatureError"})}}class InvalidStructSignatureError extends BaseError{constructor({signature}){super("Invalid struct signature.",{details:signature,metaMessages:["No properties exist."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStructSignatureError"})}}class CircularReferenceError extends BaseError{constructor({type}){super("Circular reference detected.",{metaMessages:[`Struct "${type}" is a circular reference.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"CircularReferenceError"})}}class InvalidParenthesisError extends BaseError{constructor({current,depth}){super("Unbalanced parentheses.",{metaMessages:[`"${current.trim()}" has too many ${depth>0?"opening":"closing"} parentheses.`],details:`Depth "${depth}"`}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidParenthesisError"})}}const parameterCache=new Map([["address",{type:"address"}],["bool",{type:"bool"}],["bytes",{type:"bytes"}],["bytes32",{type:"bytes32"}],["int",{type:"int256"}],["int256",{type:"int256"}],["string",{type:"string"}],["uint",{type:"uint256"}],["uint8",{type:"uint8"}],["uint16",{type:"uint16"}],["uint24",{type:"uint24"}],["uint32",{type:"uint32"}],["uint64",{type:"uint64"}],["uint96",{type:"uint96"}],["uint112",{type:"uint112"}],["uint160",{type:"uint160"}],["uint192",{type:"uint192"}],["uint256",{type:"uint256"}],["address owner",{type:"address",name:"owner"}],["address to",{type:"address",name:"to"}],["bool approved",{type:"bool",name:"approved"}],["bytes _data",{type:"bytes",name:"_data"}],["bytes data",{type:"bytes",name:"data"}],["bytes signature",{type:"bytes",name:"signature"}],["bytes32 hash",{type:"bytes32",name:"hash"}],["bytes32 r",{type:"bytes32",name:"r"}],["bytes32 root",{type:"bytes32",name:"root"}],["bytes32 s",{type:"bytes32",name:"s"}],["string name",{type:"string",name:"name"}],["string symbol",{type:"string",name:"symbol"}],["string tokenURI",{type:"string",name:"tokenURI"}],["uint tokenId",{type:"uint256",name:"tokenId"}],["uint8 v",{type:"uint8",name:"v"}],["uint256 balance",{type:"uint256",name:"balance"}],["uint256 tokenId",{type:"uint256",name:"tokenId"}],["uint256 value",{type:"uint256",name:"value"}],["event:address indexed from",{type:"address",name:"from",indexed:!0}],["event:address indexed to",{type:"address",name:"to",indexed:!0}],["event:uint indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}],["event:uint256 indexed tokenId",{type:"uint256",name:"tokenId",indexed:!0}]]);function parseSignature(signature,structs={}){if(function isFunctionSignature(signature){return functionSignatureRegex.test(signature)}(signature))return function parseFunctionSignature(signature,structs={}){const match=function execFunctionSignature(signature){return execTyped(functionSignatureRegex,signature)}(signature);if(!match)throw new InvalidSignatureError({signature,type:"function"});const inputParams=splitParameters(match.parameters),inputs=[],inputLength=inputParams.length;for(let i=0;i<inputLength;i++)inputs.push(parseAbiParameter(inputParams[i],{modifiers:functionModifiers,structs,type:"function"}));const outputs=[];if(match.returns){const outputParams=splitParameters(match.returns),outputLength=outputParams.length;for(let i=0;i<outputLength;i++)outputs.push(parseAbiParameter(outputParams[i],{modifiers:functionModifiers,structs,type:"function"}))}return{name:match.name,type:"function",stateMutability:match.stateMutability??"nonpayable",inputs,outputs}}(signature,structs);if(function isEventSignature(signature){return eventSignatureRegex.test(signature)}(signature))return function parseEventSignature(signature,structs={}){const match=function execEventSignature(signature){return execTyped(eventSignatureRegex,signature)}(signature);if(!match)throw new InvalidSignatureError({signature,type:"event"});const params=splitParameters(match.parameters),abiParameters=[],length=params.length;for(let i=0;i<length;i++)abiParameters.push(parseAbiParameter(params[i],{modifiers:eventModifiers,structs,type:"event"}));return{name:match.name,type:"event",inputs:abiParameters}}(signature,structs);if(function isErrorSignature(signature){return errorSignatureRegex.test(signature)}(signature))return function parseErrorSignature(signature,structs={}){const match=function execErrorSignature(signature){return execTyped(errorSignatureRegex,signature)}(signature);if(!match)throw new InvalidSignatureError({signature,type:"error"});const params=splitParameters(match.parameters),abiParameters=[],length=params.length;for(let i=0;i<length;i++)abiParameters.push(parseAbiParameter(params[i],{structs,type:"error"}));return{name:match.name,type:"error",inputs:abiParameters}}(signature,structs);if(function isConstructorSignature(signature){return constructorSignatureRegex.test(signature)}(signature))return function parseConstructorSignature(signature,structs={}){const match=function execConstructorSignature(signature){return execTyped(constructorSignatureRegex,signature)}(signature);if(!match)throw new InvalidSignatureError({signature,type:"constructor"});const params=splitParameters(match.parameters),abiParameters=[],length=params.length;for(let i=0;i<length;i++)abiParameters.push(parseAbiParameter(params[i],{structs,type:"constructor"}));return{type:"constructor",stateMutability:match.stateMutability??"nonpayable",inputs:abiParameters}}(signature,structs);if(function isFallbackSignature(signature){return fallbackSignatureRegex.test(signature)}(signature))return function parseFallbackSignature(signature){const match=function execFallbackSignature(signature){return execTyped(fallbackSignatureRegex,signature)}(signature);if(!match)throw new InvalidSignatureError({signature,type:"fallback"});return{type:"fallback",stateMutability:match.stateMutability??"nonpayable"}}(signature);if(function isReceiveSignature(signature){return receiveSignatureRegex.test(signature)}(signature))return{type:"receive",stateMutability:"payable"};throw new UnknownSignatureError({signature})}const abiParameterWithoutTupleRegex=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\spayable)?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,abiParameterWithTupleRegex=/^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/,dynamicIntegerRegex=/^u?int$/;function parseAbiParameter(param,options){const parameterCacheKey=function getParameterCacheKey(param,type,structs){let structKey="";if(structs)for(const struct of Object.entries(structs)){if(!struct)continue;let propertyKey="";for(const property of struct[1])propertyKey+=`[${property.type}${property.name?`:${property.name}`:""}]`;structKey+=`(${struct[0]}{${propertyKey}})`}return type?`${type}:${param}${structKey}`:param}(param,options?.type,options?.structs);if(parameterCache.has(parameterCacheKey))return parameterCache.get(parameterCacheKey);const isTuple=isTupleRegex.test(param),match=execTyped(isTuple?abiParameterWithTupleRegex:abiParameterWithoutTupleRegex,param);if(!match)throw new InvalidParameterError({param});if(match.name&&function isSolidityKeyword(name){return"address"===name||"bool"===name||"function"===name||"string"===name||"tuple"===name||bytesRegex.test(name)||integerRegex.test(name)||protectedKeywordsRegex.test(name)}(match.name))throw new SolidityProtectedKeywordError({param,name:match.name});const name=match.name?{name:match.name}:{},indexed="indexed"===match.modifier?{indexed:!0}:{},structs=options?.structs??{};let type,components={};if(isTuple){type="tuple";const params=splitParameters(match.type),components_=[],length=params.length;for(let i=0;i<length;i++)components_.push(parseAbiParameter(params[i],{structs}));components={components:components_}}else if(match.type in structs)type="tuple",components={components:structs[match.type]};else if(dynamicIntegerRegex.test(match.type))type=`${match.type}256`;else if("address payable"===match.type)type="address";else if(type=match.type,"struct"!==options?.type&&!isSolidityType(type))throw new UnknownSolidityTypeError({type});if(match.modifier){if(!options?.modifiers?.has?.(match.modifier))throw new InvalidModifierError({param,type:options?.type,modifier:match.modifier});if(functionModifiers.has(match.modifier)&&!function isValidDataLocation(type,isArray){return isArray||"bytes"===type||"string"===type||"tuple"===type}(type,!!match.array))throw new InvalidFunctionModifierError({param,type:options?.type,modifier:match.modifier})}const abiParameter={type:`${type}${match.array??""}`,...name,...indexed,...components};return parameterCache.set(parameterCacheKey,abiParameter),abiParameter}function splitParameters(params,result=[],current="",depth=0){const length=params.trim().length;for(let i=0;i<length;i++){const char=params[i],tail=params.slice(i+1);switch(char){case",":return 0===depth?splitParameters(tail,[...result,current.trim()]):splitParameters(tail,result,`${current}${char}`,depth);case"(":return splitParameters(tail,result,`${current}${char}`,depth+1);case")":return splitParameters(tail,result,`${current}${char}`,depth-1);default:return splitParameters(tail,result,`${current}${char}`,depth)}}if(""===current)return result;if(0!==depth)throw new InvalidParenthesisError({current,depth});return result.push(current.trim()),result}function isSolidityType(type){return"address"===type||"bool"===type||"function"===type||"string"===type||bytesRegex.test(type)||integerRegex.test(type)}const protectedKeywordsRegex=/^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;function parseStructs(signatures){const shallowStructs={},signaturesLength=signatures.length;for(let i=0;i<signaturesLength;i++){const signature=signatures[i];if(!isStructSignature(signature))continue;const match=execStructSignature(signature);if(!match)throw new InvalidSignatureError({signature,type:"struct"});const properties=match.properties.split(";"),components=[],propertiesLength=properties.length;for(let k=0;k<propertiesLength;k++){const trimmed=properties[k].trim();if(!trimmed)continue;const abiParameter=parseAbiParameter(trimmed,{type:"struct"});components.push(abiParameter)}if(!components.length)throw new InvalidStructSignatureError({signature});shallowStructs[match.name]=components}const resolvedStructs={},entries=Object.entries(shallowStructs),entriesLength=entries.length;for(let i=0;i<entriesLength;i++){const[name,parameters]=entries[i];resolvedStructs[name]=resolveStructs(parameters,shallowStructs)}return resolvedStructs}const typeWithoutTupleRegex=/^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;function resolveStructs(abiParameters,structs,ancestors=new Set){const components=[],length=abiParameters.length;for(let i=0;i<length;i++){const abiParameter=abiParameters[i];if(isTupleRegex.test(abiParameter.type))components.push(abiParameter);else{const match=execTyped(typeWithoutTupleRegex,abiParameter.type);if(!match?.type)throw new InvalidAbiTypeParameterError({abiParameter});const{array,type}=match;if(type in structs){if(ancestors.has(type))throw new CircularReferenceError({type});components.push({...abiParameter,type:`tuple${array??""}`,components:resolveStructs(structs[type]??[],structs,new Set([...ancestors,type]))})}else{if(!isSolidityType(type))throw new UnknownTypeError({type});components.push(abiParameter)}}}return components}function parseAbiItem(signature){let abiItem;if("string"==typeof signature)abiItem=parseSignature(signature);else{const structs=parseStructs(signature),length=signature.length;for(let i=0;i<length;i++){const signature_=signature[i];if(!isStructSignature(signature_)){abiItem=parseSignature(signature_,structs);break}}}if(!abiItem)throw new InvalidAbiItemError({signature});return abiItem}const tupleRegex=/^tuple(?<array>(\[(\d*)\])*)$/;function formatAbiParameter(abiParameter){let type=abiParameter.type;if(tupleRegex.test(abiParameter.type)&&"components"in abiParameter){type="(";const length=abiParameter.components.length;for(let i=0;i<length;i++){type+=formatAbiParameter(abiParameter.components[i]),i<length-1&&(type+=", ")}const result=execTyped(tupleRegex,abiParameter.type);return type+=`)${result?.array??""}`,formatAbiParameter({...abiParameter,type})}return"indexed"in abiParameter&&abiParameter.indexed&&(type=`${type} indexed`),abiParameter.name?`${type} ${abiParameter.name}`:type}function formatAbiParameters(abiParameters){let params="";const length=abiParameters.length;for(let i=0;i<length;i++){params+=formatAbiParameter(abiParameters[i]),i!==length-1&&(params+=", ")}return params}function formatAbiItem_formatAbiItem(abiItem){return"function"===abiItem.type?`function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability&&"nonpayable"!==abiItem.stateMutability?` ${abiItem.stateMutability}`:""}${abiItem.outputs?.length?` returns (${formatAbiParameters(abiItem.outputs)})`:""}`:"event"===abiItem.type?`event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`:"error"===abiItem.type?`error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`:"constructor"===abiItem.type?`constructor(${formatAbiParameters(abiItem.inputs)})${"payable"===abiItem.stateMutability?" payable":""}`:"fallback"===abiItem.type?"fallback() external"+("payable"===abiItem.stateMutability?" payable":""):"receive() external payable"}var Errors=__webpack_require__("./node_modules/ox/_esm/core/Errors.js"),sha3=__webpack_require__("./node_modules/@noble/hashes/esm/sha3.js"),core_Hex=__webpack_require__("./node_modules/ox/_esm/core/Hex.js");function assertSize(bytes,size_){if(Bytes_size(bytes)>size_)throw new SizeOverflowError({givenSize:Bytes_size(bytes),maxSize:size_})}const charCodeMap={zero:48,nine:57,A:65,F:70,a:97,f:102};function charCodeToBase16(char){return char>=charCodeMap.zero&&char<=charCodeMap.nine?char-charCodeMap.zero:char>=charCodeMap.A&&char<=charCodeMap.F?char-(charCodeMap.A-10):char>=charCodeMap.a&&char<=charCodeMap.f?char-(charCodeMap.a-10):void 0}function bytes_trim(value,options={}){const{dir="left"}=options;let data=value,sliceLength=0;for(let i=0;i<data.length-1&&"0"===data["left"===dir?i:data.length-i-1].toString();i++)sliceLength++;return data="left"===dir?data.slice(sliceLength):data.slice(0,data.length-sliceLength),data}var internal_hex=__webpack_require__("./node_modules/ox/_esm/core/internal/hex.js"),Json=__webpack_require__("./node_modules/ox/_esm/core/Json.js");const decoder=new TextDecoder,encoder=new TextEncoder;function from(value){return value instanceof Uint8Array?value:"string"==typeof value?Bytes_fromHex(value):function fromArray(value){return value instanceof Uint8Array?value:new Uint8Array(value)}(value)}function Bytes_fromHex(value,options={}){const{size}=options;let hex=value;size&&(internal_hex.Sl(value,size),hex=core_Hex.M7(value,size));let hexString=hex.slice(2);hexString.length%2&&(hexString=`0${hexString}`);const length=hexString.length/2,bytes=new Uint8Array(length);for(let index=0,j=0;index<length;index++){const nibbleLeft=charCodeToBase16(hexString.charCodeAt(j++)),nibbleRight=charCodeToBase16(hexString.charCodeAt(j++));if(void 0===nibbleLeft||void 0===nibbleRight)throw new Errors.C(`Invalid byte sequence ("${hexString[j-2]}${hexString[j-1]}" in "${hexString}").`);bytes[index]=16*nibbleLeft+nibbleRight}return bytes}function fromString(value,options={}){const{size}=options,bytes=encoder.encode(value);return"number"==typeof size?(assertSize(bytes,size),function padRight(value,size){return function pad(bytes,options={}){const{dir,size=32}=options;if(0===size)return bytes;if(bytes.length>size)throw new SizeExceedsPaddingSizeError({size:bytes.length,targetSize:size,type:"Bytes"});const paddedBytes=new Uint8Array(size);for(let i=0;i<size;i++){const padEnd="right"===dir;paddedBytes[padEnd?i:size-i-1]=bytes[padEnd?i:bytes.length-i-1]}return paddedBytes}(value,{dir:"right",size})}(bytes,size)):bytes}function Bytes_size(value){return value.length}function slice(value,start,end,options={}){const{strict}=options;!function assertStartOffset(value,start){if("number"==typeof start&&start>0&&start>Bytes_size(value)-1)throw new SliceOffsetOutOfBoundsError({offset:start,position:"start",size:Bytes_size(value)})}(value,start);const value_=value.slice(start,end);return strict&&function assertEndOffset(value,start,end){if("number"==typeof start&&"number"==typeof end&&Bytes_size(value)!==end-start)throw new SliceOffsetOutOfBoundsError({offset:end,position:"end",size:Bytes_size(value)})}(value_,start,end),value_}function toBigInt(bytes,options={}){const{size}=options;void 0!==size&&assertSize(bytes,size);const hex=core_Hex.uK(bytes,options);return core_Hex.Dg(hex,options)}function toBoolean(bytes,options={}){const{size}=options;let bytes_=bytes;if(void 0!==size&&(assertSize(bytes_,size),bytes_=trimLeft(bytes_)),bytes_.length>1||bytes_[0]>1)throw new InvalidBytesBooleanError(bytes_);return Boolean(bytes_[0])}function toNumber(bytes,options={}){const{size}=options;void 0!==size&&assertSize(bytes,size);const hex=core_Hex.uK(bytes,options);return core_Hex.Ro(hex,options)}function Bytes_toString(bytes,options={}){const{size}=options;let bytes_=bytes;return void 0!==size&&(assertSize(bytes_,size),bytes_=function trimRight(value){return bytes_trim(value,{dir:"right"})}(bytes_)),decoder.decode(bytes_)}function trimLeft(value){return bytes_trim(value,{dir:"left"})}class InvalidBytesBooleanError extends Errors.C{constructor(bytes){super(`Bytes value \`${bytes}\` is not a valid boolean.`,{metaMessages:["The bytes array must contain a single byte of either a `0` or `1` value."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesBooleanError"})}}Errors.C;class SizeOverflowError extends Errors.C{constructor({givenSize,maxSize}){super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}}class SliceOffsetOutOfBoundsError extends Errors.C{constructor({offset,position,size}){super(`Slice ${"start"===position?"starting":"ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SliceOffsetOutOfBoundsError"})}}class SizeExceedsPaddingSizeError extends Errors.C{constructor({size,targetSize,type}){super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size}\`) exceeds padding size (\`${targetSize}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}}function Hash_keccak256(value,options={}){const{as="string"==typeof value?"Hex":"Bytes"}=options,bytes=(0,sha3.lY)(from(value));return"Bytes"===as?bytes:core_Hex.uK(bytes)}class LruMap extends Map{constructor(size){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=size}get(key){const value=super.get(key);return super.has(key)&&void 0!==value&&(this.delete(key),super.set(key,value)),value}set(key,value){if(super.set(key,value),this.maxSize&&this.size>this.maxSize){const firstKey=this.keys().next().value;firstKey&&this.delete(firstKey)}return this}}const caches={checksum:new LruMap(8192)},checksum=caches.checksum;const addressRegex=/^0x[a-fA-F0-9]{40}$/;function Address_assert(value,options={}){const{strict=!0}=options;if(!addressRegex.test(value))throw new InvalidAddressError({address:value,cause:new InvalidInputError});if(strict){if(value.toLowerCase()===value)return;if(Address_checksum(value)!==value)throw new InvalidAddressError({address:value,cause:new InvalidChecksumError})}}function Address_checksum(address){if(checksum.has(address))return checksum.get(address);Address_assert(address,{strict:!1});const hexAddress=address.substring(2).toLowerCase(),hash=Hash_keccak256(fromString(hexAddress),{as:"Bytes"}),characters=hexAddress.split("");for(let i=0;i<40;i+=2)hash[i>>1]>>4>=8&&characters[i]&&(characters[i]=characters[i].toUpperCase()),(15&hash[i>>1])>=8&&characters[i+1]&&(characters[i+1]=characters[i+1].toUpperCase());const result=`0x${characters.join("")}`;return checksum.set(address,result),result}function Address_validate(address,options={}){const{strict=!0}=options??{};try{return Address_assert(address,{strict}),!0}catch{return!1}}class InvalidAddressError extends Errors.C{constructor({address,cause}){super(`Address "${address}" is invalid.`,{cause}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class InvalidInputError extends Errors.C{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class InvalidChecksumError extends Errors.C{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}function normalizeSignature(signature){let active=!0,current="",level=0,result="",valid=!1;for(let i=0;i<signature.length;i++){const char=signature[i];if(["(",")",","].includes(char)&&(active=!0),"("===char&&level++,")"===char&&level--,active)if(0!==level)" "!==char?(result+=char,current+=char):","!==signature[i-1]&&","!==current&&",("!==current&&(current="",active=!1);else if(" "===char&&["event","function","error",""].includes(result))result="";else if(result+=char,")"===char){valid=!0;break}}if(!valid)throw new Errors.C("Unable to normalize signature.");return result}function isArgOfType(arg,abiParameter){const argType=typeof arg,abiParameterType=abiParameter.type;switch(abiParameterType){case"address":return Address_validate(arg,{strict:!1});case"bool":return"boolean"===argType;case"function":case"string":return"string"===argType;default:return"tuple"===abiParameterType&&"components"in abiParameter?Object.values(abiParameter.components).every((component,index)=>isArgOfType(Object.values(arg)[index],component)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)?"number"===argType||"bigint"===argType:/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)?"string"===argType||arg instanceof Uint8Array:!!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)&&(Array.isArray(arg)&&arg.every(x=>isArgOfType(x,{...abiParameter,type:abiParameterType.replace(/(\[[0-9]{0,}\])$/,"")})))}}function getAmbiguousTypes(sourceParameters,targetParameters,args){for(const parameterIndex in sourceParameters){const sourceParameter=sourceParameters[parameterIndex],targetParameter=targetParameters[parameterIndex];if("tuple"===sourceParameter.type&&"tuple"===targetParameter.type&&"components"in sourceParameter&&"components"in targetParameter)return getAmbiguousTypes(sourceParameter.components,targetParameter.components,args[parameterIndex]);const types=[sourceParameter.type,targetParameter.type];if((()=>!(!types.includes("address")||!types.includes("bytes20"))||(types.includes("address")&&types.includes("string")||!(!types.includes("address")||!types.includes("bytes")))&&Address_validate(args[parameterIndex],{strict:!1}))())return types}}function AbiItem_from(abiItem,options={}){const{prepare=!0}=options,item=Array.isArray(abiItem)||"string"==typeof abiItem?parseAbiItem(abiItem):abiItem;return{...item,...prepare?{hash:getSignatureHash(item)}:{}}}function fromAbi(abi,name,options){const{args=[],prepare=!0}=options??{},isSelector=core_Hex.tf(name,{strict:!1}),abiItems=abi.filter(abiItem=>isSelector?"function"===abiItem.type||"error"===abiItem.type?getSelector(abiItem)===core_Hex.di(name,0,4):"event"===abiItem.type&&getSignatureHash(abiItem)===name:"name"in abiItem&&abiItem.name===name);if(0===abiItems.length)throw new NotFoundError({name});if(1===abiItems.length)return{...abiItems[0],...prepare?{hash:getSignatureHash(abiItems[0])}:{}};let matchedAbiItem;for(const abiItem of abiItems){if(!("inputs"in abiItem))continue;if(!args||0===args.length){if(!abiItem.inputs||0===abiItem.inputs.length)return{...abiItem,...prepare?{hash:getSignatureHash(abiItem)}:{}};continue}if(!abiItem.inputs)continue;if(0===abiItem.inputs.length)continue;if(abiItem.inputs.length!==args.length)continue;if(args.every((arg,index)=>{const abiParameter="inputs"in abiItem&&abiItem.inputs[index];return!!abiParameter&&isArgOfType(arg,abiParameter)})){if(matchedAbiItem&&"inputs"in matchedAbiItem&&matchedAbiItem.inputs){const ambiguousTypes=getAmbiguousTypes(abiItem.inputs,matchedAbiItem.inputs,args);if(ambiguousTypes)throw new AmbiguityError({abiItem,type:ambiguousTypes[0]},{abiItem:matchedAbiItem,type:ambiguousTypes[1]})}matchedAbiItem=abiItem}}const abiItem=(()=>{if(matchedAbiItem)return matchedAbiItem;const[abiItem,...overloads]=abiItems;return{...abiItem,overloads}})();if(!abiItem)throw new NotFoundError({name});return{...abiItem,...prepare?{hash:getSignatureHash(abiItem)}:{}}}function getSelector(...parameters){const abiItem=(()=>{if(Array.isArray(parameters[0])){const[abi,name]=parameters;return fromAbi(abi,name)}return parameters[0]})();return core_Hex.di(getSignatureHash(abiItem),0,4)}function getSignatureHash(...parameters){const abiItem=(()=>{if(Array.isArray(parameters[0])){const[abi,name]=parameters;return fromAbi(abi,name)}return parameters[0]})();return"string"!=typeof abiItem&&"hash"in abiItem&&abiItem.hash?abiItem.hash:Hash_keccak256(core_Hex.sH(function getSignature(...parameters){const abiItem=(()=>{if(Array.isArray(parameters[0])){const[abi,name]=parameters;return fromAbi(abi,name)}return parameters[0]})();return normalizeSignature("string"==typeof abiItem?abiItem:formatAbiItem_formatAbiItem(abiItem))}(abiItem)))}class AmbiguityError extends Errors.C{constructor(x,y){super("Found ambiguous types in overloaded ABI Items.",{metaMessages:[`\`${x.type}\` in \`${normalizeSignature(formatAbiItem_formatAbiItem(x.abiItem))}\`, and`,`\`${y.type}\` in \`${normalizeSignature(formatAbiItem_formatAbiItem(y.abiItem))}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.AmbiguityError"})}}class NotFoundError extends Errors.C{constructor({name,data,type="item"}){super(`ABI ${type}${name?` with name "${name}"`:data?` with data "${data}"`:""} not found.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.NotFoundError"})}}Errors.C;function parseAbiParameters(params){const abiParameters=[];if("string"==typeof params){const parameters=splitParameters(params),length=parameters.length;for(let i=0;i<length;i++)abiParameters.push(parseAbiParameter(parameters[i],{modifiers}))}else{const structs=parseStructs(params),length=params.length;for(let i=0;i<length;i++){const signature=params[i];if(isStructSignature(signature))continue;const parameters=splitParameters(signature),length=parameters.length;for(let k=0;k<length;k++)abiParameters.push(parseAbiParameter(parameters[k],{modifiers,structs}))}}if(0===abiParameters.length)throw new InvalidAbiParametersError({params});return abiParameters}const arrayRegex=/^(.*)\[([0-9]*)\]$/,Solidity_bytesRegex=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,Solidity_integerRegex=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,maxUint256=2n**256n-1n;function decodeParameter(cursor,param,options){const{checksumAddress,staticPosition}=options,arrayComponents=getArrayComponents(param.type);if(arrayComponents){const[length,type]=arrayComponents;return function decodeArray(cursor,param,options){const{checksumAddress,length,staticPosition}=options;if(!length){const start=staticPosition+toNumber(cursor.readBytes(sizeOfOffset)),startOfData=start+sizeOfLength;cursor.setPosition(start);const length=toNumber(cursor.readBytes(sizeOfLength)),dynamicChild=hasDynamicChild(param);let consumed=0;const value=[];for(let i=0;i<length;++i){cursor.setPosition(startOfData+(dynamicChild?32*i:consumed));const[data,consumed_]=decodeParameter(cursor,param,{checksumAddress,staticPosition:startOfData});consumed+=consumed_,value.push(data)}return cursor.setPosition(staticPosition+32),[value,32]}if(hasDynamicChild(param)){const start=staticPosition+toNumber(cursor.readBytes(sizeOfOffset)),value=[];for(let i=0;i<length;++i){cursor.setPosition(start+32*i);const[data]=decodeParameter(cursor,param,{checksumAddress,staticPosition:start});value.push(data)}return cursor.setPosition(staticPosition+32),[value,32]}let consumed=0;const value=[];for(let i=0;i<length;++i){const[data,consumed_]=decodeParameter(cursor,param,{checksumAddress,staticPosition:staticPosition+consumed});consumed+=consumed_,value.push(data)}return[value,consumed]}(cursor,{...param,type},{checksumAddress,length,staticPosition})}if("tuple"===param.type)return function decodeTuple(cursor,param,options){const{checksumAddress,staticPosition}=options,hasUnnamedChild=0===param.components.length||param.components.some(({name})=>!name),value=hasUnnamedChild?[]:{};let consumed=0;if(hasDynamicChild(param)){const start=staticPosition+toNumber(cursor.readBytes(sizeOfOffset));for(let i=0;i<param.components.length;++i){const component=param.components[i];cursor.setPosition(start+consumed);const[data,consumed_]=decodeParameter(cursor,component,{checksumAddress,staticPosition:start});consumed+=consumed_,value[hasUnnamedChild?i:component?.name]=data}return cursor.setPosition(staticPosition+32),[value,32]}for(let i=0;i<param.components.length;++i){const component=param.components[i],[data,consumed_]=decodeParameter(cursor,component,{checksumAddress,staticPosition});value[hasUnnamedChild?i:component?.name]=data,consumed+=consumed_}return[value,consumed]}(cursor,param,{checksumAddress,staticPosition});if("address"===param.type)return function decodeAddress(cursor,options={}){const{checksum=!1}=options,value=cursor.readBytes(32),wrap=address=>checksum?Address_checksum(address):address;return[wrap(core_Hex.uK(slice(value,-20))),32]}(cursor,{checksum:checksumAddress});if("bool"===param.type)return function decodeBool(cursor){return[toBoolean(cursor.readBytes(32),{size:32}),32]}(cursor);if(param.type.startsWith("bytes"))return function decodeBytes(cursor,param,{staticPosition}){const[_,size]=param.type.split("bytes");if(!size){const offset=toNumber(cursor.readBytes(32));cursor.setPosition(staticPosition+offset);const length=toNumber(cursor.readBytes(32));if(0===length)return cursor.setPosition(staticPosition+32),["0x",32];const data=cursor.readBytes(length);return cursor.setPosition(staticPosition+32),[core_Hex.uK(data),32]}const value=core_Hex.uK(cursor.readBytes(Number.parseInt(size,10),32));return[value,32]}(cursor,param,{staticPosition});if(param.type.startsWith("uint")||param.type.startsWith("int"))return function decodeNumber(cursor,param){const signed=param.type.startsWith("int"),size=Number.parseInt(param.type.split("int")[1]||"256",10),value=cursor.readBytes(32);return[size>48?toBigInt(value,{signed}):toNumber(value,{signed}),32]}(cursor,param);if("string"===param.type)return function decodeString(cursor,{staticPosition}){const offset=toNumber(cursor.readBytes(32)),start=staticPosition+offset;cursor.setPosition(start);const length=toNumber(cursor.readBytes(32));if(0===length)return cursor.setPosition(staticPosition+32),["",32];const data=cursor.readBytes(length,32),value=Bytes_toString(trimLeft(data));return cursor.setPosition(staticPosition+32),[value,32]}(cursor,{staticPosition});throw new InvalidTypeError(param.type)}const sizeOfLength=32,sizeOfOffset=32;function prepareParameter({checksumAddress=!1,parameter:parameter_,value}){const parameter=parameter_,arrayComponents=getArrayComponents(parameter.type);if(arrayComponents){const[length,type]=arrayComponents;return function encodeArray(value,options){const{checksumAddress,length,parameter}=options,dynamic=null===length;if(!Array.isArray(value))throw new InvalidArrayError(value);if(!dynamic&&value.length!==length)throw new ArrayLengthMismatchError({expectedLength:length,givenLength:value.length,type:`${parameter.type}[${length}]`});let dynamicChild=!1;const preparedParameters=[];for(let i=0;i<value.length;i++){const preparedParam=prepareParameter({checksumAddress,parameter,value:value[i]});preparedParam.dynamic&&(dynamicChild=!0),preparedParameters.push(preparedParam)}if(dynamic||dynamicChild){const data=encode(preparedParameters);if(dynamic){const length=core_Hex.oB(preparedParameters.length,{size:32});return{dynamic:!0,encoded:preparedParameters.length>0?core_Hex.xW(length,data):length}}if(dynamicChild)return{dynamic:!0,encoded:data}}return{dynamic:!1,encoded:core_Hex.xW(...preparedParameters.map(({encoded})=>encoded))}}(value,{checksumAddress,length,parameter:{...parameter,type}})}if("tuple"===parameter.type)return function encodeTuple(value,options){const{checksumAddress,parameter}=options;let dynamic=!1;const preparedParameters=[];for(let i=0;i<parameter.components.length;i++){const param_=parameter.components[i],preparedParam=prepareParameter({checksumAddress,parameter:param_,value:value[Array.isArray(value)?i:param_.name]});preparedParameters.push(preparedParam),preparedParam.dynamic&&(dynamic=!0)}return{dynamic,encoded:dynamic?encode(preparedParameters):core_Hex.xW(...preparedParameters.map(({encoded})=>encoded))}}(value,{checksumAddress,parameter});if("address"===parameter.type)return function encodeAddress(value,options){const{checksum=!1}=options;return Address_assert(value,{strict:checksum}),{dynamic:!1,encoded:core_Hex.Ho(value.toLowerCase())}}(value,{checksum:checksumAddress});if("bool"===parameter.type)return function encodeBoolean(value){if("boolean"!=typeof value)throw new Errors.C(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:core_Hex.Ho(core_Hex.xb(value))}}(value);if(parameter.type.startsWith("uint")||parameter.type.startsWith("int")){const signed=parameter.type.startsWith("int"),[,,size="256"]=Solidity_integerRegex.exec(parameter.type)??[];return function encodeNumber(value,{signed,size}){if("number"==typeof size){const max=2n**(BigInt(size)-(signed?1n:0n))-1n,min=signed?-max-1n:0n;if(value>max||value<min)throw new core_Hex.Ty({max:max.toString(),min:min.toString(),signed,size:size/8,value:value.toString()})}return{dynamic:!1,encoded:core_Hex.oB(value,{size:32,signed})}}(value,{signed,size:Number(size)})}if(parameter.type.startsWith("bytes"))return function encodeBytes(value,{type}){const[,parametersize]=type.split("bytes"),bytesSize=core_Hex.Ej(value);if(!parametersize){let value_=value;return bytesSize%32!=0&&(value_=core_Hex.M7(value_,32*Math.ceil((value.length-2)/2/32))),{dynamic:!0,encoded:core_Hex.xW(core_Hex.Ho(core_Hex.oB(bytesSize,{size:32})),value_)}}if(bytesSize!==Number.parseInt(parametersize,10))throw new BytesSizeMismatchError({expectedSize:Number.parseInt(parametersize,10),value});return{dynamic:!1,encoded:core_Hex.M7(value)}}(value,{type:parameter.type});if("string"===parameter.type)return function encodeString(value){const hexValue=core_Hex.sH(value),partsLength=Math.ceil(core_Hex.Ej(hexValue)/32),parts=[];for(let i=0;i<partsLength;i++)parts.push(core_Hex.M7(core_Hex.di(hexValue,32*i,32*(i+1))));return{dynamic:!0,encoded:core_Hex.xW(core_Hex.M7(core_Hex.oB(core_Hex.Ej(hexValue),{size:32})),...parts)}}(value);throw new InvalidTypeError(parameter.type)}function encode(preparedParameters){let staticSize=0;for(let i=0;i<preparedParameters.length;i++){const{dynamic,encoded}=preparedParameters[i];staticSize+=dynamic?32:core_Hex.Ej(encoded)}const staticParameters=[],dynamicParameters=[];let dynamicSize=0;for(let i=0;i<preparedParameters.length;i++){const{dynamic,encoded}=preparedParameters[i];dynamic?(staticParameters.push(core_Hex.oB(staticSize+dynamicSize,{size:32})),dynamicParameters.push(encoded),dynamicSize+=core_Hex.Ej(encoded)):staticParameters.push(encoded)}return core_Hex.xW(...staticParameters,...dynamicParameters)}function getArrayComponents(type){const matches=type.match(/^(.*)\[(\d+)?\]$/);return matches?[matches[2]?Number(matches[2]):null,matches[1]]:void 0}function hasDynamicChild(param){const{type}=param;if("string"===type)return!0;if("bytes"===type)return!0;if(type.endsWith("[]"))return!0;if("tuple"===type)return param.components?.some(hasDynamicChild);const arrayComponents=getArrayComponents(param.type);return!(!arrayComponents||!hasDynamicChild({...param,type:arrayComponents[1]}))}const staticCursor={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new RecursiveReadLimitExceededError({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(position){if(position<0||position>this.bytes.length-1)throw new PositionOutOfBoundsError({length:this.bytes.length,position})},decrementPosition(offset){if(offset<0)throw new NegativeOffsetError({offset});const position=this.position-offset;this.assertPosition(position),this.position=position},getReadCount(position){return this.positionReadCount.get(position||this.position)||0},incrementPosition(offset){if(offset<0)throw new NegativeOffsetError({offset});const position=this.position+offset;this.assertPosition(position),this.position=position},inspectByte(position_){const position=position_??this.position;return this.assertPosition(position),this.bytes[position]},inspectBytes(length,position_){const position=position_??this.position;return this.assertPosition(position+length-1),this.bytes.subarray(position,position+length)},inspectUint8(position_){const position=position_??this.position;return this.assertPosition(position),this.bytes[position]},inspectUint16(position_){const position=position_??this.position;return this.assertPosition(position+1),this.dataView.getUint16(position)},inspectUint24(position_){const position=position_??this.position;return this.assertPosition(position+2),(this.dataView.getUint16(position)<<8)+this.dataView.getUint8(position+2)},inspectUint32(position_){const position=position_??this.position;return this.assertPosition(position+3),this.dataView.getUint32(position)},pushByte(byte){this.assertPosition(this.position),this.bytes[this.position]=byte,this.position++},pushBytes(bytes){this.assertPosition(this.position+bytes.length-1),this.bytes.set(bytes,this.position),this.position+=bytes.length},pushUint8(value){this.assertPosition(this.position),this.bytes[this.position]=value,this.position++},pushUint16(value){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,value),this.position+=2},pushUint24(value){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,value>>8),this.dataView.setUint8(this.position+2,255&value),this.position+=3},pushUint32(value){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,value),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const value=this.inspectByte();return this.position++,value},readBytes(length,size){this.assertReadLimit(),this._touch();const value=this.inspectBytes(length);return this.position+=size??length,value},readUint8(){this.assertReadLimit(),this._touch();const value=this.inspectUint8();return this.position+=1,value},readUint16(){this.assertReadLimit(),this._touch();const value=this.inspectUint16();return this.position+=2,value},readUint24(){this.assertReadLimit(),this._touch();const value=this.inspectUint24();return this.position+=3,value},readUint32(){this.assertReadLimit(),this._touch();const value=this.inspectUint32();return this.position+=4,value},get remaining(){return this.bytes.length-this.position},setPosition(position){const oldPosition=this.position;return this.assertPosition(position),this.position=position,()=>this.position=oldPosition},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const count=this.getReadCount();this.positionReadCount.set(this.position,count+1),count>0&&this.recursiveReadCount++}};class NegativeOffsetError extends Errors.C{constructor({offset}){super(`Offset \`${offset}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.NegativeOffsetError"})}}class PositionOutOfBoundsError extends Errors.C{constructor({length,position}){super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.PositionOutOfBoundsError"})}}class RecursiveReadLimitExceededError extends Errors.C{constructor({count,limit}){super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.RecursiveReadLimitExceededError"})}}function decode(parameters,data,options={}){const{as="Array",checksumAddress=!1}=options,bytes="string"==typeof data?Bytes_fromHex(data):data,cursor=function create(bytes,{recursiveReadLimit=8192}={}){const cursor=Object.create(staticCursor);return cursor.bytes=bytes,cursor.dataView=new DataView(bytes.buffer,bytes.byteOffset,bytes.byteLength),cursor.positionReadCount=new Map,cursor.recursiveReadLimit=recursiveReadLimit,cursor}(bytes);if(0===Bytes_size(bytes)&&parameters.length>0)throw new ZeroDataError;if(Bytes_size(bytes)&&Bytes_size(bytes)<32)throw new DataSizeTooSmallError({data:"string"==typeof data?data:core_Hex.uK(data),parameters,size:Bytes_size(bytes)});let consumed=0;const values="Array"===as?[]:{};for(let i=0;i<parameters.length;++i){const param=parameters[i];cursor.setPosition(consumed);const[data,consumed_]=decodeParameter(cursor,param,{checksumAddress,staticPosition:0});consumed+=consumed_,"Array"===as?values.push(data):values[param.name??i]=data}return values}function AbiParameters_encode(parameters,values,options){const{checksumAddress=!1}=options??{};if(parameters.length!==values.length)throw new LengthMismatchError({expectedLength:parameters.length,givenLength:values.length});const preparedParameters=function prepareParameters({checksumAddress,parameters,values}){const preparedParameters=[];for(let i=0;i<parameters.length;i++)preparedParameters.push(prepareParameter({checksumAddress,parameter:parameters[i],value:values[i]}));return preparedParameters}({checksumAddress,parameters,values}),data=encode(preparedParameters);return 0===data.length?"0x":data}function encodePacked(types,values){if(types.length!==values.length)throw new LengthMismatchError({expectedLength:types.length,givenLength:values.length});const data=[];for(let i=0;i<types.length;i++){const type=types[i],value=values[i];data.push(encodePacked.encode(type,value))}return core_Hex.xW(...data)}function AbiParameters_from(parameters){return Array.isArray(parameters)&&"string"==typeof parameters[0]||"string"==typeof parameters?parseAbiParameters(parameters):parameters}!function(encodePacked){encodePacked.encode=function encode(type,value,isArray=!1){if("address"===type){const address=value;return Address_assert(address),core_Hex.Ho(address.toLowerCase(),isArray?32:0)}if("string"===type)return core_Hex.sH(value);if("bytes"===type)return value;if("bool"===type)return core_Hex.Ho(core_Hex.xb(value),isArray?32:1);const intMatch=type.match(Solidity_integerRegex);if(intMatch){const[_type,baseType,bits="256"]=intMatch,size=Number.parseInt(bits,10)/8;return core_Hex.oB(value,{size:isArray?32:size,signed:"int"===baseType})}const bytesMatch=type.match(Solidity_bytesRegex);if(bytesMatch){const[_type,size]=bytesMatch;if(Number.parseInt(size,10)!==(value.length-2)/2)throw new BytesSizeMismatchError({expectedSize:Number.parseInt(size,10),value});return core_Hex.M7(value,isArray?32:0)}const arrayMatch=type.match(arrayRegex);if(arrayMatch&&Array.isArray(value)){const[_type,childType]=arrayMatch,data=[];for(let i=0;i<value.length;i++)data.push(encode(childType,value[i],!0));return 0===data.length?"0x":core_Hex.xW(...data)}throw new InvalidTypeError(type)}}(encodePacked||(encodePacked={}));class DataSizeTooSmallError extends Errors.C{constructor({data,parameters,size}){super(`Data size of ${size} bytes is too small for given parameters.`,{metaMessages:[`Params: (${formatAbiParameters(parameters)})`,`Data:   ${data} (${size} bytes)`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.DataSizeTooSmallError"})}}class ZeroDataError extends Errors.C{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.'),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ZeroDataError"})}}class ArrayLengthMismatchError extends Errors.C{constructor({expectedLength,givenLength,type}){super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ArrayLengthMismatchError"})}}class BytesSizeMismatchError extends Errors.C{constructor({expectedSize,value}){super(`Size of bytes "${value}" (bytes${core_Hex.Ej(value)}) does not match expected size (bytes${expectedSize}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.BytesSizeMismatchError"})}}class LengthMismatchError extends Errors.C{constructor({expectedLength,givenLength}){super(["ABI encoding parameters/values length mismatch.",`Expected length (parameters): ${expectedLength}`,`Given length (values): ${givenLength}`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.LengthMismatchError"})}}class InvalidArrayError extends Errors.C{constructor(value){super(`Value \`${value}\` is not a valid array.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidArrayError"})}}class InvalidTypeError extends Errors.C{constructor(type){super(`Type \`${type}\` is not a valid ABI Type.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidTypeError"})}}function AbiConstructor_fromAbi(abi){const item=abi.find(item=>"constructor"===item.type);if(!item)throw new NotFoundError({name:"constructor"});return item}function encodeData(...parameters){const[abiFunction,args=[]]=(()=>{if(Array.isArray(parameters[0])){const[abi,name,args]=parameters;return[AbiFunction_fromAbi(abi,name,{args}),args]}const[abiFunction,args]=parameters;return[abiFunction,args]})(),{overloads}=abiFunction,item=overloads?AbiFunction_fromAbi([abiFunction,...overloads],abiFunction.name,{args}):abiFunction,selector=function AbiFunction_getSelector(abiItem){return getSelector(abiItem)}(item),data=args.length>0?AbiParameters_encode(item.inputs,args):void 0;return data?core_Hex.xW(selector,data):selector}function AbiFunction_from(abiFunction,options={}){return AbiItem_from(abiFunction,options)}function AbiFunction_fromAbi(abi,name,options){const item=fromAbi(abi,name,options);if("function"!==item.type)throw new NotFoundError({name,type:"function"});return item}const ethAddress="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",zeroAddress="0x0000000000000000000000000000000000000000";var contracts=__webpack_require__("./node_modules/viem/_esm/constants/contracts.js");const getBalanceCode="0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";async function simulateCalls(client,parameters){const{blockNumber,blockTag,calls,stateOverrides,traceAssetChanges,traceTransfers,validation}=parameters,account=parameters.account?(0,parseAccount.J)(parameters.account):void 0;if(traceAssetChanges&&!account)throw new base.C("`account` is required when `traceAssetChanges` is true");const getBalanceData=account?function AbiConstructor_encode(...parameters){const[abiConstructor,options]=(()=>{if(Array.isArray(parameters[0])){const[abi,options]=parameters;return[AbiConstructor_fromAbi(abi),options]}return parameters})(),{bytecode,args}=options;return core_Hex.xW(bytecode,abiConstructor.inputs?.length&&args?.length?AbiParameters_encode(abiConstructor.inputs,args):"0x")}(function AbiConstructor_from(abiConstructor){return AbiItem_from(abiConstructor)}("constructor(bytes, bytes)"),{bytecode:contracts.LX,args:[getBalanceCode,encodeData(AbiFunction_from("function getBalance(address)"),[account.address])]}):void 0,assetAddresses=traceAssetChanges?await Promise.all(parameters.calls.map(async call=>{if(!call.data&&!call.abi)return;const{accessList}=await createAccessList(client,{account:account.address,...call,data:call.abi?(0,encodeFunctionData.p)(call):call.data});return accessList.map(({address,storageKeys})=>storageKeys.length>0?address:null)})).then(x=>x.flat().filter(Boolean)):[],blocks=await simulateBlocks(client,{blockNumber,blockTag,blocks:[...traceAssetChanges?[{calls:[{data:getBalanceData}],stateOverrides},{calls:assetAddresses.map((address,i)=>({abi:[AbiFunction_from("function balanceOf(address) returns (uint256)")],functionName:"balanceOf",args:[account.address],to:address,from:zeroAddress,nonce:i})),stateOverrides:[{address:zeroAddress,nonce:0}]}]:[],{calls:[...calls,{}].map(call=>({...call,from:account?.address})),stateOverrides},...traceAssetChanges?[{calls:[{data:getBalanceData}]},{calls:assetAddresses.map((address,i)=>({abi:[AbiFunction_from("function balanceOf(address) returns (uint256)")],functionName:"balanceOf",args:[account.address],to:address,from:zeroAddress,nonce:i})),stateOverrides:[{address:zeroAddress,nonce:0}]},{calls:assetAddresses.map((address,i)=>({to:address,abi:[AbiFunction_from("function decimals() returns (uint256)")],functionName:"decimals",from:zeroAddress,nonce:i})),stateOverrides:[{address:zeroAddress,nonce:0}]},{calls:assetAddresses.map((address,i)=>({to:address,abi:[AbiFunction_from("function tokenURI(uint256) returns (string)")],functionName:"tokenURI",args:[0n],from:zeroAddress,nonce:i})),stateOverrides:[{address:zeroAddress,nonce:0}]},{calls:assetAddresses.map((address,i)=>({to:address,abi:[AbiFunction_from("function symbol() returns (string)")],functionName:"symbol",from:zeroAddress,nonce:i})),stateOverrides:[{address:zeroAddress,nonce:0}]}]:[]],traceTransfers,validation}),block_results=traceAssetChanges?blocks[2]:blocks[0],[block_ethPre,block_assetsPre,,block_ethPost,block_assetsPost,block_decimals,block_tokenURI,block_symbols]=traceAssetChanges?blocks:[],{calls:block_calls,...block}=block_results,results=block_calls.slice(0,-1)??[],balancesPre=[...block_ethPre?.calls??[],...block_assetsPre?.calls??[]].map(call=>"success"===call.status?(0,fromHex.uU)(call.data):null),balancesPost=[...block_ethPost?.calls??[],...block_assetsPost?.calls??[]].map(call=>"success"===call.status?(0,fromHex.uU)(call.data):null),decimals=(block_decimals?.calls??[]).map(x=>"success"===x.status?x.result:null),symbols=(block_symbols?.calls??[]).map(x=>"success"===x.status?x.result:null),tokenURI=(block_tokenURI?.calls??[]).map(x=>"success"===x.status?x.result:null),changes=[];for(const[i,balancePost]of balancesPost.entries()){const balancePre=balancesPre[i];if("bigint"!=typeof balancePost)continue;if("bigint"!=typeof balancePre)continue;const decimals_=decimals[i-1],symbol_=symbols[i-1],tokenURI_=tokenURI[i-1],token=(()=>0===i?{address:ethAddress,decimals:18,symbol:"ETH"}:{address:assetAddresses[i-1],decimals:tokenURI_||decimals_?Number(decimals_??1):void 0,symbol:symbol_??void 0})();changes.some(change=>change.token.address===token.address)||changes.push({token,value:{pre:balancePre,post:balancePost,diff:balancePost-balancePre}})}return{assetChanges:changes,block,results}}async function uninstallFilter(_client,{filter}){return filter.request({method:"eth_uninstallFilter",params:[filter.id]})}const magicBytes="0x6492649264926492649264926492649264926492649264926492649264926492";function SignatureErc6492_assert(wrapped){if(core_Hex.di(wrapped,-32)!==magicBytes)throw new InvalidWrappedSignatureError(wrapped)}class InvalidWrappedSignatureError extends Errors.C{constructor(wrapped){super(`Value \`${wrapped}\` is an invalid ERC-6492 wrapped signature.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SignatureErc6492.InvalidWrappedSignatureError"})}}function Signature_assert(signature,options={}){const{recovered}=options;if(void 0===signature.r)throw new MissingPropertiesError({signature});if(void 0===signature.s)throw new MissingPropertiesError({signature});if(recovered&&void 0===signature.yParity)throw new MissingPropertiesError({signature});if(signature.r<0n||signature.r>maxUint256)throw new InvalidRError({value:signature.r});if(signature.s<0n||signature.s>maxUint256)throw new InvalidSError({value:signature.s});if("number"==typeof signature.yParity&&0!==signature.yParity&&1!==signature.yParity)throw new InvalidYParityError({value:signature.yParity})}function Signature_fromHex(signature){if(130!==signature.length&&132!==signature.length)throw new InvalidSerializedSizeError({signature});const r=BigInt(core_Hex.di(signature,0,32)),s=BigInt(core_Hex.di(signature,32,64)),yParity=(()=>{const yParity=Number(`0x${signature.slice(130)}`);if(!Number.isNaN(yParity))try{return vToYParity(yParity)}catch{throw new InvalidYParityError({value:yParity})}})();return void 0===yParity?{r,s}:{r,s,yParity}}function Signature_from(signature){const signature_="string"==typeof signature?Signature_fromHex(signature):signature instanceof Uint8Array?function fromBytes(signature){return Signature_fromHex(core_Hex.uK(signature))}(signature):"string"==typeof signature.r?function fromRpc(signature){const yParity=(()=>{const v=signature.v?Number(signature.v):void 0;let yParity=signature.yParity?Number(signature.yParity):void 0;if("number"==typeof v&&"number"!=typeof yParity&&(yParity=vToYParity(v)),"number"!=typeof yParity)throw new InvalidYParityError({value:signature.yParity});return yParity})();return{r:BigInt(signature.r),s:BigInt(signature.s),yParity}}(signature):signature.v?function fromLegacy(signature){return{r:signature.r,s:signature.s,yParity:vToYParity(signature.v)}}(signature):{r:signature.r,s:signature.s,...void 0!==signature.yParity?{yParity:signature.yParity}:{}};return Signature_assert(signature_),signature_}function vToYParity(v){if(0===v||27===v)return 0;if(1===v||28===v)return 1;if(v>=35)return v%2==0?1:0;throw new InvalidVError({value:v})}class InvalidSerializedSizeError extends Errors.C{constructor({signature}){super(`Value \`${signature}\` is an invalid signature size.`,{metaMessages:["Expected: 64 bytes or 65 bytes.",`Received ${core_Hex.Ej(core_Hex.HT(signature))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidSerializedSizeError"})}}class MissingPropertiesError extends Errors.C{constructor({signature}){super(`Signature \`${Json.A(signature)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.MissingPropertiesError"})}}class InvalidRError extends Errors.C{constructor({value}){super(`Value \`${value}\` is an invalid r value. r must be a positive integer less than 2^256.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidRError"})}}class InvalidSError extends Errors.C{constructor({value}){super(`Value \`${value}\` is an invalid s value. s must be a positive integer less than 2^256.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidSError"})}}class InvalidYParityError extends Errors.C{constructor({value}){super(`Value \`${value}\` is an invalid y-parity value. Y-parity must be 0 or 1.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidYParityError"})}}class InvalidVError extends Errors.C{constructor({value}){super(`Value \`${value}\` is an invalid v value. v must be 27, 28 or >=35.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidVError"})}}function Authorization_from(authorization,options={}){return"string"==typeof authorization.chainId?Authorization_fromRpc(authorization):{...authorization,...options.signature}}function Authorization_fromRpc(authorization){const{address,chainId,nonce}=authorization,signature=function Signature_extract(value){if(void 0!==value.r&&void 0!==value.s)return Signature_from(value)}(authorization);return{address,chainId:Number(chainId),nonce:BigInt(nonce),...signature}}const SignatureErc8010_magicBytes="0x8010801080108010801080108010801080108010801080108010801080108010",suffixParameters=AbiParameters_from("(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data");function SignatureErc8010_assert(value){if("string"==typeof value){if(core_Hex.di(value,-32)!==SignatureErc8010_magicBytes)throw new SignatureErc8010_InvalidWrappedSignatureError(value)}else Signature_assert(value.authorization)}function SignatureErc8010_unwrap(wrapped){SignatureErc8010_assert(wrapped);const suffixLength=core_Hex.Ro(core_Hex.di(wrapped,-64,-32)),suffix=core_Hex.di(wrapped,-suffixLength-64,-64),signature=core_Hex.di(wrapped,0,-suffixLength-64),[auth,to,data]=decode(suffixParameters,suffix);return{authorization:Authorization_from({address:auth.delegation,chainId:Number(auth.chainId),nonce:auth.nonce,yParity:auth.yParity,r:auth.r,s:auth.s}),signature,...data&&"0x"!==data?{data,to}:{}}}class SignatureErc8010_InvalidWrappedSignatureError extends Errors.C{constructor(wrapped){super(`Value \`${wrapped}\` is an invalid ERC-8010 wrapped signature.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SignatureErc8010.InvalidWrappedSignatureError"})}}var encodeDeployData=__webpack_require__("./node_modules/viem/_esm/utils/abi/encodeDeployData.js"),getAddress=__webpack_require__("./node_modules/viem/_esm/utils/address/getAddress.js"),recoverAuthorizationAddress=__webpack_require__("./node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js");var recoverAddress=__webpack_require__("./node_modules/viem/_esm/utils/signature/recoverAddress.js"),esm_secp256k1=__webpack_require__("./node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js");async function verifyHash(client,parameters){const{address,hash,erc6492VerifierAddress:verifierAddress=parameters.universalSignatureVerifierAddress??client.chain?.contracts?.erc6492Verifier?.address,multicallAddress=parameters.multicallAddress??client.chain?.contracts?.multicall3?.address}=parameters,signature=(()=>{const signature=parameters.signature;return(0,isHex.q)(signature)?signature:"object"==typeof signature&&"r"in signature&&"s"in signature?function serializeSignature({r,s,to="hex",v,yParity}){const yParity_=(()=>{if(0===yParity||1===yParity)return yParity;if(v&&(27n===v||28n===v||v>=35n))return v%2n==0n?1:0;throw new Error("Invalid `v` or `yParity` value")})(),signature=`0x${new esm_secp256k1.secp256k1.Signature((0,fromHex.uU)(r),(0,fromHex.uU)(s)).toCompactHex()}${0===yParity_?"1b":"1c"}`;return"hex"===to?signature:(0,toBytes.aT)(signature)}(signature):(0,toHex.My)(signature)})();try{return function SignatureErc8010_validate(value){try{return SignatureErc8010_assert(value),!0}catch{return!1}}(signature)?await async function verifyErc8010(client,parameters){const{address,blockNumber,blockTag,hash,multicallAddress}=parameters,{authorization:authorization_ox,data:initData,signature,to}=SignatureErc8010_unwrap(parameters.signature),code=await getCode(client,{address,blockNumber,blockTag});if(code===(0,concat.aP)(["0xef0100",authorization_ox.address]))return await async function verifyErc1271(client,parameters){const{address,blockNumber,blockTag,hash,signature}=parameters,result=await(0,getAction.T)(client,readContract.J,"readContract")({address,abi:abis.UW,args:[hash,signature],blockNumber,blockTag,functionName:"isValidSignature"}).catch(error=>{if(error instanceof contract.bG)throw new VerificationError;throw error});if(result.startsWith("0x1626ba7e"))return!0;throw new VerificationError}(client,{address,blockNumber,blockTag,hash,signature});const authorization={address:authorization_ox.address,chainId:Number(authorization_ox.chainId),nonce:Number(authorization_ox.nonce),r:(0,toHex.cK)(authorization_ox.r,{size:32}),s:(0,toHex.cK)(authorization_ox.s,{size:32}),yParity:authorization_ox.yParity},valid=await async function verifyAuthorization({address,authorization,signature}){return(0,isAddressEqual.h)((0,getAddress.b)(address),await(0,recoverAuthorizationAddress.g)({authorization,signature}))}({address,authorization});if(!valid)throw new VerificationError;const results=await(0,getAction.T)(client,readContract.J,"readContract")({...multicallAddress?{address:multicallAddress}:{code:contracts.Ez},authorizationList:[authorization],abi:abis.v2,blockNumber,blockTag:"pending",functionName:"aggregate3",args:[[...initData?[{allowFailure:!0,target:to??address,callData:initData}]:[],{allowFailure:!0,target:address,callData:(0,encodeFunctionData.p)({abi:abis.UW,functionName:"isValidSignature",args:[hash,signature]})}]]}),data=results[results.length-1]?.returnData;if(data?.startsWith("0x1626ba7e"))return!0;throw new VerificationError}(client,{...parameters,multicallAddress,signature}):await async function verifyErc6492(client,parameters){const{address,factory,factoryData,hash,signature,verifierAddress,...rest}=parameters,wrappedSignature=await(async()=>factory||factoryData?function SignatureErc6492_validate(wrapped){try{return SignatureErc6492_assert(wrapped),!0}catch{return!1}}(signature)?signature:function wrap(value){const{data,signature,to}=value;return core_Hex.xW(AbiParameters_encode(AbiParameters_from("address, bytes, bytes"),[to,data,signature]),magicBytes)}({data:factoryData,signature,to:factory}):signature)(),args=verifierAddress?{to:verifierAddress,data:(0,encodeFunctionData.p)({abi:abis.E5,functionName:"isValidSig",args:[address,hash,wrappedSignature]}),...rest}:{data:(0,encodeDeployData.m)({abi:abis.E5,args:[address,hash,wrappedSignature],bytecode:contracts.fT}),...rest},{data}=await(0,getAction.T)(client,call.T,"call")(args).catch(error=>{if(error instanceof contract.zX)throw new VerificationError;throw error});if((0,fromHex.Nx)(data??"0x0"))return!0;throw new VerificationError}(client,{...parameters,verifierAddress,signature})}catch(error){try{if((0,isAddressEqual.h)((0,getAddress.b)(address),await(0,recoverAddress.x)({hash,signature})))return!0}catch{}if(error instanceof VerificationError)return!1;throw error}}class VerificationError extends Error{}const presignMessagePrefix="Ethereum Signed Message:\n";function hashMessage(message,to_){return(0,keccak256.S)(function toPrefixedMessage(message_){const message="string"==typeof message_?(0,toHex.i3)(message_):"string"==typeof message_.raw?message_.raw:(0,toHex.My)(message_.raw),prefix=(0,toHex.i3)(`${presignMessagePrefix}${(0,size.E)(message)}`);return(0,concat.xW)([prefix,message])}(message),to_)}var typedData=__webpack_require__("./node_modules/viem/_esm/utils/typedData.js");function hashTypedData(parameters){const{domain={},message,primaryType}=parameters,types={EIP712Domain:(0,typedData.H4)({domain}),...parameters.types};(0,typedData.$$)({domain,message,primaryType,types});const parts=["0x1901"];return domain&&parts.push(function hashDomain({domain,types}){return hashStruct({data:domain,primaryType:"EIP712Domain",types})}({domain,types})),"EIP712Domain"!==primaryType&&parts.push(hashStruct({data:message,primaryType,types})),(0,keccak256.S)((0,concat.xW)(parts))}function hashStruct({data,primaryType,types}){const encoded=hashTypedData_encodeData({data,primaryType,types});return(0,keccak256.S)(encoded)}function hashTypedData_encodeData({data,primaryType,types}){const encodedTypes=[{type:"bytes32"}],encodedValues=[hashType({primaryType,types})];for(const field of types[primaryType]){const[type,value]=encodeField({types,name:field.name,type:field.type,value:data[field.name]});encodedTypes.push(type),encodedValues.push(value)}return(0,encodeAbiParameters.h)(encodedTypes,encodedValues)}function hashType({primaryType,types}){const encodedHashType=(0,toHex.nj)(function encodeType({primaryType,types}){let result="";const unsortedDeps=findTypeDependencies({primaryType,types});unsortedDeps.delete(primaryType);const deps=[primaryType,...Array.from(unsortedDeps).sort()];for(const type of deps)result+=`${type}(${types[type].map(({name,type:t})=>`${t} ${name}`).join(",")})`;return result}({primaryType,types}));return(0,keccak256.S)(encodedHashType)}function findTypeDependencies({primaryType:primaryType_,types},results=new Set){const match=primaryType_.match(/^\w*/u),primaryType=match?.[0];if(results.has(primaryType)||void 0===types[primaryType])return results;results.add(primaryType);for(const field of types[primaryType])findTypeDependencies({primaryType:field.type,types},results);return results}function encodeField({types,name,type,value}){if(void 0!==types[type])return[{type:"bytes32"},(0,keccak256.S)(hashTypedData_encodeData({data:value,primaryType:type,types}))];if("bytes"===type){return value=`0x${(value.length%2?"0":"")+value.slice(2)}`,[{type:"bytes32"},(0,keccak256.S)(value)]}if("string"===type)return[{type:"bytes32"},(0,keccak256.S)((0,toHex.nj)(value))];if(type.lastIndexOf("]")===type.length-1){const parsedType=type.slice(0,type.lastIndexOf("[")),typeValuePairs=value.map(item=>encodeField({name,type:parsedType,types,value:item}));return[{type:"bytes32"},(0,keccak256.S)((0,encodeAbiParameters.h)(typeValuePairs.map(([t])=>t),typeValuePairs.map(([,v])=>v)))]}return[{type},value]}var waitForTransactionReceipt=__webpack_require__("./node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js"),watchBlockNumber=__webpack_require__("./node_modules/viem/_esm/actions/public/watchBlockNumber.js"),observe=__webpack_require__("./node_modules/viem/_esm/utils/observe.js"),poll=__webpack_require__("./node_modules/viem/_esm/utils/poll.js"),stringify=__webpack_require__("./node_modules/viem/_esm/utils/stringify.js");var rpc=__webpack_require__("./node_modules/viem/_esm/errors/rpc.js");const prefixRegex=/^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/,suffixRegex=/(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;var isAddress=__webpack_require__("./node_modules/viem/_esm/utils/address/isAddress.js");async function verifySiweMessage(client,parameters){const{address,domain,message,nonce,scheme,signature,time=new Date,...callRequest}=parameters,parsed=function parseSiweMessage(message){const{scheme,statement,...prefix}=message.match(prefixRegex)?.groups??{},{chainId,expirationTime,issuedAt,notBefore,requestId,...suffix}=message.match(suffixRegex)?.groups??{},resources=message.split("Resources:")[1]?.split("\n- ").slice(1);return{...prefix,...suffix,...chainId?{chainId:Number(chainId)}:{},...expirationTime?{expirationTime:new Date(expirationTime)}:{},...issuedAt?{issuedAt:new Date(issuedAt)}:{},...notBefore?{notBefore:new Date(notBefore)}:{},...requestId?{requestId}:{},...resources?{resources}:{},...scheme?{scheme}:{},...statement?{statement}:{}}}(message);if(!parsed.address)return!1;const isValid=function validateSiweMessage(parameters){const{address,domain,message,nonce,scheme,time=new Date}=parameters;if(domain&&message.domain!==domain)return!1;if(nonce&&message.nonce!==nonce)return!1;if(scheme&&message.scheme!==scheme)return!1;if(message.expirationTime&&time>=message.expirationTime)return!1;if(message.notBefore&&time<message.notBefore)return!1;try{if(!message.address)return!1;if(!(0,isAddress.P)(message.address,{strict:!1}))return!1;if(address&&!(0,isAddressEqual.h)(message.address,address))return!1}catch{return!1}return!0}({address,domain,message:parsed,nonce,scheme,time});if(!isValid)return!1;const hash=hashMessage(message);return verifyHash(client,{address:parsed.address,hash,signature,...callRequest})}var prepareTransactionRequest=__webpack_require__("./node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js"),sendRawTransaction=__webpack_require__("./node_modules/viem/_esm/actions/wallet/sendRawTransaction.js"),sendRawTransactionSync=__webpack_require__("./node_modules/viem/_esm/actions/wallet/sendRawTransactionSync.js");function publicActions(client){return{call:args=>(0,call.T)(client,args),createAccessList:args=>createAccessList(client,args),createBlockFilter:()=>async function createBlockFilter(client){const getRequest=createFilterRequestScope(client,{method:"eth_newBlockFilter"}),id=await client.request({method:"eth_newBlockFilter"});return{id,request:getRequest(id),type:"block"}}(client),createContractEventFilter:args=>createContractEventFilter(client,args),createEventFilter:args=>createEventFilter(client,args),createPendingTransactionFilter:()=>createPendingTransactionFilter(client),estimateContractGas:args=>(0,estimateContractGas.W)(client,args),estimateGas:args=>(0,estimateGas.Q)(client,args),getBalance:args=>(0,getBalance.r)(client,args),getBlobBaseFee:()=>async function getBlobBaseFee(client){const baseFee=await client.request({method:"eth_blobBaseFee"});return BigInt(baseFee)}(client),getBlock:args=>(0,getBlock.g)(client,args),getBlockNumber:args=>(0,getBlockNumber.G)(client,args),getBlockTransactionCount:args=>async function getBlockTransactionCount(client,{blockHash,blockNumber,blockTag="latest"}={}){const blockNumberHex=void 0!==blockNumber?(0,toHex.cK)(blockNumber):void 0;let count;return count=blockHash?await client.request({method:"eth_getBlockTransactionCountByHash",params:[blockHash]},{dedupe:!0}):await client.request({method:"eth_getBlockTransactionCountByNumber",params:[blockNumberHex||blockTag]},{dedupe:Boolean(blockNumberHex)}),(0,fromHex.ME)(count)}(client,args),getBytecode:args=>getCode(client,args),getChainId:()=>(0,getChainId.T)(client),getCode:args=>getCode(client,args),getContractEvents:args=>getContractEvents(client,args),getEip712Domain:args=>async function getEip712Domain(client,parameters){const{address,factory,factoryData}=parameters;try{const[fields,name,version,chainId,verifyingContract,salt,extensions]=await(0,getAction.T)(client,readContract.J,"readContract")({abi,address,functionName:"eip712Domain",factory,factoryData});return{domain:{name,version,chainId:Number(chainId),verifyingContract,salt},extensions,fields}}catch(e){const error=e;if("ContractFunctionExecutionError"===error.name&&"ContractFunctionZeroDataError"===error.cause.name)throw new Eip712DomainNotFoundError({address});throw error}}(client,args),getEnsAddress:args=>async function getEnsAddress(client,parameters){const{blockNumber,blockTag,coinType,name,gatewayUrls,strict}=parameters,{chain}=client,universalResolverAddress=(()=>{if(parameters.universalResolverAddress)return parameters.universalResolverAddress;if(!chain)throw new Error("client chain not configured. universalResolverAddress is required.");return(0,getChainContractAddress.M)({blockNumber,chain,contract:"ensUniversalResolver"})})(),tlds=chain?.ensTlds;if(tlds&&!tlds.some(tld=>name.endsWith(tld)))return null;const args=null!=coinType?[namehash(name),BigInt(coinType)]:[namehash(name)];try{const functionData=(0,encodeFunctionData.p)({abi:abis.Rm,functionName:"addr",args}),readContractParameters={address:universalResolverAddress,abi:abis.Ag,functionName:"resolveWithGateways",args:[(0,toHex.nj)(packetToBytes(name)),functionData,gatewayUrls??[localBatchGatewayRequest.J]],blockNumber,blockTag},readContractAction=(0,getAction.T)(client,readContract.J,"readContract"),res=await readContractAction(readContractParameters);if("0x"===res[0])return null;const address=(0,decodeFunctionResult.e)({abi:abis.Rm,args,functionName:"addr",data:res[0]});return"0x"===address||"0x00"===(0,trim.B)(address)?null:address}catch(err){if(strict)throw err;if(isNullUniversalResolverError(err))return null;throw err}}(client,args),getEnsAvatar:args=>async function getEnsAvatar(client,{blockNumber,blockTag,assetGatewayUrls,name,gatewayUrls,strict,universalResolverAddress}){const record=await(0,getAction.T)(client,getEnsText,"getEnsText")({blockNumber,blockTag,key:"avatar",name,universalResolverAddress,gatewayUrls,strict});if(!record)return null;try{return await parseAvatarRecord(client,{record,gatewayUrls:assetGatewayUrls})}catch{return null}}(client,args),getEnsName:args=>async function getEnsName(client,parameters){const{address,blockNumber,blockTag,coinType=60n,gatewayUrls,strict}=parameters,{chain}=client,universalResolverAddress=(()=>{if(parameters.universalResolverAddress)return parameters.universalResolverAddress;if(!chain)throw new Error("client chain not configured. universalResolverAddress is required.");return(0,getChainContractAddress.M)({blockNumber,chain,contract:"ensUniversalResolver"})})();try{const readContractParameters={address:universalResolverAddress,abi:abis.oX,args:[address,coinType,gatewayUrls??[localBatchGatewayRequest.J]],functionName:"reverseWithGateways",blockNumber,blockTag},readContractAction=(0,getAction.T)(client,readContract.J,"readContract"),[name]=await readContractAction(readContractParameters);return name||null}catch(err){if(strict)throw err;if(isNullUniversalResolverError(err))return null;throw err}}(client,args),getEnsResolver:args=>async function getEnsResolver(client,parameters){const{blockNumber,blockTag,name}=parameters,{chain}=client,universalResolverAddress=(()=>{if(parameters.universalResolverAddress)return parameters.universalResolverAddress;if(!chain)throw new Error("client chain not configured. universalResolverAddress is required.");return(0,getChainContractAddress.M)({blockNumber,chain,contract:"ensUniversalResolver"})})(),tlds=chain?.ensTlds;if(tlds&&!tlds.some(tld=>name.endsWith(tld)))throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(", ")}) for chain "${chain.name}" (id: ${chain.id}).`);const[resolverAddress]=await(0,getAction.T)(client,readContract.J,"readContract")({address:universalResolverAddress,abi:[{inputs:[{type:"bytes"}],name:"findResolver",outputs:[{type:"address"},{type:"bytes32"},{type:"uint256"}],stateMutability:"view",type:"function"}],functionName:"findResolver",args:[(0,toHex.nj)(packetToBytes(name))],blockNumber,blockTag});return resolverAddress}(client,args),getEnsText:args=>getEnsText(client,args),getFeeHistory:args=>getFeeHistory(client,args),estimateFeesPerGas:args=>(0,estimateFeesPerGas._)(client,args),getFilterChanges:args=>getFilterChanges(0,args),getFilterLogs:args=>async function getFilterLogs(_client,{filter}){const strict=filter.strict??!1,formattedLogs=(await filter.request({method:"eth_getFilterLogs",params:[filter.id]})).map(log=>(0,formatters_log.e)(log));return filter.abi?parseEventLogs({abi:filter.abi,logs:formattedLogs,strict}):formattedLogs}(0,args),getGasPrice:()=>(0,getGasPrice.L)(client),getLogs:args=>getLogs(client,args),getProof:args=>(0,getProof.l)(client,args),estimateMaxPriorityFeePerGas:args=>(0,estimateMaxPriorityFeePerGas.b)(client,args),getStorageAt:args=>async function getStorageAt(client,{address,blockNumber,blockTag="latest",slot}){const blockNumberHex=void 0!==blockNumber?(0,toHex.cK)(blockNumber):void 0;return await client.request({method:"eth_getStorageAt",params:[address,slot,blockNumberHex||blockTag]})}(client,args),getTransaction:args=>(0,getTransaction.x)(client,args),getTransactionConfirmations:args=>async function getTransactionConfirmations(client,{hash,transactionReceipt}){const[blockNumber,transaction]=await Promise.all([(0,getAction.T)(client,getBlockNumber.G,"getBlockNumber")({}),hash?(0,getAction.T)(client,getTransaction.x,"getTransaction")({hash}):void 0]),transactionBlockNumber=transactionReceipt?.blockNumber||transaction?.blockNumber;return transactionBlockNumber?blockNumber-transactionBlockNumber+1n:0n}(client,args),getTransactionCount:args=>(0,getTransactionCount.y)(client,args),getTransactionReceipt:args=>(0,getTransactionReceipt.h)(client,args),multicall:args=>(0,multicall.C)(client,args),prepareTransactionRequest:args=>(0,prepareTransactionRequest.ft)(client,args),readContract:args=>(0,readContract.J)(client,args),sendRawTransaction:args=>(0,sendRawTransaction.L)(client,args),sendRawTransactionSync:args=>(0,sendRawTransactionSync.s)(client,args),simulate:args=>simulateBlocks(client,args),simulateBlocks:args=>simulateBlocks(client,args),simulateCalls:args=>simulateCalls(client,args),simulateContract:args=>async function simulateContract(client,parameters){const{abi,address,args,dataSuffix,functionName,...callRequest}=parameters,account=callRequest.account?(0,parseAccount.J)(callRequest.account):client.account,calldata=(0,encodeFunctionData.p)({abi,args,functionName});try{const{data}=await(0,getAction.T)(client,call.T,"call")({batch:!1,data:`${calldata}${dataSuffix?dataSuffix.replace("0x",""):""}`,to:address,...callRequest,account});return{result:(0,decodeFunctionResult.e)({abi,args,functionName,data:data||"0x"}),request:{abi:abi.filter(abiItem=>"name"in abiItem&&abiItem.name===parameters.functionName),address,args,dataSuffix,functionName,...callRequest,account}}}catch(error){throw(0,getContractError.j)(error,{abi,address,args,docsPath:"/docs/contract/simulateContract",functionName,sender:account?.address})}}(client,args),verifyHash:args=>verifyHash(client,args),verifyMessage:args=>async function verifyMessage(client,{address,message,factory,factoryData,signature,...callRequest}){return verifyHash(client,{address,factory,factoryData,hash:hashMessage(message),signature,...callRequest})}(client,args),verifySiweMessage:args=>verifySiweMessage(client,args),verifyTypedData:args=>async function verifyTypedData(client,parameters){const{address,factory,factoryData,signature,message,primaryType,types,domain,...callRequest}=parameters;return verifyHash(client,{address,factory,factoryData,hash:hashTypedData({message,primaryType,types,domain}),signature,...callRequest})}(client,args),uninstallFilter:args=>uninstallFilter(0,args),waitForTransactionReceipt:args=>(0,waitForTransactionReceipt.n)(client,args),watchBlocks:args=>function watchBlocks(client,{blockTag=client.experimental_blockTag??"latest",emitMissed=!1,emitOnBegin=!1,onBlock,onError,includeTransactions:includeTransactions_,poll:poll_,pollingInterval=client.pollingInterval}){const enablePolling=void 0!==poll_?poll_:"webSocket"!==client.transport.type&&"ipc"!==client.transport.type&&("fallback"!==client.transport.type||"webSocket"!==client.transport.transports[0].config.type&&"ipc"!==client.transport.transports[0].config.type),includeTransactions=includeTransactions_??!1;let prevBlock;return enablePolling?(()=>{const observerId=(0,stringify.A)(["watchBlocks",client.uid,blockTag,emitMissed,emitOnBegin,includeTransactions,pollingInterval]);return(0,observe.lB)(observerId,{onBlock,onError},emit=>(0,poll.w)(async()=>{try{const block=await(0,getAction.T)(client,getBlock.g,"getBlock")({blockTag,includeTransactions});if(null!==block.number&&null!=prevBlock?.number){if(block.number===prevBlock.number)return;if(block.number-prevBlock.number>1&&emitMissed)for(let i=prevBlock?.number+1n;i<block.number;i++){const block=await(0,getAction.T)(client,getBlock.g,"getBlock")({blockNumber:i,includeTransactions});emit.onBlock(block,prevBlock),prevBlock=block}}(null==prevBlock?.number||"pending"===blockTag&&null==block?.number||null!==block.number&&block.number>prevBlock.number)&&(emit.onBlock(block,prevBlock),prevBlock=block)}catch(err){emit.onError?.(err)}},{emitOnBegin,interval:pollingInterval}))})():(()=>{let active=!0,emitFetched=!0,unsubscribe=()=>active=!1;return(async()=>{try{emitOnBegin&&(0,getAction.T)(client,getBlock.g,"getBlock")({blockTag,includeTransactions}).then(block=>{active&&emitFetched&&(onBlock(block,void 0),emitFetched=!1)}).catch(onError);const transport=(()=>{if("fallback"===client.transport.type){const transport=client.transport.transports.find(transport=>"webSocket"===transport.config.type||"ipc"===transport.config.type);return transport?transport.value:client.transport}return client.transport})(),{unsubscribe:unsubscribe_}=await transport.subscribe({params:["newHeads"],async onData(data){if(!active)return;const block=await(0,getAction.T)(client,getBlock.g,"getBlock")({blockNumber:data.result?.number,includeTransactions}).catch(()=>{});active&&(onBlock(block,prevBlock),emitFetched=!1,prevBlock=block)},onError(error){onError?.(error)}});unsubscribe=unsubscribe_,active||unsubscribe()}catch(err){onError?.(err)}})(),()=>unsubscribe()})()}(client,args),watchBlockNumber:args=>(0,watchBlockNumber.q)(client,args),watchContractEvent:args=>function watchContractEvent(client,parameters){const{abi,address,args,batch=!0,eventName,fromBlock,onError,onLogs,poll:poll_,pollingInterval=client.pollingInterval,strict:strict_}=parameters;return(void 0!==poll_?poll_:"bigint"==typeof fromBlock||"webSocket"!==client.transport.type&&"ipc"!==client.transport.type&&("fallback"!==client.transport.type||"webSocket"!==client.transport.transports[0].config.type&&"ipc"!==client.transport.transports[0].config.type))?(()=>{const strict=strict_??!1,observerId=(0,stringify.A)(["watchContractEvent",address,args,batch,client.uid,eventName,pollingInterval,strict,fromBlock]);return(0,observe.lB)(observerId,{onLogs,onError},emit=>{let previousBlockNumber,filter;void 0!==fromBlock&&(previousBlockNumber=fromBlock-1n);let initialized=!1;const unwatch=(0,poll.w)(async()=>{if(initialized)try{let logs;if(filter)logs=await(0,getAction.T)(client,getFilterChanges,"getFilterChanges")({filter});else{const blockNumber=await(0,getAction.T)(client,getBlockNumber.G,"getBlockNumber")({});logs=previousBlockNumber&&previousBlockNumber<blockNumber?await(0,getAction.T)(client,getContractEvents,"getContractEvents")({abi,address,args,eventName,fromBlock:previousBlockNumber+1n,toBlock:blockNumber,strict}):[],previousBlockNumber=blockNumber}if(0===logs.length)return;if(batch)emit.onLogs(logs);else for(const log of logs)emit.onLogs([log])}catch(err){filter&&err instanceof rpc.Di&&(initialized=!1),emit.onError?.(err)}else{try{filter=await(0,getAction.T)(client,createContractEventFilter,"createContractEventFilter")({abi,address,args,eventName,strict,fromBlock})}catch{}initialized=!0}},{emitOnBegin:!0,interval:pollingInterval});return async()=>{filter&&await(0,getAction.T)(client,uninstallFilter,"uninstallFilter")({filter}),unwatch()}})})():(()=>{const strict=strict_??!1,observerId=(0,stringify.A)(["watchContractEvent",address,args,batch,client.uid,eventName,pollingInterval,strict]);let active=!0,unsubscribe=()=>active=!1;return(0,observe.lB)(observerId,{onLogs,onError},emit=>((async()=>{try{const transport=(()=>{if("fallback"===client.transport.type){const transport=client.transport.transports.find(transport=>"webSocket"===transport.config.type||"ipc"===transport.config.type);return transport?transport.value:client.transport}return client.transport})(),topics=eventName?encodeEventTopics({abi,eventName,args}):[],{unsubscribe:unsubscribe_}=await transport.subscribe({params:["logs",{address,topics}],onData(data){if(!active)return;const log=data.result;try{const{eventName,args}=decodeEventLog({abi,data:log.data,topics:log.topics,strict:strict_}),formatted=(0,formatters_log.e)(log,{args,eventName});emit.onLogs([formatted])}catch(err){let eventName,isUnnamed;if(err instanceof errors_abi.fo||err instanceof errors_abi.l3){if(strict_)return;eventName=err.abiItem.name,isUnnamed=err.abiItem.inputs?.some(x=>!("name"in x&&x.name))}const formatted=(0,formatters_log.e)(log,{args:isUnnamed?[]:{},eventName});emit.onLogs([formatted])}},onError(error){emit.onError?.(error)}});unsubscribe=unsubscribe_,active||unsubscribe()}catch(err){onError?.(err)}})(),()=>unsubscribe()))})()}(client,args),watchEvent:args=>function watchEvent(client,{address,args,batch=!0,event,events,fromBlock,onError,onLogs,poll:poll_,pollingInterval=client.pollingInterval,strict:strict_}){const enablePolling=void 0!==poll_?poll_:"bigint"==typeof fromBlock||"webSocket"!==client.transport.type&&"ipc"!==client.transport.type&&("fallback"!==client.transport.type||"webSocket"!==client.transport.transports[0].config.type&&"ipc"!==client.transport.transports[0].config.type),strict=strict_??!1;return enablePolling?(()=>{const observerId=(0,stringify.A)(["watchEvent",address,args,batch,client.uid,event,pollingInterval,fromBlock]);return(0,observe.lB)(observerId,{onLogs,onError},emit=>{let previousBlockNumber,filter;void 0!==fromBlock&&(previousBlockNumber=fromBlock-1n);let initialized=!1;const unwatch=(0,poll.w)(async()=>{if(initialized)try{let logs;if(filter)logs=await(0,getAction.T)(client,getFilterChanges,"getFilterChanges")({filter});else{const blockNumber=await(0,getAction.T)(client,getBlockNumber.G,"getBlockNumber")({});logs=previousBlockNumber&&previousBlockNumber!==blockNumber?await(0,getAction.T)(client,getLogs,"getLogs")({address,args,event,events,fromBlock:previousBlockNumber+1n,toBlock:blockNumber}):[],previousBlockNumber=blockNumber}if(0===logs.length)return;if(batch)emit.onLogs(logs);else for(const log of logs)emit.onLogs([log])}catch(err){filter&&err instanceof rpc.Di&&(initialized=!1),emit.onError?.(err)}else{try{filter=await(0,getAction.T)(client,createEventFilter,"createEventFilter")({address,args,event,events,strict,fromBlock})}catch{}initialized=!0}},{emitOnBegin:!0,interval:pollingInterval});return async()=>{filter&&await(0,getAction.T)(client,uninstallFilter,"uninstallFilter")({filter}),unwatch()}})})():(()=>{let active=!0,unsubscribe=()=>active=!1;return(async()=>{try{const transport=(()=>{if("fallback"===client.transport.type){const transport=client.transport.transports.find(transport=>"webSocket"===transport.config.type||"ipc"===transport.config.type);return transport?transport.value:client.transport}return client.transport})(),events_=events??(event?[event]:void 0);let topics=[];if(events_){const encoded=events_.flatMap(event=>encodeEventTopics({abi:[event],eventName:event.name,args}));topics=[encoded],event&&(topics=topics[0])}const{unsubscribe:unsubscribe_}=await transport.subscribe({params:["logs",{address,topics}],onData(data){if(!active)return;const log=data.result;try{const{eventName,args}=decodeEventLog({abi:events_??[],data:log.data,topics:log.topics,strict}),formatted=(0,formatters_log.e)(log,{args,eventName});onLogs([formatted])}catch(err){let eventName,isUnnamed;if(err instanceof errors_abi.fo||err instanceof errors_abi.l3){if(strict_)return;eventName=err.abiItem.name,isUnnamed=err.abiItem.inputs?.some(x=>!("name"in x&&x.name))}const formatted=(0,formatters_log.e)(log,{args:isUnnamed?[]:{},eventName});onLogs([formatted])}},onError(error){onError?.(error)}});unsubscribe=unsubscribe_,active||unsubscribe()}catch(err){onError?.(err)}})(),()=>unsubscribe()})()}(client,args),watchPendingTransactions:args=>function watchPendingTransactions(client,{batch=!0,onError,onTransactions,poll:poll_,pollingInterval=client.pollingInterval}){return(void 0!==poll_?poll_:"webSocket"!==client.transport.type&&"ipc"!==client.transport.type)?(()=>{const observerId=(0,stringify.A)(["watchPendingTransactions",client.uid,batch,pollingInterval]);return(0,observe.lB)(observerId,{onTransactions,onError},emit=>{let filter;const unwatch=(0,poll.w)(async()=>{try{if(!filter)try{return void(filter=await(0,getAction.T)(client,createPendingTransactionFilter,"createPendingTransactionFilter")({}))}catch(err){throw unwatch(),err}const hashes=await(0,getAction.T)(client,getFilterChanges,"getFilterChanges")({filter});if(0===hashes.length)return;if(batch)emit.onTransactions(hashes);else for(const hash of hashes)emit.onTransactions([hash])}catch(err){emit.onError?.(err)}},{emitOnBegin:!0,interval:pollingInterval});return async()=>{filter&&await(0,getAction.T)(client,uninstallFilter,"uninstallFilter")({filter}),unwatch()}})})():(()=>{let active=!0,unsubscribe=()=>active=!1;return(async()=>{try{const{unsubscribe:unsubscribe_}=await client.transport.subscribe({params:["newPendingTransactions"],onData(data){if(!active)return;const transaction=data.result;onTransactions([transaction])},onError(error){onError?.(error)}});unsubscribe=unsubscribe_,active||unsubscribe()}catch(err){onError?.(err)}})(),()=>unsubscribe()})()}(client,args)}}function createPublicClient(parameters){const{key="public",name="Public Client"}=parameters;return(0,createClient.U)({...parameters,key,name,type:"publicClient"}).extend(publicActions)}},"./node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{X:()=>localBatchGatewayRequest,J:()=>localBatchGatewayUrl});var abis=__webpack_require__("./node_modules/viem/_esm/constants/abis.js"),solidity=__webpack_require__("./node_modules/viem/_esm/constants/solidity.js"),errors_abi=__webpack_require__("./node_modules/viem/_esm/errors/abi.js"),slice=__webpack_require__("./node_modules/viem/_esm/utils/data/slice.js"),toFunctionSelector=__webpack_require__("./node_modules/viem/_esm/utils/hash/toFunctionSelector.js"),decodeAbiParameters=__webpack_require__("./node_modules/viem/_esm/utils/abi/decodeAbiParameters.js"),formatAbiItem=__webpack_require__("./node_modules/viem/_esm/utils/abi/formatAbiItem.js");var concat=__webpack_require__("./node_modules/viem/_esm/utils/data/concat.js"),encodeAbiParameters=__webpack_require__("./node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"),getAbiItem=__webpack_require__("./node_modules/viem/_esm/utils/abi/getAbiItem.js");const docsPath="/docs/contract/encodeErrorResult";function encodeErrorResult(parameters){const{abi,errorName,args}=parameters;let abiItem=abi[0];if(errorName){const item=(0,getAbiItem.iY)({abi,args,name:errorName});if(!item)throw new errors_abi.yy(errorName,{docsPath});abiItem=item}if("error"!==abiItem.type)throw new errors_abi.yy(void 0,{docsPath});const definition=(0,formatAbiItem.B)(abiItem),signature=(0,toFunctionSelector.V)(definition);let data="0x";if(args&&args.length>0){if(!abiItem.inputs)throw new errors_abi.ZP(abiItem.name,{docsPath});data=(0,encodeAbiParameters.h)(abiItem.inputs,args)}return(0,concat.aP)([signature,data])}const encodeFunctionResult_docsPath="/docs/contract/encodeFunctionResult";const localBatchGatewayUrl="x-batch-gateway:true";async function localBatchGatewayRequest(parameters){const{data,ccipRequest}=parameters,{args:[queries]}=function decodeFunctionData(parameters){const{abi,data}=parameters,signature=(0,slice.di)(data,0,4),description=abi.find(x=>"function"===x.type&&signature===(0,toFunctionSelector.V)((0,formatAbiItem.B)(x)));if(!description)throw new errors_abi.EB(signature,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:description.name,args:"inputs"in description&&description.inputs&&description.inputs.length>0?(0,decodeAbiParameters.n)(description.inputs,(0,slice.di)(data,4)):void 0}}({abi:abis.b2,data}),failures=[],responses=[];return await Promise.all(queries.map(async(query,i)=>{try{responses[i]=query.urls.includes(localBatchGatewayUrl)?await localBatchGatewayRequest({data:query.data,ccipRequest}):await ccipRequest(query),failures[i]=!1}catch(err){failures[i]=!0,responses[i]=function encodeError(error){return"HttpRequestError"===error.name&&error.status?encodeErrorResult({abi:abis.b2,errorName:"HttpError",args:[error.status,error.shortMessage]}):encodeErrorResult({abi:[solidity.Mc],errorName:"Error",args:["shortMessage"in error?error.shortMessage:error.message]})}(err)}})),function encodeFunctionResult(parameters){const{abi,functionName,result}=parameters;let abiItem=abi[0];if(functionName){const item=(0,getAbiItem.iY)({abi,name:functionName});if(!item)throw new errors_abi.Iz(functionName,{docsPath:encodeFunctionResult_docsPath});abiItem=item}if("function"!==abiItem.type)throw new errors_abi.Iz(void 0,{docsPath:encodeFunctionResult_docsPath});if(!abiItem.outputs)throw new errors_abi.MR(abiItem.name,{docsPath:encodeFunctionResult_docsPath});const values=(()=>{if(0===abiItem.outputs.length)return[];if(1===abiItem.outputs.length)return[result];if(Array.isArray(result))return result;throw new errors_abi.dm(result)})();return(0,encodeAbiParameters.h)(abiItem.outputs,values)}({abi:abis.b2,functionName:"query",result:[failures,responses]})}}}]);