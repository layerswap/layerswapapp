{"version":3,"file":"8530.59b14edd.iframe.bundle.js","mappings":";;;;;;;;;;;;;;AAwwBA;;;;;;;;;;;;;AAcA;;;;;;;;;AAUA;;;;;;;AAQA;;;;;;;AAQA;;;;;;;AAQA;;;;;;;AAQA;;;;;;AAOA;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;;;;;;;;;AAcA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA;;;;;;;;;;;AAWA;;;;;;;AAQA;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;;;;;;;;AASA;;;;;AAOA;;;;;;;;;AAUA;;;;;;AAMA;;;;;;;;AASA;;;;;;;AAQA;;;;;;;;;;;AAaA;;;;;;;;;;AAWA;;;;;;;;;AASA;AACA;;;;;;;;;;AAWA;AACA;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;AAUA;;;;;;;;;;AAWA;;;;;;;;AASA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;;;;;;;;;;AAWA;;;;;;;;AASA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOA;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAcA;;;;;;AAQA;;;;;;;AAQA;;;;;;;;;;;;;AAcA;;;;;;;AAQA;;;;;;AAOA;;;;;;AAMA;;;;;;AAOA;;;;;;;;;AAUA;AACA;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;AAoBA;AACA;;;;;;AAOA;;;;;;;;;AAUA;;;;;;;;AASA;;;;;;;;AAUA;;;;;;AAMA;;;;;;;;;AAUA;AACA;;;;;;;;;;;;;AAcA;AACA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;AAoBA;AACA;;;;;;;;;;;AAYA;AACA;;;;;;;AASA;;;;;;AAMA;;;;;;AAQA;;;;;;AAOA;;;;;;AAOA;;;;;;AAOA;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;AAoBA;AACA;;;;;;AAQA;;;;;;;;;;;AAWA;;;;;;AAQA;;;;;;AAMA;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAWA;;;;;;AAQA;;;;;;;AAQA;;;;;;AAMA;;;;;;;;;;;;AAcA;;;;;;;;;;AAWA;;;;;;;;;;AAUA;;;;;;;;;AAUA;AA63JA;AACA;;AAGA;AC/vKA;;;;;;;;;;;AAAA;;;;;AAAA;;;;AAAA;;;;AAAA;;;;AACA;;;;;;;AACA;;;AAgDA;AAquBA;AAEA;AAmPA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;AAQA;;AAEA;;;;;AAKA;;;AAGA;;AAEA;;;AAIA;AA6ZA;;AAGA;;;;;;;;AAkCA;;;;;;AAMA;;;;;;;;;;AAUA;;;;;AAMA;;;;;;;;;;;;AA0FA;;;AAIA;;;;;;;AAOA;;;;;AAMA;;;;;;;;AAQA;AACA;;AAEA;;;AAIA;;;;AAKA;;;;;AAKA;AACA;AAEA;AACA;AAEA;AAqKA;AACA;;AAEA;AACA;AACA;;AAGA;;;;;;;;;AA2BA;;AAEA;AAEA;;;;;;;;AAQA;AACA;;AAEA;;;AAIA;;AAGA;;;;AAIA;;;;;AAKA;;;;AAIA;;AAqDA;;;;;;;;;;;;AA2BA;;;;;AAKA;AACA;AACA;AACA;;;;;;;AAOA;;AAEA;;;;;;;AAOA;;;;;AAKA;;AAEA;;;;;AAMA;;;;;;;;;;;;;;;;;;AAkBA;;AAGA;;AAEA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AAEA;;AA41DA;AACA;AACA;;AAEA;AAEA;;;;;;;;;;;;;;AA+DA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA;;;;;;;;;;;;;AAaA;;;;;;;;;;AAUA;;;;;AAMA;;;AAGA;;;AAIA;;;;;;AAMA;;AAGA;;;;;;;AAOA;;;AAIA;AACA;;;;;AAKA;;AAEA;;;AAIA;;;;;;;;AAsEA;;;;;;AAOA;;;;;;;;AAqBA;;;;;;AAOA;;;;;;AAmBA;;;;;;AAOA;AA8HA;;;;;;;;AAWA;;;;;AAyOA;AACA;;;;AAKA;;;AAGA;AAEA;;;AAkFA;;;;;;;;;;;;;;AAeA;;;;;AAKA;;;AAGA;;;;AAKA;;;AAsCA;;;AAsEA;;AAEA;;AAEA;AAEA;AACA;;AAGA;;;;;;;;AAQA;;AAEA;;;;;;;;AAQA;;;;;;AAOA;;;;;;AA8FA;;AAEA;AAEA;;;;;;AAOA;;AAEA;AAEA;;AA4CA;;AA0BA;;AAuBA;;;AAsBA;;AAkDA;AA4HA;AACA;AACA;;;;;;;AAQA;;;;AAIA;AAEA;;;;AAIA;AACA;AACA;;;;;AAMA;;;AAIA;;;;;AAMA;;;;AAKA;;;;AAKA;;;;;;AAg+CA;;;;AAKA;;;AAGA;;;AAIA;;;;;;AAMA;;;;AAKA;;;;AAKA;;AAGA;;;;AA6DA;;AAGA;;;;;AAKA;;;AAGA;;;AAIA;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;AAiBA;;;;AAKA;;;;AAKA;AACA;AAEA;;;;;;;AAOA;AACA;;AAEA;;;;AAKA;AACA;;;AAIA;;;;;;;;;;;;;;;AAeA;AAEA;;;AAuMA;;AAEA;;;;;;AAOA;;AAGA;;;AAIA;;;;AAKA;;;;AAKA;;;;;AAMA;;AAGA;;AAGA;;;AAIA;;AAGA;AACA;;;AAIA;;;;;AAKA;;;AAIA;;;AAGA;AAEA;;;;AAi4BA;;AAGA;;;;;AAMA;;AAGA;;;AAIA;;;AAGA;AAEA;;;;;;AAOA;;;;;;;;AAyFA;;;AAIA;;;;AAKA;;;;;AAKA;AAEA;;;;AAKA;;AAGA;;;AAIA;;AAGA;AACA;;;AAIA;;;;;AAMA;;;AASA;;;AAIA;;AAGA;;;;;;AAOA;;;AAGA;AACA;AACA;;;;;AAMA;;;;;;;;;;;;;;AA2bA;;;;;;;;;;AAUA;;;;;AAMA;;;;AAKA;AACA;AAIA;AAIA;AAIA;AACA;AACA;AAEA;;;AAIA;;;AAGA;;AAEA;;AAEA;;;;;;;;;AAUA;;AAEA;;;AAIA;;;;AAKA;;;AASA;;;AAIA;;AAGA;;;;;;AAOA;;;AAGA;AACA;AACA;;;;;AAMA;;;;;AA0QA;;;;AAKA;;AAGA;;AAGA;;AAGA;;;;AAKA;;;;;;;AAOA;;;AAGA;;;;AAIA;;AAGA;;;;;;;;;AASA;AACA;;AAGA;;;;;;;;AAQA;;;;;;;AAOA;;;;;;AAOA;;;;;AAMA;;;;;;;AAQA;AACA;;AAGA;;;AAyEA;;;;AAKA;;;;AAKA;;;;AAKA;;;;;;AAMA;AAEA;;;;;AAKA;;;;AAKA;;AAGA;;AAGA;;;;;;AAOA;;;;;;AAMA;;AAGA;AACA;;;AAIA;;;;;AAMA;;AAGA;;;;AAKA;;;AAIA;;;;;AAMA;;AAGA;;;AAIA;;;AAGA;AAEA;;;;AAIA;;;;;;;AAUA;AAKA;;;;;AAkeA;;AAGA;;;;;;;AAOA;AAEA;;;AAIA;;;AAIA;;AAGA;;;;;;;;ACx0WA;;;;;;;;AAQA;;;;;;;;AAQA;;;;;AAKA;;;;AAIA;;;;;;;AAOA;;;;;AAKA;;;;;;;;AAQA;;;;AAIA;;;;;;;AAOA;;;;;;AAMA;AACA;AACA;AACA;;;;;;;;AAQA;;;;;;;;;;;;;;AAcA;;;;;AAKA;;;;AAIA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;AAEA;;;;;;;AAOA;;;;;;;;AAQA;;;;;AAKA;;AAEA;;;;;;;;;;;;AAkBA;;;;;;;AAOA;;;;;AAKA","sources":["webpack://layerswap/./node_modules/@fuel-ts/account/dist/index.mjs","webpack://layerswap/./node_modules/@tonconnect/ui/lib/index.mjs","webpack://layerswap/./node_modules/react-hot-toast/dist/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/providers/chains.ts\nvar CHAIN_IDS = {\n  eth: {\n    mainnet: 1,\n    sepolia: 11155111,\n    foundry: 31337\n  },\n  fuel: {\n    devnet: 0,\n    testnet: 0,\n    mainnet: 9889\n  }\n};\n\n// src/assets/utils/network.ts\nvar getDefaultChainId = /* @__PURE__ */ __name((networkType) => {\n  if (networkType === \"ethereum\") {\n    return CHAIN_IDS.eth.sepolia;\n  }\n  if (networkType === \"fuel\") {\n    return CHAIN_IDS.fuel.testnet;\n  }\n  return void 0;\n}, \"getDefaultChainId\");\nvar getAssetNetwork = /* @__PURE__ */ __name(({\n  asset,\n  chainId,\n  networkType\n}) => {\n  const network = asset.networks.find(\n    (item) => item.chainId === chainId && item.type === networkType\n  );\n  return network;\n}, \"getAssetNetwork\");\nvar getAssetWithNetwork = /* @__PURE__ */ __name(({\n  asset,\n  chainId,\n  networkType\n}) => {\n  const { networks: _, ...assetRest } = asset;\n  const chainIdToUse = chainId ?? getDefaultChainId(networkType);\n  if (chainIdToUse === void 0) {\n    return void 0;\n  }\n  const assetNetwork = getAssetNetwork({\n    asset,\n    chainId: chainIdToUse,\n    networkType\n  });\n  if (!assetNetwork) {\n    return void 0;\n  }\n  return {\n    ...assetRest,\n    ...assetNetwork\n  };\n}, \"getAssetWithNetwork\");\nvar getAssetEth = /* @__PURE__ */ __name((asset, chainId) => getAssetWithNetwork({\n  asset,\n  networkType: \"ethereum\",\n  chainId\n}), \"getAssetEth\");\nvar getAssetFuel = /* @__PURE__ */ __name((asset, chainId) => getAssetWithNetwork({\n  asset,\n  networkType: \"fuel\",\n  chainId\n}), \"getAssetFuel\");\n\n// src/assets/utils/url.ts\nvar DELIMITER_PATH = \"/\";\nvar trimRegex = /^\\/|\\/$/g;\nvar trimPath = /* @__PURE__ */ __name((path = \"\") => path.replace(trimRegex, \"\"), \"trimPath\");\nfunction urlJoin(baseUrl, ...paths) {\n  const hasBaseUrl = baseUrl !== null && baseUrl !== void 0;\n  const rootPath = baseUrl?.[0] === \"/\" && baseUrl.length > 1;\n  const allPaths = [baseUrl, ...paths].filter(Boolean).map(trimPath);\n  if (rootPath && hasBaseUrl) {\n    allPaths.unshift(\"\");\n  }\n  return allPaths.join(DELIMITER_PATH);\n}\n__name(urlJoin, \"urlJoin\");\n\n// src/assets/utils/resolveIconPaths.ts\nfunction resolveIconPaths(assets2, basePath = \"./\") {\n  return assets2.map((asset) => ({\n    ...asset,\n    icon: urlJoin(basePath, asset.icon)\n  }));\n}\n__name(resolveIconPaths, \"resolveIconPaths\");\n\n// src/assets/utils/fuelAssetsBaseUrl.ts\nvar fuelAssetsBaseUrl = \"https://assets.fuel.network/providers/\";\n\n// src/assets/assets.ts\nvar rawAssets = [\n  {\n    name: \"Ethereum\",\n    symbol: \"ETH\",\n    icon: \"eth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.sepolia,\n        decimals: 18\n      },\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.foundry,\n        decimals: 18\n      },\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.devnet,\n        decimals: 9,\n        assetId: \"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07\"\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.testnet,\n        decimals: 9,\n        assetId: \"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07\"\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        decimals: 9,\n        assetId: \"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07\"\n      }\n    ]\n  },\n  {\n    name: \"WETH\",\n    symbol: \"WETH\",\n    icon: \"weth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"weETH\",\n    symbol: \"weETH\",\n    icon: \"weETH.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"rsETH\",\n    symbol: \"rsETH\",\n    icon: \"rsETH.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"rETH\",\n    symbol: \"rETH\",\n    icon: \"reth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xae78736cd615f374d3085123a210448e74fc6393\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"wbETH\",\n    symbol: \"wbETH\",\n    icon: \"wbeth.png\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xa2E3356610840701BDf5611a53974510Ae27E2e1\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"rstETH\",\n    symbol: \"rstETH\",\n    icon: \"rstETH.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x7a4EffD87C2f3C55CA251080b1343b605f327E3a\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"amphrETH\",\n    symbol: \"amphrETH\",\n    icon: \"amphrETH.png\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x5fD13359Ba15A84B76f7F87568309040176167cd\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"Manta mBTC\",\n    symbol: \"Manta mBTC\",\n    icon: \"manta-mbtc.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x4041381e947CFD3D483d67a25C6aa9Dc924250c5\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"Manta mETH\",\n    symbol: \"Manta mETH\",\n    icon: \"manta-meth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x8CdF550C04Bc9B9F10938368349C9c8051A772b6\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"Manta mUSD\",\n    symbol: \"Manta mUSD\",\n    icon: \"manta-musd.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x3f24E1d7a973867fC2A03fE199E5502514E0e11E\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"pumpBTC\",\n    symbol: \"pumpBTC\",\n    icon: \"pumpbtc.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xf469fbd2abcd6b9de8e169d128226c0fc90a012e\",\n        decimals: 8\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f\",\n        decimals: 8\n      }\n    ]\n  },\n  {\n    name: \"FBTC\",\n    symbol: \"FBTC\",\n    icon: \"fbtc.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xc96de26018a54d51c097160568752c4e3bd6c364\",\n        decimals: 8\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a\",\n        decimals: 8\n      }\n    ]\n  },\n  {\n    name: \"SolvBTC\",\n    symbol: \"SolvBTC\",\n    icon: \"solvBTC.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x7a56e1c57c7475ccf742a1832b028f0456652f97\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"SolvBTC.BBN\",\n    symbol: \"SolvBTC.BBN\",\n    icon: \"SolvBTC.BBN.png\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xd9d920aa40f578ab794426f5c90f6c731d159def\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"Mantle mETH\",\n    symbol: \"Mantle mETH\",\n    icon: \"mantle-meth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"sDAI\",\n    symbol: \"sDAI\",\n    icon: \"sdai.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x83f20f44975d03b1b09e64809b757c47f942beea\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"USDT\",\n    symbol: \"USDT\",\n    icon: \"usdt.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n        decimals: 6\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e\",\n        decimals: 6\n      }\n    ]\n  },\n  {\n    name: \"USDC\",\n    symbol: \"USDC\",\n    icon: \"usdc.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n        decimals: 6\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b\",\n        decimals: 6\n      }\n    ]\n  },\n  {\n    name: \"USDe\",\n    symbol: \"USDe\",\n    icon: \"USDe.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x4c9edd5852cd905f086c759e8383e09bff1e68b3\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"sUSDe\",\n    symbol: \"sUSDe\",\n    icon: \"sUSDe.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x9d39a5de30e57443bff2a8307a4256c8797a3497\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"rsUSDe\",\n    symbol: \"rsUSDe\",\n    icon: \"rsUSDe.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"wstETH\",\n    symbol: \"wstETH\",\n    icon: \"wsteth.svg\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"ezETH\",\n    symbol: \"ezETH\",\n    icon: \"ezeth.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xbf5495Efe5DB9ce00f80364C8B423567e58d2110\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"pzETH\",\n    symbol: \"pzETH\",\n    icon: \"pzETH.webp\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"Re7LRT\",\n    symbol: \"Re7LRT\",\n    icon: \"Re7LRT.png\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995\",\n        decimals: 9\n      }\n    ]\n  },\n  {\n    name: \"steakLRT\",\n    symbol: \"steakLRT\",\n    icon: \"steakLRT.png\",\n    networks: [\n      {\n        type: \"ethereum\",\n        chainId: CHAIN_IDS.eth.mainnet,\n        address: \"0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc\",\n        decimals: 18\n      },\n      {\n        type: \"fuel\",\n        chainId: CHAIN_IDS.fuel.mainnet,\n        contractId: \"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8\",\n        assetId: \"0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30\",\n        decimals: 9\n      }\n    ]\n  }\n];\nvar assets = resolveIconPaths(rawAssets, fuelAssetsBaseUrl);\n\n// src/assets/asset-api.ts\nvar networks = {\n  mainnet: \"https://mainnet-explorer.fuel.network\",\n  testnet: \"https://explorer-indexer-testnet.fuel.network\"\n};\nvar request = /* @__PURE__ */ __name(async (url, slug) => {\n  const response = await fetch(`${url}${slug}`, {\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Accept\": \"application/json\"\n    }\n  });\n  try {\n    return await response.json();\n  } catch (error) {\n    return null;\n  }\n}, \"request\");\nvar buildQueryString = /* @__PURE__ */ __name((parameters) => {\n  const query = new URLSearchParams();\n  Object.entries(parameters).forEach(([key, value]) => {\n    query.set(key, value.toString());\n  });\n  return query.size > 0 ? `?${query.toString()}` : \"\";\n}, \"buildQueryString\");\nvar getAssetById = /* @__PURE__ */ __name((opts) => {\n  const { network = \"mainnet\", assetId } = opts;\n  const url = networks[network];\n  return request(url, `/assets/${assetId}`);\n}, \"getAssetById\");\nvar getAssetsByOwner = /* @__PURE__ */ __name(async (opts) => {\n  const { network = \"mainnet\", owner, pagination = { last: 10 } } = opts;\n  const url = networks[network];\n  const { last } = pagination;\n  const queryString = buildQueryString({ last });\n  const response = await request(url, `/accounts/${owner}/assets${queryString}`);\n  if (!response) {\n    return { data: [], pageInfo: { count: 0 } };\n  }\n  return response;\n}, \"getAssetsByOwner\");\n\n// src/account.ts\nimport { UTXO_ID_LEN as UTXO_ID_LEN3 } from \"@fuel-ts/abi-coder\";\nimport { Address as Address5 } from \"@fuel-ts/address\";\nimport { randomBytes as randomBytes2 } from \"@fuel-ts/crypto\";\nimport { ErrorCode as ErrorCode20, FuelError as FuelError22 } from \"@fuel-ts/errors\";\nimport { bn as bn22 } from \"@fuel-ts/math\";\nimport { InputType as InputType8, OutputType as OutputType10 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify17, hexlify as hexlify18, isDefined as isDefined4 } from \"@fuel-ts/utils\";\nimport { clone as clone9 } from \"ramda\";\n\n// src/providers/coin-quantity.ts\nimport { bn } from \"@fuel-ts/math\";\nimport { hexlify } from \"@fuel-ts/utils\";\nvar coinQuantityfy = /* @__PURE__ */ __name((coinQuantityLike) => {\n  let assetId;\n  let amount;\n  let max;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1];\n    max = coinQuantityLike[2] ?? void 0;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId;\n    max = coinQuantityLike.max ?? void 0;\n  }\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n    max: max ? bn(max) : void 0\n  };\n}, \"coinQuantityfy\");\nvar addAmountToCoinQuantities = /* @__PURE__ */ __name((params) => {\n  const { amount, assetId } = params;\n  const coinQuantities = [...params.coinQuantities];\n  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);\n  if (assetIdx !== -1) {\n    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);\n  } else {\n    coinQuantities.push({ assetId, amount });\n  }\n  return coinQuantities;\n}, \"addAmountToCoinQuantities\");\n\n// src/providers/provider.ts\nimport { Address as Address2, isB256 } from \"@fuel-ts/address\";\nimport { ErrorCode as ErrorCode17, FuelError as FuelError19 } from \"@fuel-ts/errors\";\nimport { bn as bn18 } from \"@fuel-ts/math\";\nimport { InputMessageCoder as InputMessageCoder2, TransactionCoder as TransactionCoder7, TransactionType as TransactionType11 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify13, hexlify as hexlify17, DateTime as DateTime2, isDefined as isDefined3, sleep as sleep2 } from \"@fuel-ts/utils\";\nimport { checkFuelCoreVersionCompatibility, versions } from \"@fuel-ts/versions\";\nimport { GraphQLClient } from \"graphql-request\";\nimport gql2 from \"graphql-tag\";\nimport { clone as clone8 } from \"ramda\";\n\n// src/providers/__generated__/operations.ts\nimport gql from \"graphql-tag\";\nvar InputCoinFragmentDoc = gql`\n    fragment InputCoinFragment on InputCoin {\n  type: __typename\n  utxoId\n  owner\n  amount\n  assetId\n  txPointer\n  coinWitnessIndex: witnessIndex\n  predicateGasUsed\n  predicate\n  predicateData\n}\n    `;\nvar InputMessageFragmentDoc = gql`\n    fragment InputMessageFragment on InputMessage {\n  type: __typename\n  sender\n  recipient\n  amount\n  nonce\n  messageWitnessIndex: witnessIndex\n  predicateGasUsed\n  data\n  predicate\n  predicateData\n}\n    `;\nvar InputContractFragmentDoc = gql`\n    fragment InputContractFragment on InputContract {\n  type: __typename\n  utxoId\n  balanceRoot\n  stateRoot\n  txPointer\n  contractId\n}\n    `;\nvar OutputCoinFragmentDoc = gql`\n    fragment OutputCoinFragment on CoinOutput {\n  type: __typename\n  to\n  amount\n  assetId\n}\n    `;\nvar OutputContractFragmentDoc = gql`\n    fragment OutputContractFragment on ContractOutput {\n  type: __typename\n  inputIndex\n  balanceRoot\n  stateRoot\n}\n    `;\nvar OutputChangeFragmentDoc = gql`\n    fragment OutputChangeFragment on ChangeOutput {\n  type: __typename\n  to\n  amount\n  assetId\n}\n    `;\nvar OutputVariableFragmentDoc = gql`\n    fragment OutputVariableFragment on VariableOutput {\n  type: __typename\n  to\n  amount\n  assetId\n}\n    `;\nvar OutputContractCreatedFragmentDoc = gql`\n    fragment OutputContractCreatedFragment on ContractCreated {\n  type: __typename\n  contract\n  stateRoot\n}\n    `;\nvar SubmittedStatusFragmentDoc = gql`\n    fragment SubmittedStatusFragment on SubmittedStatus {\n  type: __typename\n  time\n}\n    `;\nvar ReceiptFragmentDoc = gql`\n    fragment receiptFragment on Receipt {\n  id\n  pc\n  is\n  to\n  toAddress\n  amount\n  assetId\n  gas\n  param1\n  param2\n  val\n  ptr\n  digest\n  reason\n  ra\n  rb\n  rc\n  rd\n  len\n  receiptType\n  result\n  gasUsed\n  data\n  sender\n  recipient\n  nonce\n  contractId\n  subId\n}\n    `;\nvar SuccessStatusFragmentDoc = gql`\n    fragment SuccessStatusFragment on SuccessStatus {\n  type: __typename\n  time\n  programState {\n    returnType\n    data\n  }\n  receipts {\n    ...receiptFragment\n  }\n  totalGas\n  totalFee\n}\n    ${ReceiptFragmentDoc}`;\nvar SuccessStatusWithBlockIdFragmentDoc = gql`\n    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {\n  ...SuccessStatusFragment\n  block {\n    id\n  }\n}\n    ${SuccessStatusFragmentDoc}`;\nvar MalleableTransactionFieldsFragmentDoc = gql`\n    fragment malleableTransactionFieldsFragment on Transaction {\n  receiptsRoot\n  inputs {\n    type: __typename\n    ... on InputCoin {\n      txPointer\n    }\n    ... on InputContract {\n      txPointer\n    }\n  }\n  outputs {\n    type: __typename\n    ... on CoinOutput {\n      to\n      amount\n      assetId\n    }\n    ... on ContractOutput {\n      inputIndex\n      balanceRoot\n      stateRoot\n    }\n    ... on ChangeOutput {\n      to\n      amount\n      assetId\n    }\n    ... on VariableOutput {\n      to\n      amount\n      assetId\n    }\n    ... on ContractCreated {\n      contract\n      stateRoot\n    }\n  }\n}\n    `;\nvar FailureStatusFragmentDoc = gql`\n    fragment FailureStatusFragment on FailureStatus {\n  type: __typename\n  totalGas\n  totalFee\n  time\n  reason\n  receipts {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentDoc}`;\nvar FailureStatusWithBlockIdFragmentDoc = gql`\n    fragment FailureStatusWithBlockIdFragment on FailureStatus {\n  ...FailureStatusFragment\n  block {\n    id\n  }\n}\n    ${FailureStatusFragmentDoc}`;\nvar SqueezedOutStatusFragmentDoc = gql`\n    fragment SqueezedOutStatusFragment on SqueezedOutStatus {\n  type: __typename\n  reason\n}\n    `;\nvar PreconfirmationSuccessStatusFragmentDoc = gql`\n    fragment PreconfirmationSuccessStatusFragment on PreconfirmationSuccessStatus {\n  type: __typename\n  totalGas\n  totalFee\n  resolvedOutputs {\n    utxoId\n    output {\n      type: __typename\n      ... on CoinOutput {\n        to\n        amount\n        assetId\n      }\n      ... on ContractOutput {\n        inputIndex\n        balanceRoot\n        stateRoot\n      }\n      ... on ChangeOutput {\n        to\n        amount\n        assetId\n      }\n      ... on VariableOutput {\n        to\n        amount\n        assetId\n      }\n      ... on ContractCreated {\n        contract\n        stateRoot\n      }\n    }\n  }\n  preconfirmationReceipts: receipts {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentDoc}`;\nvar PreconfirmationFailureStatusFragmentDoc = gql`\n    fragment PreconfirmationFailureStatusFragment on PreconfirmationFailureStatus {\n  type: __typename\n  reason\n  totalGas\n  totalFee\n  resolvedOutputs {\n    utxoId\n    output {\n      type: __typename\n      ... on CoinOutput {\n        to\n        amount\n        assetId\n      }\n      ... on ContractOutput {\n        inputIndex\n        balanceRoot\n        stateRoot\n      }\n      ... on ChangeOutput {\n        to\n        amount\n        assetId\n      }\n      ... on VariableOutput {\n        to\n        amount\n        assetId\n      }\n      ... on ContractCreated {\n        contract\n        stateRoot\n      }\n    }\n  }\n  preconfirmationReceipts: receipts {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentDoc}`;\nvar TransactionStatusSubscriptionFragmentDoc = gql`\n    fragment transactionStatusSubscriptionFragment on TransactionStatus {\n  ... on SubmittedStatus {\n    ...SubmittedStatusFragment\n  }\n  ... on SuccessStatus {\n    ...SuccessStatusWithBlockIdFragment\n    transaction {\n      ...malleableTransactionFieldsFragment\n    }\n  }\n  ... on FailureStatus {\n    ...FailureStatusWithBlockIdFragment\n    transaction {\n      ...malleableTransactionFieldsFragment\n    }\n  }\n  ... on SqueezedOutStatus {\n    ...SqueezedOutStatusFragment\n  }\n  ... on PreconfirmationSuccessStatus {\n    ...PreconfirmationSuccessStatusFragment\n  }\n  ... on PreconfirmationFailureStatus {\n    ...PreconfirmationFailureStatusFragment\n  }\n}\n    ${SubmittedStatusFragmentDoc}\n${SuccessStatusWithBlockIdFragmentDoc}\n${MalleableTransactionFieldsFragmentDoc}\n${FailureStatusWithBlockIdFragmentDoc}\n${SqueezedOutStatusFragmentDoc}\n${PreconfirmationSuccessStatusFragmentDoc}\n${PreconfirmationFailureStatusFragmentDoc}`;\nvar TransactionStatusFragmentDoc = gql`\n    fragment transactionStatusFragment on TransactionStatus {\n  ... on SubmittedStatus {\n    ...SubmittedStatusFragment\n  }\n  ... on SuccessStatus {\n    ...SuccessStatusFragment\n  }\n  ... on FailureStatus {\n    ...FailureStatusFragment\n  }\n  ... on SqueezedOutStatus {\n    ...SqueezedOutStatusFragment\n  }\n}\n    ${SubmittedStatusFragmentDoc}\n${SuccessStatusFragmentDoc}\n${FailureStatusFragmentDoc}\n${SqueezedOutStatusFragmentDoc}`;\nvar TransactionFragmentDoc = gql`\n    fragment transactionFragment on Transaction {\n  id\n  rawPayload\n  status {\n    ...transactionStatusFragment\n  }\n}\n    ${TransactionStatusFragmentDoc}`;\nvar TransactionRawPayloadFragmentDoc = gql`\n    fragment transactionRawPayloadFragment on Transaction {\n  id\n  rawPayload\n}\n    `;\nvar InputEstimatePredicatesFragmentDoc = gql`\n    fragment inputEstimatePredicatesFragment on Input {\n  ... on InputCoin {\n    predicateGasUsed\n  }\n  ... on InputMessage {\n    predicateGasUsed\n  }\n}\n    `;\nvar TransactionEstimatePredicatesFragmentDoc = gql`\n    fragment transactionEstimatePredicatesFragment on Transaction {\n  inputs {\n    ...inputEstimatePredicatesFragment\n  }\n}\n    ${InputEstimatePredicatesFragmentDoc}`;\nvar DryRunFailureAssembleTxFragmentDoc = gql`\n    fragment dryRunFailureAssembleTxFragment on DryRunFailureStatus {\n  type: __typename\n  reason\n  receipts {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentDoc}`;\nvar DryRunSuccessAssembleTxFragmentDoc = gql`\n    fragment dryRunSuccessAssembleTxFragment on DryRunSuccessStatus {\n  type: __typename\n  receipts {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentDoc}`;\nvar DryRunFailureStatusFragmentDoc = gql`\n    fragment dryRunFailureStatusFragment on DryRunFailureStatus {\n  type: __typename\n  totalGas\n  totalFee\n  reason\n  programState {\n    returnType\n    data\n  }\n}\n    `;\nvar DryRunSuccessStatusFragmentDoc = gql`\n    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {\n  type: __typename\n  totalGas\n  totalFee\n  programState {\n    returnType\n    data\n  }\n}\n    `;\nvar DryRunTransactionStatusFragmentDoc = gql`\n    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {\n  ... on DryRunFailureStatus {\n    ...dryRunFailureStatusFragment\n  }\n  ... on DryRunSuccessStatus {\n    ...dryRunSuccessStatusFragment\n  }\n}\n    ${DryRunFailureStatusFragmentDoc}\n${DryRunSuccessStatusFragmentDoc}`;\nvar DryRunTransactionExecutionStatusFragmentDoc = gql`\n    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {\n  id\n  status {\n    ...dryRunTransactionStatusFragment\n  }\n  receipts {\n    ...receiptFragment\n  }\n}\n    ${DryRunTransactionStatusFragmentDoc}\n${ReceiptFragmentDoc}`;\nvar BlockFragmentDoc = gql`\n    fragment blockFragment on Block {\n  id\n  height\n  header {\n    time\n    daHeight\n    stateTransitionBytecodeVersion\n    transactionsCount\n    transactionsRoot\n    messageOutboxRoot\n    eventInboxRoot\n    prevRoot\n    applicationHash\n  }\n  transactions {\n    id\n  }\n}\n    `;\nvar CoinFragmentDoc = gql`\n    fragment coinFragment on Coin {\n  type: __typename\n  utxoId\n  amount\n  assetId\n  blockCreated\n  txCreatedIdx\n}\n    `;\nvar MessageCoinFragmentDoc = gql`\n    fragment messageCoinFragment on MessageCoin {\n  type: __typename\n  sender\n  recipient\n  nonce\n  amount\n  assetId\n  daHeight\n}\n    `;\nvar MessageFragmentDoc = gql`\n    fragment messageFragment on Message {\n  amount\n  sender\n  recipient\n  data\n  daHeight\n}\n    `;\nvar GetMessageFragmentDoc = gql`\n    fragment getMessageFragment on Message {\n  ...messageFragment\n  nonce\n}\n    ${MessageFragmentDoc}`;\nvar MessageProofFragmentDoc = gql`\n    fragment messageProofFragment on MessageProof {\n  messageProof {\n    proofSet\n    proofIndex\n  }\n  blockProof {\n    proofSet\n    proofIndex\n  }\n  messageBlockHeader {\n    version\n    id\n    daHeight\n    consensusParametersVersion\n    stateTransitionBytecodeVersion\n    transactionsCount\n    messageReceiptCount\n    transactionsRoot\n    messageOutboxRoot\n    eventInboxRoot\n    height\n    prevRoot\n    time\n    applicationHash\n  }\n  commitBlockHeader {\n    version\n    id\n    daHeight\n    consensusParametersVersion\n    stateTransitionBytecodeVersion\n    transactionsCount\n    messageReceiptCount\n    transactionsRoot\n    messageOutboxRoot\n    eventInboxRoot\n    height\n    prevRoot\n    time\n    applicationHash\n  }\n  sender\n  recipient\n  amount\n  data\n}\n    `;\nvar TxParametersFragmentDoc = gql`\n    fragment TxParametersFragment on TxParameters {\n  version\n  maxInputs\n  maxOutputs\n  maxWitnesses\n  maxGasPerTx\n  maxSize\n  maxBytecodeSubsections\n}\n    `;\nvar PredicateParametersFragmentDoc = gql`\n    fragment PredicateParametersFragment on PredicateParameters {\n  version\n  maxPredicateLength\n  maxPredicateDataLength\n  maxGasPerPredicate\n  maxMessageDataLength\n}\n    `;\nvar ScriptParametersFragmentDoc = gql`\n    fragment ScriptParametersFragment on ScriptParameters {\n  version\n  maxScriptLength\n  maxScriptDataLength\n}\n    `;\nvar ContractParametersFragmentDoc = gql`\n    fragment ContractParametersFragment on ContractParameters {\n  version\n  contractMaxSize\n  maxStorageSlots\n}\n    `;\nvar FeeParametersFragmentDoc = gql`\n    fragment FeeParametersFragment on FeeParameters {\n  version\n  gasPriceFactor\n  gasPerByte\n}\n    `;\nvar DependentCostFragmentDoc = gql`\n    fragment DependentCostFragment on DependentCost {\n  ... on LightOperation {\n    type: __typename\n    base\n    unitsPerGas\n  }\n  ... on HeavyOperation {\n    type: __typename\n    base\n    gasPerUnit\n  }\n}\n    `;\nvar GasCostsFragmentDoc = gql`\n    fragment GasCostsFragment on GasCosts {\n  contractRoot {\n    ...DependentCostFragment\n  }\n  stateRoot {\n    ...DependentCostFragment\n  }\n  vmInitialization {\n    ...DependentCostFragment\n  }\n  s256 {\n    ...DependentCostFragment\n  }\n  ecr1\n  newStoragePerByte\n}\n    ${DependentCostFragmentDoc}`;\nvar ConsensusParametersFragmentDoc = gql`\n    fragment consensusParametersFragment on ConsensusParameters {\n  version\n  txParams {\n    ...TxParametersFragment\n  }\n  predicateParams {\n    ...PredicateParametersFragment\n  }\n  scriptParams {\n    ...ScriptParametersFragment\n  }\n  contractParams {\n    ...ContractParametersFragment\n  }\n  feeParams {\n    ...FeeParametersFragment\n  }\n  gasCosts {\n    ...GasCostsFragment\n  }\n  baseAssetId\n  chainId\n}\n    ${TxParametersFragmentDoc}\n${PredicateParametersFragmentDoc}\n${ScriptParametersFragmentDoc}\n${ContractParametersFragmentDoc}\n${FeeParametersFragmentDoc}\n${GasCostsFragmentDoc}`;\nvar ChainInfoFragmentDoc = gql`\n    fragment chainInfoFragment on ChainInfo {\n  name\n  daHeight\n  consensusParameters {\n    ...consensusParametersFragment\n  }\n  latestBlock {\n    header {\n      consensusParametersVersion\n    }\n  }\n}\n    ${ConsensusParametersFragmentDoc}`;\nvar ContractBalanceFragmentDoc = gql`\n    fragment contractBalanceFragment on ContractBalance {\n  contract\n  amount\n  assetId\n}\n    `;\nvar PageInfoFragmentDoc = gql`\n    fragment pageInfoFragment on PageInfo {\n  hasPreviousPage\n  hasNextPage\n  startCursor\n  endCursor\n}\n    `;\nvar NodeInfoFragmentDoc = gql`\n    fragment nodeInfoFragment on NodeInfo {\n  utxoValidation\n  vmBacktrace\n  maxTx\n  maxDepth\n  nodeVersion\n  indexation {\n    balances\n    coinsToSpend\n    assetMetadata\n  }\n}\n    `;\nvar RelayedTransactionStatusFragmentDoc = gql`\n    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {\n  ... on RelayedTransactionFailed {\n    blockHeight\n    failure\n  }\n}\n    `;\nvar GetVersionDocument = gql`\n    query getVersion {\n  nodeInfo {\n    nodeVersion\n  }\n}\n    `;\nvar GetNodeInfoDocument = gql`\n    query getNodeInfo {\n  nodeInfo {\n    ...nodeInfoFragment\n  }\n}\n    ${NodeInfoFragmentDoc}`;\nvar GetChainDocument = gql`\n    query getChain {\n  chain {\n    ...chainInfoFragment\n  }\n}\n    ${ChainInfoFragmentDoc}`;\nvar GetChainAndNodeInfoDocument = gql`\n    query getChainAndNodeInfo {\n  chain {\n    ...chainInfoFragment\n  }\n  nodeInfo {\n    ...nodeInfoFragment\n  }\n}\n    ${ChainInfoFragmentDoc}\n${NodeInfoFragmentDoc}`;\nvar GetTransactionDocument = gql`\n    query getTransaction($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    ...transactionFragment\n  }\n}\n    ${TransactionFragmentDoc}`;\nvar GetTransactionWithReceiptsDocument = gql`\n    query getTransactionWithReceipts($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    id\n    rawPayload\n    status {\n      ... on SubmittedStatus {\n        ...SubmittedStatusFragment\n      }\n      ... on SuccessStatus {\n        ...SuccessStatusWithBlockIdFragment\n      }\n      ... on FailureStatus {\n        ...FailureStatusWithBlockIdFragment\n      }\n      ... on SqueezedOutStatus {\n        ...SqueezedOutStatusFragment\n      }\n      ... on PreconfirmationSuccessStatus {\n        ...PreconfirmationSuccessStatusFragment\n      }\n      ... on PreconfirmationFailureStatus {\n        ...PreconfirmationFailureStatusFragment\n      }\n    }\n  }\n}\n    ${SubmittedStatusFragmentDoc}\n${SuccessStatusWithBlockIdFragmentDoc}\n${FailureStatusWithBlockIdFragmentDoc}\n${SqueezedOutStatusFragmentDoc}\n${PreconfirmationSuccessStatusFragmentDoc}\n${PreconfirmationFailureStatusFragmentDoc}`;\nvar GetTransactionsDocument = gql`\n    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n  transactions(after: $after, before: $before, first: $first, last: $last) {\n    edges {\n      node {\n        rawPayload\n      }\n    }\n    pageInfo {\n      ...pageInfoFragment\n    }\n  }\n}\n    ${PageInfoFragmentDoc}`;\nvar GetTransactionsByOwnerDocument = gql`\n    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  transactionsByOwner(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...transactionFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentDoc}\n${TransactionFragmentDoc}`;\nvar EstimatePredicatesDocument = gql`\n    query estimatePredicates($encodedTransaction: HexString!) {\n  estimatePredicates(tx: $encodedTransaction) {\n    ...transactionEstimatePredicatesFragment\n  }\n}\n    ${TransactionEstimatePredicatesFragmentDoc}`;\nvar EstimatePredicatesAndGasPriceDocument = gql`\n    query estimatePredicatesAndGasPrice($encodedTransaction: HexString!, $blockHorizon: U32!) {\n  estimatePredicates(tx: $encodedTransaction) {\n    ...transactionEstimatePredicatesFragment\n  }\n  estimateGasPrice(blockHorizon: $blockHorizon) {\n    gasPrice\n  }\n}\n    ${TransactionEstimatePredicatesFragmentDoc}`;\nvar GetLatestBlockDocument = gql`\n    query getLatestBlock {\n  chain {\n    latestBlock {\n      ...blockFragment\n    }\n  }\n}\n    ${BlockFragmentDoc}`;\nvar GetLatestBlockHeightDocument = gql`\n    query getLatestBlockHeight {\n  chain {\n    latestBlock {\n      height\n    }\n  }\n}\n    `;\nvar GetBlockDocument = gql`\n    query getBlock($blockId: BlockId, $height: U32) {\n  block(id: $blockId, height: $height) {\n    ...blockFragment\n  }\n}\n    ${BlockFragmentDoc}`;\nvar GetBlockWithTransactionsDocument = gql`\n    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {\n  block(id: $blockId, height: $blockHeight) {\n    ...blockFragment\n    transactions {\n      ...transactionRawPayloadFragment\n    }\n  }\n}\n    ${BlockFragmentDoc}\n${TransactionRawPayloadFragmentDoc}`;\nvar GetBlocksDocument = gql`\n    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n  blocks(after: $after, before: $before, first: $first, last: $last) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...blockFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentDoc}\n${BlockFragmentDoc}`;\nvar GetCoinDocument = gql`\n    query getCoin($coinId: UtxoId!) {\n  coin(utxoId: $coinId) {\n    ...coinFragment\n    owner\n  }\n}\n    ${CoinFragmentDoc}`;\nvar GetCoinsDocument = gql`\n    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  coins(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...coinFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentDoc}\n${CoinFragmentDoc}`;\nvar GetCoinsToSpendDocument = gql`\n    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {\n  coinsToSpend(\n    owner: $owner\n    queryPerAsset: $queryPerAsset\n    excludedIds: $excludedIds\n  ) {\n    ...coinFragment\n    ...messageCoinFragment\n  }\n}\n    ${CoinFragmentDoc}\n${MessageCoinFragmentDoc}`;\nvar GetContractDocument = gql`\n    query getContract($contractId: ContractId!) {\n  contract(id: $contractId) {\n    bytecode\n    id\n  }\n}\n    `;\nvar GetContractBalanceDocument = gql`\n    query getContractBalance($contract: ContractId!, $asset: AssetId!) {\n  contractBalance(contract: $contract, asset: $asset) {\n    ...contractBalanceFragment\n  }\n}\n    ${ContractBalanceFragmentDoc}`;\nvar GetBalanceDocument = gql`\n    query getBalance($owner: Address!, $assetId: AssetId!) {\n  balance(owner: $owner, assetId: $assetId) {\n    amount\n  }\n}\n    `;\nvar GetBalanceV2Document = gql`\n    query getBalanceV2($owner: Address!, $assetId: AssetId!) {\n  balance(owner: $owner, assetId: $assetId) {\n    amountU128\n  }\n}\n    `;\nvar GetLatestGasPriceDocument = gql`\n    query getLatestGasPrice {\n  latestGasPrice {\n    gasPrice\n  }\n}\n    `;\nvar EstimateGasPriceDocument = gql`\n    query estimateGasPrice($blockHorizon: U32!) {\n  estimateGasPrice(blockHorizon: $blockHorizon) {\n    gasPrice\n  }\n}\n    `;\nvar GetBalancesDocument = gql`\n    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  balances(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        assetId\n        amount\n      }\n    }\n  }\n}\n    `;\nvar GetBalancesV2Document = gql`\n    query getBalancesV2($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int, $supportsPagination: Boolean!) {\n  balances(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo @include(if: $supportsPagination) {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        assetId\n        amountU128\n      }\n    }\n  }\n}\n    ${PageInfoFragmentDoc}`;\nvar GetMessagesDocument = gql`\n    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  messages(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...getMessageFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentDoc}\n${GetMessageFragmentDoc}`;\nvar DaCompressedBlockDocument = gql`\n    query daCompressedBlock($height: U32!) {\n  daCompressedBlock(height: $height) {\n    bytes\n  }\n}\n    `;\nvar GetMessageProofDocument = gql`\n    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {\n  messageProof(\n    transactionId: $transactionId\n    nonce: $nonce\n    commitBlockId: $commitBlockId\n    commitBlockHeight: $commitBlockHeight\n  ) {\n    ...messageProofFragment\n  }\n}\n    ${MessageProofFragmentDoc}`;\nvar GetMessageStatusDocument = gql`\n    query getMessageStatus($nonce: Nonce!) {\n  messageStatus(nonce: $nonce) {\n    state\n  }\n}\n    `;\nvar GetRelayedTransactionStatusDocument = gql`\n    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {\n  relayedTransactionStatus(id: $relayedTransactionId) {\n    ...relayedTransactionStatusFragment\n  }\n}\n    ${RelayedTransactionStatusFragmentDoc}`;\nvar GetAssetDetailsDocument = gql`\n    query getAssetDetails($assetId: AssetId!) {\n  assetDetails(id: $assetId) {\n    subId\n    contractId\n    totalSupply\n  }\n}\n    `;\nvar AssembleTxDocument = gql`\n    query assembleTx($tx: HexString!, $blockHorizon: U32!, $requiredBalances: [RequiredBalance!]!, $feeAddressIndex: U16!, $excludeInput: ExcludeInput, $estimatePredicates: Boolean, $reserveGas: U64) {\n  assembleTx(\n    tx: $tx\n    blockHorizon: $blockHorizon\n    requiredBalances: $requiredBalances\n    feeAddressIndex: $feeAddressIndex\n    excludeInput: $excludeInput\n    estimatePredicates: $estimatePredicates\n    reserveGas: $reserveGas\n  ) {\n    transaction {\n      id\n      inputs {\n        ... on InputCoin {\n          ...InputCoinFragment\n        }\n        ... on InputContract {\n          ...InputContractFragment\n        }\n        ... on InputMessage {\n          ...InputMessageFragment\n        }\n      }\n      outputs {\n        ... on CoinOutput {\n          ...OutputCoinFragment\n        }\n        ... on ContractOutput {\n          ...OutputContractFragment\n        }\n        ... on ChangeOutput {\n          ...OutputChangeFragment\n        }\n        ... on VariableOutput {\n          ...OutputVariableFragment\n        }\n        ... on ContractCreated {\n          ...OutputContractCreatedFragment\n        }\n      }\n      policies {\n        tip\n        witnessLimit\n        maturity\n        maxFee\n      }\n      witnesses\n      scriptGasLimit\n    }\n    status {\n      ... on DryRunFailureStatus {\n        ...dryRunFailureAssembleTxFragment\n      }\n      ... on DryRunSuccessStatus {\n        ...dryRunSuccessAssembleTxFragment\n      }\n    }\n    gasPrice\n  }\n}\n    ${InputCoinFragmentDoc}\n${InputContractFragmentDoc}\n${InputMessageFragmentDoc}\n${OutputCoinFragmentDoc}\n${OutputContractFragmentDoc}\n${OutputChangeFragmentDoc}\n${OutputVariableFragmentDoc}\n${OutputContractCreatedFragmentDoc}\n${DryRunFailureAssembleTxFragmentDoc}\n${DryRunSuccessAssembleTxFragmentDoc}`;\nvar DryRunDocument = gql`\n    query dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {\n  dryRun(\n    txs: $encodedTransactions\n    utxoValidation: $utxoValidation\n    gasPrice: $gasPrice\n  ) {\n    ...dryRunTransactionExecutionStatusFragment\n  }\n}\n    ${DryRunTransactionExecutionStatusFragmentDoc}`;\nvar SubmitDocument = gql`\n    mutation submit($encodedTransaction: HexString!) {\n  submit(tx: $encodedTransaction) {\n    id\n  }\n}\n    `;\nvar ProduceBlocksDocument = gql`\n    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {\n  produceBlocks(\n    blocksToProduce: $blocksToProduce\n    startTimestamp: $startTimestamp\n  )\n}\n    `;\nvar GetMessageByNonceDocument = gql`\n    query getMessageByNonce($nonce: Nonce!) {\n  message(nonce: $nonce) {\n    ...messageFragment\n  }\n}\n    ${MessageFragmentDoc}`;\nvar IsUserAccountDocument = gql`\n    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {\n  blob(id: $blobId) {\n    id\n  }\n  contract(id: $contractId) {\n    id\n  }\n  transaction(id: $transactionId) {\n    id\n  }\n}\n    `;\nvar GetConsensusParametersVersionDocument = gql`\n    query getConsensusParametersVersion {\n  chain {\n    latestBlock {\n      header {\n        consensusParametersVersion\n      }\n    }\n  }\n}\n    `;\nvar SubmitAndAwaitStatusDocument = gql`\n    subscription submitAndAwaitStatus($encodedTransaction: HexString!, $estimatePredicates: Boolean, $includePreConfirmation: Boolean) {\n  submitAndAwaitStatus(\n    tx: $encodedTransaction\n    estimatePredicates: $estimatePredicates\n    includePreconfirmation: $includePreConfirmation\n  ) {\n    ...transactionStatusSubscriptionFragment\n  }\n}\n    ${TransactionStatusSubscriptionFragmentDoc}`;\nvar StatusChangeDocument = gql`\n    subscription statusChange($transactionId: TransactionId!, $includePreConfirmation: Boolean) {\n  statusChange(\n    id: $transactionId\n    includePreconfirmation: $includePreConfirmation\n  ) {\n    ...transactionStatusSubscriptionFragment\n  }\n}\n    ${TransactionStatusSubscriptionFragmentDoc}`;\nfunction getSdk(requester) {\n  return {\n    getVersion(variables, options) {\n      return requester(GetVersionDocument, variables, options);\n    },\n    getNodeInfo(variables, options) {\n      return requester(GetNodeInfoDocument, variables, options);\n    },\n    getChain(variables, options) {\n      return requester(GetChainDocument, variables, options);\n    },\n    getChainAndNodeInfo(variables, options) {\n      return requester(GetChainAndNodeInfoDocument, variables, options);\n    },\n    getTransaction(variables, options) {\n      return requester(GetTransactionDocument, variables, options);\n    },\n    getTransactionWithReceipts(variables, options) {\n      return requester(GetTransactionWithReceiptsDocument, variables, options);\n    },\n    getTransactions(variables, options) {\n      return requester(GetTransactionsDocument, variables, options);\n    },\n    getTransactionsByOwner(variables, options) {\n      return requester(GetTransactionsByOwnerDocument, variables, options);\n    },\n    estimatePredicates(variables, options) {\n      return requester(EstimatePredicatesDocument, variables, options);\n    },\n    estimatePredicatesAndGasPrice(variables, options) {\n      return requester(EstimatePredicatesAndGasPriceDocument, variables, options);\n    },\n    getLatestBlock(variables, options) {\n      return requester(GetLatestBlockDocument, variables, options);\n    },\n    getLatestBlockHeight(variables, options) {\n      return requester(GetLatestBlockHeightDocument, variables, options);\n    },\n    getBlock(variables, options) {\n      return requester(GetBlockDocument, variables, options);\n    },\n    getBlockWithTransactions(variables, options) {\n      return requester(GetBlockWithTransactionsDocument, variables, options);\n    },\n    getBlocks(variables, options) {\n      return requester(GetBlocksDocument, variables, options);\n    },\n    getCoin(variables, options) {\n      return requester(GetCoinDocument, variables, options);\n    },\n    getCoins(variables, options) {\n      return requester(GetCoinsDocument, variables, options);\n    },\n    getCoinsToSpend(variables, options) {\n      return requester(GetCoinsToSpendDocument, variables, options);\n    },\n    getContract(variables, options) {\n      return requester(GetContractDocument, variables, options);\n    },\n    getContractBalance(variables, options) {\n      return requester(GetContractBalanceDocument, variables, options);\n    },\n    getBalance(variables, options) {\n      return requester(GetBalanceDocument, variables, options);\n    },\n    getBalanceV2(variables, options) {\n      return requester(GetBalanceV2Document, variables, options);\n    },\n    getLatestGasPrice(variables, options) {\n      return requester(GetLatestGasPriceDocument, variables, options);\n    },\n    estimateGasPrice(variables, options) {\n      return requester(EstimateGasPriceDocument, variables, options);\n    },\n    getBalances(variables, options) {\n      return requester(GetBalancesDocument, variables, options);\n    },\n    getBalancesV2(variables, options) {\n      return requester(GetBalancesV2Document, variables, options);\n    },\n    getMessages(variables, options) {\n      return requester(GetMessagesDocument, variables, options);\n    },\n    daCompressedBlock(variables, options) {\n      return requester(DaCompressedBlockDocument, variables, options);\n    },\n    getMessageProof(variables, options) {\n      return requester(GetMessageProofDocument, variables, options);\n    },\n    getMessageStatus(variables, options) {\n      return requester(GetMessageStatusDocument, variables, options);\n    },\n    getRelayedTransactionStatus(variables, options) {\n      return requester(GetRelayedTransactionStatusDocument, variables, options);\n    },\n    getAssetDetails(variables, options) {\n      return requester(GetAssetDetailsDocument, variables, options);\n    },\n    assembleTx(variables, options) {\n      return requester(AssembleTxDocument, variables, options);\n    },\n    dryRun(variables, options) {\n      return requester(DryRunDocument, variables, options);\n    },\n    submit(variables, options) {\n      return requester(SubmitDocument, variables, options);\n    },\n    produceBlocks(variables, options) {\n      return requester(ProduceBlocksDocument, variables, options);\n    },\n    getMessageByNonce(variables, options) {\n      return requester(GetMessageByNonceDocument, variables, options);\n    },\n    isUserAccount(variables, options) {\n      return requester(IsUserAccountDocument, variables, options);\n    },\n    getConsensusParametersVersion(variables, options) {\n      return requester(GetConsensusParametersVersionDocument, variables, options);\n    },\n    submitAndAwaitStatus(variables, options) {\n      return requester(SubmitAndAwaitStatusDocument, variables, options);\n    },\n    statusChange(variables, options) {\n      return requester(StatusChangeDocument, variables, options);\n    }\n  };\n}\n__name(getSdk, \"getSdk\");\n\n// src/providers/assemble-tx-helpers.ts\nimport { FuelError, ErrorCode } from \"@fuel-ts/errors\";\nimport { bn as bn2 } from \"@fuel-ts/math\";\nimport { TransactionType } from \"@fuel-ts/transactions\";\nimport { hexlify as hexlify2, isDefined } from \"@fuel-ts/utils\";\nvar resolveAccountForAssembleTxParams = /* @__PURE__ */ __name((account) => {\n  const assembleTxAccount = {};\n  const accountIsPredicate = \"bytes\" in account;\n  if (accountIsPredicate) {\n    assembleTxAccount.predicate = {\n      predicate: hexlify2(account.bytes),\n      predicateAddress: account.address.toB256(),\n      predicateData: hexlify2(account.getPredicateData())\n    };\n  } else {\n    assembleTxAccount.address = account.address.toB256();\n  }\n  return assembleTxAccount;\n}, \"resolveAccountForAssembleTxParams\");\nvar setAndValidateGasAndFeeForAssembledTx = /* @__PURE__ */ __name(async (params) => {\n  const { gasPrice, transactionRequest, setGasLimit, setMaxFee, provider } = params;\n  const gasLimitSpecified = isDefined(setGasLimit);\n  const maxFeeSpecified = isDefined(setMaxFee);\n  const isScriptTx = transactionRequest.type === TransactionType.Script;\n  if (gasLimitSpecified && isScriptTx) {\n    const requiredGasLimit = transactionRequest.gasLimit;\n    if (bn2(setGasLimit).lt(bn2(requiredGasLimit))) {\n      throw new FuelError(\n        ErrorCode.GAS_LIMIT_TOO_LOW,\n        `Gas limit '${setGasLimit}' is lower than the required: '${requiredGasLimit}'.`\n      );\n    }\n    transactionRequest.gasLimit = bn2(setGasLimit);\n  }\n  if (maxFeeSpecified) {\n    const requiredMaxFee = transactionRequest.maxFee;\n    if (bn2(setMaxFee).lt(requiredMaxFee)) {\n      throw new FuelError(\n        ErrorCode.MAX_FEE_TOO_LOW,\n        `Max fee '${setMaxFee}' is lower than the required: '${requiredMaxFee}'.`\n      );\n    }\n    transactionRequest.maxFee = bn2(setMaxFee);\n  }\n  if (gasLimitSpecified && !maxFeeSpecified) {\n    const { maxFee: feeForGasPrice } = await provider.estimateTxGasAndFee({\n      transactionRequest,\n      gasPrice\n    });\n    transactionRequest.maxFee = feeForGasPrice;\n  }\n  return transactionRequest;\n}, \"setAndValidateGasAndFeeForAssembledTx\");\n\n// src/providers/fuel-graphql-subscriber.ts\nimport { ErrorCode as ErrorCode3, FuelError as FuelError3 } from \"@fuel-ts/errors\";\nimport { print } from \"graphql\";\n\n// src/providers/utils/handle-gql-error-message.ts\nimport { ErrorCode as ErrorCode2, FuelError as FuelError2 } from \"@fuel-ts/errors\";\nvar ASSET_ID_REGEX = /[0-9a-fA-F]{32,64}/g;\nvar gqlErrorMessage = {\n  RPC_CONSISTENCY: /The required fuel block height is higher than the current block height. Required: \\d+, Current: \\d+/,\n  INSUFFICIENT_FUNDS: /the target cannot be met due to insufficient coins available for [0-9a-fA-F]{32,64}. Collected: \\d+/,\n  MAX_COINS_REACHED: /the target for [0-9a-fA-F]{32,64} cannot be met due to exceeding the \\d+ coin limit. Collected: \\d+./,\n  NOT_ENOUGH_COINS_MAX_COINS: /the target cannot be met due to no coins available or exceeding the \\d+ coin limit./,\n  ASSET_NOT_FOUND: /resource was not found in table/,\n  MULTIPLE_CHANGE_POLICIES: /The asset ([a-fA-F0-9]{64}) has multiple change policies/,\n  DUPLICATE_CHANGE_OUTPUT_ACCOUNT: /required balances contain duplicate \\(asset, account\\) pair/,\n  INSUFFICIENT_FEE_AMOUNT: /InsufficientFeeAmount { expected: (\\d+), provided: (\\d+) }/\n};\nvar mapGqlErrorMessage = /* @__PURE__ */ __name((error) => {\n  if (gqlErrorMessage.NOT_ENOUGH_COINS_MAX_COINS.test(error.message)) {\n    return new FuelError2(\n      ErrorCode2.INSUFFICIENT_FUNDS_OR_MAX_COINS,\n      `Insufficient funds or too many small value coins. Consider combining UTXOs.`,\n      {},\n      error\n    );\n  }\n  if (gqlErrorMessage.MAX_COINS_REACHED.test(error.message)) {\n    const matches = error.message.match(ASSET_ID_REGEX);\n    const assetId = matches ? `0x${matches[0]}` : null;\n    const owner = matches ? `0x${matches[1]}` : null;\n    let suffix = \"\";\n    if (assetId) {\n      suffix += `\n\tAsset ID: '${assetId}'.`;\n    }\n    if (owner) {\n      suffix += `\n\tOwner: '${owner}'.`;\n    }\n    return new FuelError2(\n      ErrorCode2.MAX_COINS_REACHED,\n      `You have too many small value coins - consider combining UTXOs.${suffix}`,\n      { assetId, owner },\n      error\n    );\n  }\n  if (gqlErrorMessage.INSUFFICIENT_FUNDS.test(error.message)) {\n    const matches = error.message.match(ASSET_ID_REGEX);\n    const assetId = matches ? `0x${matches[0]}` : null;\n    const owner = matches ? `0x${matches[1]}` : null;\n    let suffix = \"\";\n    if (assetId) {\n      suffix += `\n\tAsset ID: '${assetId}'.`;\n    }\n    if (owner) {\n      suffix += `\n\tOwner: '${owner}'.`;\n    }\n    return new FuelError2(\n      ErrorCode2.INSUFFICIENT_FUNDS,\n      `Insufficient funds.${suffix}`,\n      { assetId, owner },\n      error\n    );\n  }\n  if (gqlErrorMessage.MULTIPLE_CHANGE_POLICIES.test(error.message)) {\n    const match = error.message.match(/asset ([a-fA-F0-9]{64})/);\n    const assetId = match?.[1] || \"\";\n    return new FuelError2(\n      ErrorCode2.CHANGE_OUTPUT_COLLISION,\n      `OutputChange address for asset 0x${assetId} differs between transaction request and assembleTx parameters.`,\n      {},\n      error\n    );\n  }\n  if (gqlErrorMessage.DUPLICATE_CHANGE_OUTPUT_ACCOUNT.test(error.message)) {\n    return new FuelError2(\n      ErrorCode2.DUPLICATE_CHANGE_OUTPUT_ACCOUNT,\n      `The parameter 'accountCoinQuantities' of assembleTx contains duplicate entries for the same assetId with different 'changeOutputAccount'.`,\n      {},\n      error\n    );\n  }\n  if (gqlErrorMessage.ASSET_NOT_FOUND.test(error.message)) {\n    return new FuelError2(\n      ErrorCode2.ASSET_NOT_FOUND,\n      `Asset not found for given asset id.`,\n      {},\n      error\n    );\n  }\n  if (gqlErrorMessage.RPC_CONSISTENCY.test(error.message)) {\n    return new FuelError2(ErrorCode2.RPC_CONSISTENCY, error.message, {}, error);\n  }\n  if (gqlErrorMessage.INSUFFICIENT_FEE_AMOUNT.test(error.message)) {\n    const match = error.message.match(gqlErrorMessage.INSUFFICIENT_FEE_AMOUNT);\n    return new FuelError2(ErrorCode2.FUNDS_TOO_LOW, match?.[0] || error.message, {}, error);\n  }\n  return new FuelError2(ErrorCode2.INVALID_REQUEST, error.message, {}, error);\n}, \"mapGqlErrorMessage\");\nvar mapGqlErrorWithIncompatibleNodeVersion = /* @__PURE__ */ __name((error, incompatibleNodeVersionMessage) => {\n  if (!incompatibleNodeVersionMessage) {\n    return error;\n  }\n  return new FuelError2(\n    error.code,\n    `${error.message}\n\n${incompatibleNodeVersionMessage}`,\n    error.metadata,\n    error.rawError\n  );\n}, \"mapGqlErrorWithIncompatibleNodeVersion\");\nvar assertGqlResponseHasNoErrors = /* @__PURE__ */ __name((errors, incompatibleNodeVersionMessage = false) => {\n  if (!Array.isArray(errors)) {\n    return;\n  }\n  const mappedErrors = errors.map(mapGqlErrorMessage);\n  if (mappedErrors.length === 1) {\n    throw mapGqlErrorWithIncompatibleNodeVersion(mappedErrors[0], incompatibleNodeVersionMessage);\n  }\n  const errorMessage = mappedErrors.map((err) => err.message).join(\"\\n\");\n  throw mapGqlErrorWithIncompatibleNodeVersion(\n    new FuelError2(ErrorCode2.INVALID_REQUEST, errorMessage, {}, mappedErrors),\n    incompatibleNodeVersionMessage\n  );\n}, \"assertGqlResponseHasNoErrors\");\n\n// src/providers/fuel-graphql-subscriber.ts\nvar FuelGraphqlSubscriber = class _FuelGraphqlSubscriber {\n  constructor(stream, onEvent) {\n    this.stream = stream;\n    this.onEvent = onEvent;\n  }\n  static {\n    __name(this, \"FuelGraphqlSubscriber\");\n  }\n  static incompatibleNodeVersionMessage = false;\n  static textDecoder = new TextDecoder();\n  static async create(options) {\n    const { url, query, variables, fetchFn, operationName, onEvent } = options;\n    const response = await fetchFn(`${url}-sub`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        query: print(query),\n        variables,\n        operationName\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\"\n      }\n    });\n    const [errorReader, resultReader] = response.body.tee().map((stream) => stream.getReader());\n    await new _FuelGraphqlSubscriber(errorReader).next();\n    return new _FuelGraphqlSubscriber(resultReader, onEvent);\n  }\n  /**\n   * This method will take a stream reader and parse the event from the stream.\n   *\n   * @param reader - The reader of the SSE stream\n   * @param parsingLeftover - The leftover string from parsing the previous event\n   * @returns The event parsed as a full GraphQL response, whether the stream is done and the leftover string after parsing\n   */\n  static async readEvent(reader, parsingLeftover = \"\") {\n    let text = parsingLeftover;\n    const regex = /data:.*\\n\\n/g;\n    while (true) {\n      const matches = [...text.matchAll(regex)].flatMap((match) => match);\n      if (matches.length > 0) {\n        try {\n          const event = JSON.parse(matches[0].replace(/^data:/, \"\"));\n          return {\n            event,\n            done: false,\n            parsingLeftover: text.replace(matches[0], \"\")\n          };\n        } catch (e) {\n          throw new FuelError3(\n            ErrorCode3.STREAM_PARSING_ERROR,\n            `Error while parsing stream data response: ${text}`\n          );\n        }\n      }\n      const { value, done } = await reader.read();\n      if (done) {\n        return { event: void 0, done, parsingLeftover: \"\" };\n      }\n      const decoded = _FuelGraphqlSubscriber.textDecoder.decode(value).replace(\":keep-alive-text\\n\\n\", \"\");\n      text += decoded;\n    }\n  }\n  events = [];\n  parsingLeftover = \"\";\n  /**\n   * Gets automatically called when iterating in a `for-await-of` loop.\n   * It can also be called manually.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next\n   */\n  async next() {\n    while (true) {\n      const nextEvent = this.events.shift();\n      if (nextEvent) {\n        this.onEvent?.(nextEvent);\n        assertGqlResponseHasNoErrors(\n          nextEvent.errors,\n          _FuelGraphqlSubscriber.incompatibleNodeVersionMessage\n        );\n        return { value: nextEvent.data, done: false };\n      }\n      const { event, done, parsingLeftover } = await _FuelGraphqlSubscriber.readEvent(\n        this.stream,\n        this.parsingLeftover\n      );\n      this.parsingLeftover = parsingLeftover;\n      if (done) {\n        return { value: void 0, done: true };\n      }\n      this.events.push(event);\n    }\n  }\n  /**\n   * Gets called when `break` is called in a `for-await-of` loop.\n   */\n  return() {\n    return Promise.resolve({ done: true, value: void 0 });\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n};\n\n// src/providers/resource-cache.ts\nimport { FuelError as FuelError13, ErrorCode as ErrorCode11 } from \"@fuel-ts/errors\";\nimport { hexlify as hexlify15 } from \"@fuel-ts/utils\";\n\n// src/providers/transaction-request/input.ts\nimport { BYTES_32, UTXO_ID_LEN } from \"@fuel-ts/abi-coder\";\nimport { ZeroBytes32 } from \"@fuel-ts/address/configs\";\nimport { ErrorCode as ErrorCode4, FuelError as FuelError4 } from \"@fuel-ts/errors\";\nimport { bn as bn3, toNumber } from \"@fuel-ts/math\";\nimport { InputType } from \"@fuel-ts/transactions\";\nimport { arrayify, hexlify as hexlify3 } from \"@fuel-ts/utils\";\nvar inputify = /* @__PURE__ */ __name((value) => {\n  const { type } = value;\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = arrayify(value.predicate ?? \"0x\");\n      const predicateData = arrayify(value.predicateData ?? \"0x\");\n      return {\n        type: InputType.Coin,\n        txID: hexlify3(arrayify(value.id).slice(0, BYTES_32)),\n        outputIndex: toNumber(arrayify(value.id).slice(BYTES_32, UTXO_ID_LEN)),\n        owner: hexlify3(value.owner),\n        amount: bn3(value.amount),\n        assetId: hexlify3(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))\n        },\n        witnessIndex: value.witnessIndex,\n        predicateGasUsed: bn3(value.predicateGasUsed),\n        predicateLength: bn3(predicate.length),\n        predicateDataLength: bn3(predicateData.length),\n        predicate: hexlify3(predicate),\n        predicateData: hexlify3(predicateData)\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        txID: hexlify3(value.txID || ZeroBytes32),\n        outputIndex: 0,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(arrayify(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(arrayify(value.txPointer).slice(8, 16))\n        },\n        contractID: hexlify3(value.contractId)\n      };\n    }\n    case InputType.Message: {\n      const predicate = arrayify(value.predicate ?? \"0x\");\n      const predicateData = arrayify(value.predicateData ?? \"0x\");\n      const data = arrayify(value.data ?? \"0x\");\n      return {\n        type: InputType.Message,\n        sender: hexlify3(value.sender),\n        recipient: hexlify3(value.recipient),\n        amount: bn3(value.amount),\n        nonce: hexlify3(value.nonce),\n        witnessIndex: value.witnessIndex,\n        predicateGasUsed: bn3(value.predicateGasUsed),\n        predicateLength: bn3(predicate.length),\n        predicateDataLength: bn3(predicateData.length),\n        predicate: hexlify3(predicate),\n        predicateData: hexlify3(predicateData),\n        data: hexlify3(data),\n        dataLength: data.length\n      };\n    }\n    default: {\n      throw new FuelError4(\n        ErrorCode4.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction input type: ${type}.`\n      );\n    }\n  }\n}, \"inputify\");\n\n// src/providers/transaction-request/output.ts\nimport { ZeroBytes32 as ZeroBytes322 } from \"@fuel-ts/address/configs\";\nimport { ErrorCode as ErrorCode5, FuelError as FuelError5 } from \"@fuel-ts/errors\";\nimport { bn as bn4 } from \"@fuel-ts/math\";\nimport { OutputType } from \"@fuel-ts/transactions\";\nimport { hexlify as hexlify4 } from \"@fuel-ts/utils\";\nvar outputify = /* @__PURE__ */ __name((value) => {\n  const { type } = value;\n  switch (type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify4(value.to),\n        amount: bn4(value.amount),\n        assetId: hexlify4(value.assetId)\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes322,\n        stateRoot: ZeroBytes322\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify4(value.to),\n        amount: bn4(0),\n        assetId: hexlify4(value.assetId)\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: hexlify4(value.to || ZeroBytes322),\n        amount: bn4(value.amount),\n        assetId: hexlify4(value.assetId || ZeroBytes322)\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify4(value.contractId),\n        stateRoot: hexlify4(value.stateRoot)\n      };\n    }\n    default: {\n      throw new FuelError5(\n        ErrorCode5.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction output type: ${type}.`\n      );\n    }\n  }\n}, \"outputify\");\n\n// src/providers/transaction-request/transaction-request.ts\nimport { UTXO_ID_LEN as UTXO_ID_LEN2 } from \"@fuel-ts/abi-coder\";\nimport { Address, addressify } from \"@fuel-ts/address\";\nimport { ZeroBytes32 as ZeroBytes324 } from \"@fuel-ts/address/configs\";\nimport { randomBytes } from \"@fuel-ts/crypto\";\nimport { FuelError as FuelError10 } from \"@fuel-ts/errors\";\nimport { bn as bn9 } from \"@fuel-ts/math\";\nimport {\n  PolicyType,\n  TransactionCoder,\n  InputType as InputType4,\n  OutputType as OutputType4,\n  TransactionType as TransactionType2\n} from \"@fuel-ts/transactions\";\nimport { concat, hexlify as hexlify9, isDefined as isDefined2 } from \"@fuel-ts/utils\";\n\n// src/providers/message.ts\nvar isMessageCoin = /* @__PURE__ */ __name((message) => !(\"data\" in message), \"isMessageCoin\");\n\n// src/providers/resource.ts\nvar isRawCoin = /* @__PURE__ */ __name((resource) => \"utxoId\" in resource, \"isRawCoin\");\nvar isRawMessage = /* @__PURE__ */ __name((resource) => \"recipient\" in resource, \"isRawMessage\");\nvar isCoin = /* @__PURE__ */ __name((resource) => \"id\" in resource, \"isCoin\");\nvar isMessage = /* @__PURE__ */ __name((resource) => \"recipient\" in resource, \"isMessage\");\n\n// src/providers/utils/receipts.ts\nimport { ReceiptType as ReceiptType2 } from \"@fuel-ts/transactions\";\nimport { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from \"@fuel-ts/transactions/configs\";\n\n// src/providers/utils/serialization.ts\nimport { ZeroBytes32 as ZeroBytes323 } from \"@fuel-ts/address/configs\";\nimport { ErrorCode as ErrorCode6, FuelError as FuelError6 } from \"@fuel-ts/errors\";\nimport { bn as bn5 } from \"@fuel-ts/math\";\nimport {\n  getMintedAssetId,\n  InputMessageCoder,\n  InputType as InputType2,\n  OutputType as OutputType2,\n  ReceiptType\n} from \"@fuel-ts/transactions\";\nimport { hexlify as hexlify5, arrayify as arrayify2, assertUnreachable } from \"@fuel-ts/utils\";\nvar deserializeChain = /* @__PURE__ */ __name((chain) => {\n  const { name, daHeight, consensusParameters, latestBlock } = chain;\n  const {\n    contractParams,\n    feeParams,\n    predicateParams,\n    scriptParams,\n    txParams,\n    gasCosts,\n    baseAssetId,\n    chainId,\n    version\n  } = consensusParameters;\n  return {\n    name,\n    baseChainHeight: bn5(daHeight),\n    consensusParameters: {\n      version,\n      chainId: bn5(chainId),\n      baseAssetId,\n      feeParameters: {\n        version: feeParams.version,\n        gasPerByte: bn5(feeParams.gasPerByte),\n        gasPriceFactor: bn5(feeParams.gasPriceFactor)\n      },\n      contractParameters: {\n        version: contractParams.version,\n        contractMaxSize: bn5(contractParams.contractMaxSize),\n        maxStorageSlots: bn5(contractParams.maxStorageSlots)\n      },\n      txParameters: {\n        version: txParams.version,\n        maxInputs: bn5(txParams.maxInputs),\n        maxOutputs: bn5(txParams.maxOutputs),\n        maxWitnesses: bn5(txParams.maxWitnesses),\n        maxGasPerTx: bn5(txParams.maxGasPerTx),\n        maxSize: bn5(txParams.maxSize),\n        maxBytecodeSubsections: bn5(txParams.maxBytecodeSubsections)\n      },\n      predicateParameters: {\n        version: predicateParams.version,\n        maxPredicateLength: bn5(predicateParams.maxPredicateLength),\n        maxPredicateDataLength: bn5(predicateParams.maxPredicateDataLength),\n        maxGasPerPredicate: bn5(predicateParams.maxGasPerPredicate),\n        maxMessageDataLength: bn5(predicateParams.maxMessageDataLength)\n      },\n      scriptParameters: {\n        version: scriptParams.version,\n        maxScriptLength: bn5(scriptParams.maxScriptLength),\n        maxScriptDataLength: bn5(scriptParams.maxScriptDataLength)\n      },\n      gasCosts\n    },\n    latestBlock\n  };\n}, \"deserializeChain\");\nvar serializeChain = /* @__PURE__ */ __name((chain) => {\n  const { name, baseChainHeight, consensusParameters, latestBlock } = chain;\n  const {\n    contractParameters,\n    feeParameters,\n    predicateParameters,\n    scriptParameters,\n    txParameters,\n    gasCosts,\n    baseAssetId,\n    chainId,\n    version\n  } = consensusParameters;\n  return {\n    name,\n    daHeight: baseChainHeight.toString(),\n    consensusParameters: {\n      version,\n      chainId: chainId.toString(),\n      baseAssetId,\n      feeParams: {\n        version: feeParameters.version,\n        gasPerByte: feeParameters.gasPerByte.toString(),\n        gasPriceFactor: feeParameters.gasPriceFactor.toString()\n      },\n      contractParams: {\n        version: contractParameters.version,\n        contractMaxSize: contractParameters.contractMaxSize.toString(),\n        maxStorageSlots: contractParameters.maxStorageSlots.toString()\n      },\n      txParams: {\n        version: txParameters.version,\n        maxInputs: txParameters.maxInputs.toString(),\n        maxOutputs: txParameters.maxOutputs.toString(),\n        maxWitnesses: txParameters.maxWitnesses.toString(),\n        maxGasPerTx: txParameters.maxGasPerTx.toString(),\n        maxSize: txParameters.maxSize.toString(),\n        maxBytecodeSubsections: txParameters.maxBytecodeSubsections.toString()\n      },\n      predicateParams: {\n        version: predicateParameters.version,\n        maxPredicateLength: predicateParameters.maxPredicateLength.toString(),\n        maxPredicateDataLength: predicateParameters.maxPredicateDataLength.toString(),\n        maxGasPerPredicate: predicateParameters.maxGasPerPredicate.toString(),\n        maxMessageDataLength: predicateParameters.maxMessageDataLength.toString()\n      },\n      scriptParams: {\n        version: scriptParameters.version,\n        maxScriptLength: scriptParameters.maxScriptLength.toString(),\n        maxScriptDataLength: scriptParameters.maxScriptDataLength.toString()\n      },\n      gasCosts\n    },\n    latestBlock\n  };\n}, \"serializeChain\");\nvar deserializeNodeInfo = /* @__PURE__ */ __name((nodeInfo) => {\n  const { maxDepth, maxTx, nodeVersion, utxoValidation, vmBacktrace, indexation } = nodeInfo;\n  return {\n    maxDepth: bn5(maxDepth),\n    maxTx: bn5(maxTx),\n    nodeVersion,\n    utxoValidation,\n    vmBacktrace,\n    indexation\n  };\n}, \"deserializeNodeInfo\");\nvar serializeNodeInfo = /* @__PURE__ */ __name((nodeInfo) => {\n  const { maxDepth, maxTx, nodeVersion, utxoValidation, vmBacktrace, indexation } = nodeInfo;\n  return {\n    maxDepth: maxDepth.toString(),\n    maxTx: maxTx.toString(),\n    nodeVersion,\n    utxoValidation,\n    vmBacktrace,\n    indexation\n  };\n}, \"serializeNodeInfo\");\nvar deserializeProviderCache = /* @__PURE__ */ __name((cache2) => ({\n  consensusParametersTimestamp: cache2.consensusParametersTimestamp,\n  chain: deserializeChain(cache2.chain),\n  nodeInfo: deserializeNodeInfo(cache2.nodeInfo)\n}), \"deserializeProviderCache\");\nvar serializeProviderCache = /* @__PURE__ */ __name(async (provider) => ({\n  consensusParametersTimestamp: provider.consensusParametersTimestamp,\n  chain: serializeChain(await provider.getChain()),\n  nodeInfo: serializeNodeInfo(await provider.getNode())\n}), \"serializeProviderCache\");\nvar hexOrZero = /* @__PURE__ */ __name((hex) => hex || ZeroBytes323, \"hexOrZero\");\nvar deserializeReceipt = /* @__PURE__ */ __name((receipt) => {\n  const { receiptType } = receipt;\n  switch (receiptType) {\n    case \"CALL\" /* Call */: {\n      const id = hexOrZero(receipt.id || receipt.contractId);\n      const callReceipt = {\n        type: ReceiptType.Call,\n        id,\n        to: hexOrZero(receipt?.to),\n        amount: bn5(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        gas: bn5(receipt.gas),\n        param1: bn5(receipt.param1),\n        param2: bn5(receipt.param2),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return callReceipt;\n    }\n    case \"RETURN\" /* Return */: {\n      const returnReceipt = {\n        type: ReceiptType.Return,\n        id: hexOrZero(receipt.id || receipt.contractId),\n        val: bn5(receipt.val),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return returnReceipt;\n    }\n    case \"RETURN_DATA\" /* ReturnData */: {\n      const returnDataReceipt = {\n        type: ReceiptType.ReturnData,\n        id: hexOrZero(receipt.id || receipt.contractId),\n        ptr: bn5(receipt.ptr),\n        len: bn5(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn5(receipt.pc),\n        data: hexOrZero(receipt.data),\n        is: bn5(receipt.is)\n      };\n      return returnDataReceipt;\n    }\n    case \"PANIC\" /* Panic */: {\n      const panicReceipt = {\n        type: ReceiptType.Panic,\n        id: hexOrZero(receipt.id),\n        reason: bn5(receipt.reason),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is),\n        contractId: hexOrZero(receipt.contractId)\n      };\n      return panicReceipt;\n    }\n    case \"REVERT\" /* Revert */: {\n      const revertReceipt = {\n        type: ReceiptType.Revert,\n        id: hexOrZero(receipt.id || receipt.contractId),\n        val: bn5(receipt.ra),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return revertReceipt;\n    }\n    case \"LOG\" /* Log */: {\n      const ra = bn5(receipt.ra);\n      const rb = bn5(receipt.rb);\n      const rc = bn5(receipt.rc);\n      const rd = bn5(receipt.rd);\n      const logReceipt = {\n        type: ReceiptType.Log,\n        id: hexOrZero(receipt.id || receipt.contractId),\n        ra,\n        rb,\n        rc,\n        rd,\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return logReceipt;\n    }\n    case \"LOG_DATA\" /* LogData */: {\n      const ra = bn5(receipt.ra);\n      const rb = bn5(receipt.rb);\n      const logDataReceipt = {\n        type: ReceiptType.LogData,\n        id: hexOrZero(receipt.id || receipt.contractId),\n        ra,\n        rb,\n        ptr: bn5(receipt.ptr),\n        len: bn5(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn5(receipt.pc),\n        data: hexOrZero(receipt.data),\n        is: bn5(receipt.is)\n      };\n      return logDataReceipt;\n    }\n    case \"TRANSFER\" /* Transfer */: {\n      const id = hexOrZero(receipt.id || receipt.contractId);\n      const transferReceipt = {\n        type: ReceiptType.Transfer,\n        id,\n        to: hexOrZero(receipt.toAddress || receipt?.to),\n        amount: bn5(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return transferReceipt;\n    }\n    case \"TRANSFER_OUT\" /* TransferOut */: {\n      const id = hexOrZero(receipt.id || receipt.contractId);\n      const transferOutReceipt = {\n        type: ReceiptType.TransferOut,\n        id,\n        to: hexOrZero(receipt.toAddress || receipt.to),\n        amount: bn5(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return transferOutReceipt;\n    }\n    case \"SCRIPT_RESULT\" /* ScriptResult */: {\n      const scriptResultReceipt = {\n        type: ReceiptType.ScriptResult,\n        result: bn5(receipt.result),\n        gasUsed: bn5(receipt.gasUsed)\n      };\n      return scriptResultReceipt;\n    }\n    case \"MESSAGE_OUT\" /* MessageOut */: {\n      const sender = hexOrZero(receipt.sender);\n      const recipient = hexOrZero(receipt.recipient);\n      const nonce = hexOrZero(receipt.nonce);\n      const amount = bn5(receipt.amount);\n      const data = receipt.data ? arrayify2(receipt.data) : Uint8Array.from([]);\n      const digest = hexOrZero(receipt.digest);\n      const len = bn5(receipt.len).toNumber();\n      const messageId = InputMessageCoder.getMessageId({\n        sender,\n        recipient,\n        nonce,\n        amount,\n        data: hexlify5(data)\n      });\n      const receiptMessageOut = {\n        type: ReceiptType.MessageOut,\n        sender,\n        recipient,\n        amount,\n        nonce,\n        len,\n        data,\n        digest,\n        messageId\n      };\n      return receiptMessageOut;\n    }\n    case \"MINT\" /* Mint */: {\n      const contractId = hexOrZero(receipt.id || receipt.contractId);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = getMintedAssetId(contractId, subId);\n      const mintReceipt = {\n        type: ReceiptType.Mint,\n        subId,\n        contractId,\n        assetId,\n        val: bn5(receipt.val),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return mintReceipt;\n    }\n    case \"BURN\" /* Burn */: {\n      const contractId = hexOrZero(receipt.id || receipt.contractId);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = getMintedAssetId(contractId, subId);\n      const burnReceipt = {\n        type: ReceiptType.Burn,\n        subId,\n        contractId,\n        assetId,\n        val: bn5(receipt.val),\n        pc: bn5(receipt.pc),\n        is: bn5(receipt.is)\n      };\n      return burnReceipt;\n    }\n    default:\n      throw new FuelError6(ErrorCode6.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);\n  }\n}, \"deserializeReceipt\");\nvar deserializeInput = /* @__PURE__ */ __name((input) => {\n  let parsedInput;\n  switch (input.type) {\n    case \"InputCoin\":\n      parsedInput = {\n        type: InputType2.Coin,\n        id: input.utxoId,\n        amount: bn5(input.amount),\n        assetId: input.assetId,\n        owner: input.owner,\n        txPointer: `0x${input.txPointer}`,\n        witnessIndex: Number(input.coinWitnessIndex),\n        predicate: input.predicate,\n        predicateData: input.predicateData,\n        predicateGasUsed: bn5(input.predicateGasUsed)\n      };\n      break;\n    case \"InputMessage\":\n      parsedInput = {\n        type: InputType2.Message,\n        nonce: input.nonce,\n        amount: bn5(input.amount),\n        recipient: input.recipient,\n        sender: input.sender,\n        data: input.data,\n        witnessIndex: Number(input.messageWitnessIndex),\n        predicate: input.predicate,\n        predicateData: input.predicateData,\n        predicateGasUsed: bn5(input.predicateGasUsed)\n      };\n      break;\n    case \"InputContract\":\n      parsedInput = {\n        type: InputType2.Contract,\n        contractId: input.contractId,\n        txPointer: `0x${input.txPointer}`,\n        txID: hexlify5(arrayify2(input.utxoId).slice(0, 32))\n      };\n      break;\n    default:\n      assertUnreachable(input);\n  }\n  return parsedInput;\n}, \"deserializeInput\");\nvar deserializeOutput = /* @__PURE__ */ __name((output) => {\n  let parsedOutput;\n  switch (output.type) {\n    case \"CoinOutput\":\n      parsedOutput = {\n        type: OutputType2.Coin,\n        amount: bn5(output.amount),\n        assetId: output.assetId,\n        to: output.to\n      };\n      break;\n    case \"ContractOutput\":\n      parsedOutput = {\n        type: OutputType2.Contract,\n        inputIndex: Number(output.inputIndex)\n      };\n      break;\n    case \"ChangeOutput\":\n      parsedOutput = {\n        type: OutputType2.Change,\n        assetId: output.assetId,\n        to: output.to\n      };\n      break;\n    case \"ContractCreated\":\n      parsedOutput = {\n        type: OutputType2.ContractCreated,\n        stateRoot: output.stateRoot,\n        contractId: output.contract\n      };\n      break;\n    case \"VariableOutput\":\n      parsedOutput = {\n        type: OutputType2.Variable,\n        amount: bn5(output.amount),\n        assetId: output.assetId,\n        to: output.to\n      };\n      break;\n    default:\n      assertUnreachable(output);\n  }\n  return parsedOutput;\n}, \"deserializeOutput\");\nvar deserializeProcessedTxOutput = /* @__PURE__ */ __name((output) => {\n  let parsedOutput;\n  switch (output.type) {\n    case \"CoinOutput\":\n      parsedOutput = {\n        type: OutputType2.Coin,\n        amount: bn5(output.amount),\n        assetId: output.assetId,\n        to: output.to\n      };\n      break;\n    case \"ContractOutput\":\n      parsedOutput = {\n        type: OutputType2.Contract,\n        inputIndex: Number(output.inputIndex),\n        balanceRoot: output.balanceRoot,\n        stateRoot: output.stateRoot\n      };\n      break;\n    case \"ChangeOutput\":\n      parsedOutput = {\n        type: OutputType2.Change,\n        assetId: output.assetId,\n        to: output.to,\n        amount: bn5(output.amount)\n      };\n      break;\n    case \"ContractCreated\":\n      parsedOutput = {\n        type: OutputType2.ContractCreated,\n        stateRoot: output.stateRoot,\n        contractId: output.contract\n      };\n      break;\n    case \"VariableOutput\":\n      parsedOutput = {\n        type: OutputType2.Variable,\n        amount: bn5(output.amount),\n        assetId: output.assetId,\n        to: output.to\n      };\n      break;\n    default:\n      assertUnreachable(output);\n  }\n  return parsedOutput;\n}, \"deserializeProcessedTxOutput\");\n\n// src/providers/utils/receipts.ts\nvar doesReceiptHaveMissingOutputVariables = /* @__PURE__ */ __name((receipt) => receipt.type === ReceiptType2.Revert && receipt.val.toString(\"hex\") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL, \"doesReceiptHaveMissingOutputVariables\");\nvar doesReceiptHaveMissingContractId = /* @__PURE__ */ __name((receipt) => receipt.type === ReceiptType2.Panic && receipt.contractId !== \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"doesReceiptHaveMissingContractId\");\nvar getReceiptsWithMissingData = /* @__PURE__ */ __name((receipts) => receipts.reduce(\n  (memo, receipt) => {\n    if (doesReceiptHaveMissingOutputVariables(receipt)) {\n      memo.missingOutputVariables.push(receipt);\n    }\n    if (doesReceiptHaveMissingContractId(receipt)) {\n      memo.missingOutputContractIds.push(receipt);\n    }\n    return memo;\n  },\n  {\n    missingOutputVariables: [],\n    missingOutputContractIds: []\n  }\n), \"getReceiptsWithMissingData\");\nvar assembleReceiptByType = /* @__PURE__ */ __name((gqlReceipt) => deserializeReceipt(gqlReceipt), \"assembleReceiptByType\");\n\n// src/providers/utils/block-explorer.ts\nimport { ErrorCode as ErrorCode7, FuelError as FuelError7 } from \"@fuel-ts/errors\";\nvar DEFAULT_BLOCK_EXPLORER_URL = \"https://app.fuel.network\";\nvar getPathFromInput = /* @__PURE__ */ __name((key, value) => {\n  const pathMap = {\n    address: `address`,\n    txId: `transaction`,\n    blockNumber: `block`\n  };\n  const path = pathMap[key] || key;\n  return `${path}/${value}`;\n}, \"getPathFromInput\");\nvar buildBlockExplorerUrl = /* @__PURE__ */ __name((options = {}) => {\n  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;\n  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;\n  const customInputParams = [\n    {\n      key: \"address\",\n      value: address\n    },\n    {\n      key: \"txId\",\n      value: txId\n    },\n    {\n      key: \"blockNumber\",\n      value: blockNumber\n    }\n  ];\n  const definedValues = customInputParams.filter((param) => !!param.value).map(({ key, value }) => ({\n    key,\n    value\n  }));\n  const hasAnyDefinedValues = definedValues.length > 0;\n  if (definedValues.length > 1) {\n    throw new FuelError7(\n      ErrorCode7.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams.map((param) => param.key).join(\", \")}.`\n    );\n  }\n  if (path && definedValues.length > 0) {\n    const inputKeys = customInputParams.map(({ key }) => key).join(\", \");\n    throw new FuelError7(\n      ErrorCode7.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${inputKeys}.`\n    );\n  }\n  const pathGeneratedFromInputParams = hasAnyDefinedValues ? getPathFromInput(\n    definedValues[0].key,\n    definedValues[0].value\n  ) : \"\";\n  const trimSlashes = /^\\/|\\/$/gm;\n  const cleanPath = path ? path.replace(trimSlashes, \"\") : pathGeneratedFromInputParams;\n  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, \"\");\n  const cleanProviderUrl = providerUrl?.replace(trimSlashes, \"\");\n  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : void 0;\n  const protocol = cleanBlockExplorerUrl.match(/^https?:\\/\\//) ? \"\" : \"https://\";\n  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\\/\\//) ? \"\" : \"https://\";\n  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : \"\"}`;\n  return url;\n}, \"buildBlockExplorerUrl\");\n\n// src/providers/utils/gas.ts\nimport { bn as bn6 } from \"@fuel-ts/math\";\nimport { ReceiptType as ReceiptType3 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify3 } from \"@fuel-ts/utils\";\nvar getGasUsedFromReceipts = /* @__PURE__ */ __name((receipts) => {\n  const scriptResult = receipts.filter(\n    (receipt) => receipt.type === ReceiptType3.ScriptResult\n  );\n  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn6(0));\n  return gasUsed;\n}, \"getGasUsedFromReceipts\");\nfunction resolveGasDependentCosts(byteSize, gasDependentCost) {\n  const base = bn6(gasDependentCost.base);\n  let dependentValue = bn6(0);\n  if (\"unitsPerGas\" in gasDependentCost) {\n    dependentValue = bn6(byteSize).div(bn6(gasDependentCost.unitsPerGas));\n  } else {\n    dependentValue = bn6(byteSize).mul(bn6(gasDependentCost.gasPerUnit));\n  }\n  return base.add(dependentValue);\n}\n__name(resolveGasDependentCosts, \"resolveGasDependentCosts\");\nfunction gasUsedByInputs(inputs, txBytesSize, gasCosts) {\n  const witnessCache = [];\n  const chargeableInputs = inputs.filter((input) => {\n    const isCoinOrMessage = \"owner\" in input || \"sender\" in input;\n    if (isCoinOrMessage) {\n      if (\"predicate\" in input && input.predicate && input.predicate !== \"0x\") {\n        return true;\n      }\n      if (!witnessCache.includes(input.witnessIndex)) {\n        witnessCache.push(input.witnessIndex);\n        return true;\n      }\n    }\n    return false;\n  });\n  const vmInitializationCost = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);\n  const totalGas = chargeableInputs.reduce((total, input) => {\n    if (\"predicate\" in input && input.predicate && input.predicate !== \"0x\") {\n      return total.add(\n        vmInitializationCost.add(resolveGasDependentCosts(arrayify3(input.predicate).length, gasCosts.contractRoot)).add(bn6(input.predicateGasUsed))\n      );\n    }\n    return total.add(gasCosts.ecr1);\n  }, bn6(0));\n  return totalGas;\n}\n__name(gasUsedByInputs, \"gasUsedByInputs\");\nfunction getMinGas(params) {\n  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;\n  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);\n  const bytesGas = bn6(txBytesSize).mul(gasPerByte);\n  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);\n  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();\n  return minGas;\n}\n__name(getMinGas, \"getMinGas\");\nfunction getMaxGas(params) {\n  const {\n    gasPerByte,\n    witnessesLength,\n    witnessLimit,\n    minGas,\n    gasLimit = bn6(0),\n    maxGasPerTx\n  } = params;\n  let remainingAllowedWitnessGas = bn6(0);\n  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {\n    remainingAllowedWitnessGas = bn6(witnessLimit).sub(witnessesLength).mul(gasPerByte);\n  }\n  const maxGas = remainingAllowedWitnessGas.add(minGas).add(gasLimit);\n  return maxGas.gte(maxGasPerTx) ? maxGasPerTx : maxGas;\n}\n__name(getMaxGas, \"getMaxGas\");\nfunction calculateMetadataGasForTxCreate({\n  gasCosts,\n  stateRootSize,\n  txBytesSize,\n  contractBytesSize\n}) {\n  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);\n  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);\n  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n  const contractIdInputSize = bn6(4 + 32 + 32 + 32);\n  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);\n  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);\n  return metadataGas.maxU64();\n}\n__name(calculateMetadataGasForTxCreate, \"calculateMetadataGasForTxCreate\");\nfunction calculateMetadataGasForTxScript({\n  gasCosts,\n  txBytesSize\n}) {\n  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n}\n__name(calculateMetadataGasForTxScript, \"calculateMetadataGasForTxScript\");\nfunction calculateMetadataGasForTxBlob({\n  gasCosts,\n  txBytesSize,\n  witnessBytesSize\n}) {\n  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n  const blobLen = resolveGasDependentCosts(witnessBytesSize, gasCosts.s256);\n  return txId.add(blobLen);\n}\n__name(calculateMetadataGasForTxBlob, \"calculateMetadataGasForTxBlob\");\nfunction calculateMetadataGasForTxUpgrade({\n  gasCosts,\n  txBytesSize,\n  consensusSize\n}) {\n  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n  if (consensusSize) {\n    const consensusLen = resolveGasDependentCosts(consensusSize, gasCosts.s256);\n    txId.add(consensusLen);\n  }\n  return txId;\n}\n__name(calculateMetadataGasForTxUpgrade, \"calculateMetadataGasForTxUpgrade\");\nfunction calculateMetadataGasForTxUpload({\n  gasCosts,\n  txBytesSize,\n  subsectionSize,\n  subsectionsSize\n}) {\n  const txId = resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n  const subsectionLen = resolveGasDependentCosts(subsectionSize, gasCosts.s256);\n  txId.add(subsectionLen);\n  const subsectionsLen = resolveGasDependentCosts(subsectionsSize, gasCosts.stateRoot);\n  txId.add(subsectionsLen);\n  return txId;\n}\n__name(calculateMetadataGasForTxUpload, \"calculateMetadataGasForTxUpload\");\nfunction calculateMinGasForTxUpload({\n  gasCosts,\n  baseMinGas,\n  subsectionSize\n}) {\n  const additionalStoragePerByte = bn6(gasCosts.newStoragePerByte).mul(subsectionSize);\n  return bn6(baseMinGas).add(additionalStoragePerByte);\n}\n__name(calculateMinGasForTxUpload, \"calculateMinGasForTxUpload\");\nvar calculateGasFee = /* @__PURE__ */ __name((params) => {\n  const { gas, gasPrice, priceFactor, tip } = params;\n  return gas.mul(gasPrice).div(priceFactor).add(bn6(tip));\n}, \"calculateGasFee\");\n\n// src/providers/utils/json.ts\nimport { hexlify as hexlify6 } from \"@fuel-ts/utils\";\nimport { clone } from \"ramda\";\nfunction normalize(object) {\n  Object.keys(object).forEach((key) => {\n    switch (object[key]?.constructor.name) {\n      case \"Uint8Array\":\n        object[key] = hexlify6(object[key]);\n        break;\n      case \"Array\":\n        object[key] = normalize(object[key]);\n        break;\n      case \"BN\":\n        object[key] = object[key].toHex();\n        break;\n      case \"Address\":\n        object[key] = object[key].toB256();\n        break;\n      case \"Object\":\n        object[key] = normalize(object[key]);\n        break;\n      default:\n        break;\n    }\n  });\n  return object;\n}\n__name(normalize, \"normalize\");\nfunction normalizeJSON(root) {\n  return normalize(clone(root));\n}\n__name(normalizeJSON, \"normalizeJSON\");\n\n// src/providers/utils/extract-tx-error.ts\nimport { ErrorCode as ErrorCode8, FuelError as FuelError8 } from \"@fuel-ts/errors\";\nimport { bn as bn7 } from \"@fuel-ts/math\";\nimport { ReceiptType as ReceiptType4 } from \"@fuel-ts/transactions\";\nimport {\n  FAILED_REQUIRE_SIGNAL,\n  FAILED_ASSERT_EQ_SIGNAL,\n  FAILED_ASSERT_NE_SIGNAL,\n  FAILED_ASSERT_SIGNAL,\n  FAILED_TRANSFER_TO_ADDRESS_SIGNAL as FAILED_TRANSFER_TO_ADDRESS_SIGNAL2,\n  PANIC_REASONS,\n  PANIC_DOC_URL,\n  SwaySignalErrors\n} from \"@fuel-ts/transactions/configs\";\nvar assemblePanicError = /* @__PURE__ */ __name((statusReason, metadata) => {\n  let errorMessage = `The transaction reverted with reason: \"${statusReason}\".`;\n  if (PANIC_REASONS.includes(statusReason)) {\n    errorMessage = `${errorMessage}\n\nYou can read more about this error at:\n\n${PANIC_DOC_URL}#variant.${statusReason}`;\n  }\n  return new FuelError8(ErrorCode8.SCRIPT_REVERTED, errorMessage, {\n    ...metadata,\n    reason: statusReason\n  });\n}, \"assemblePanicError\");\nvar stringify = /* @__PURE__ */ __name((obj) => JSON.stringify(obj, null, 2), \"stringify\");\nvar assembleSignalErrorMessage = /* @__PURE__ */ __name((reasonHex, logs, metadata) => {\n  let errorMessage = \"The transaction reverted with an unknown reason.\";\n  let reason = \"\";\n  const lastLog = logs[logs.length - 1];\n  const lastButOneLog = logs[logs.length - 2];\n  switch (reasonHex) {\n    case FAILED_REQUIRE_SIGNAL: {\n      reason = \"require\";\n      errorMessage = `The transaction reverted because a \"require\" statement has thrown ${logs.length ? stringify(lastLog) : \"an error.\"}.`;\n      break;\n    }\n    case FAILED_ASSERT_EQ_SIGNAL: {\n      const suffix = logs.length >= 2 ? ` comparing ${stringify(lastLog)} and ${stringify(lastButOneLog)}.` : \".\";\n      reason = \"assert_eq\";\n      errorMessage = `The transaction reverted because of an \"assert_eq\" statement${suffix}`;\n      break;\n    }\n    case FAILED_ASSERT_NE_SIGNAL: {\n      const suffix = logs.length >= 2 ? ` comparing ${stringify(lastButOneLog)} and ${stringify(lastLog)}.` : \".\";\n      reason = \"assert_ne\";\n      errorMessage = `The transaction reverted because of an \"assert_ne\" statement${suffix}`;\n      break;\n    }\n    case FAILED_ASSERT_SIGNAL:\n      reason = \"assert\";\n      errorMessage = `The transaction reverted because an \"assert\" statement failed to evaluate to true.`;\n      break;\n    case FAILED_TRANSFER_TO_ADDRESS_SIGNAL2:\n      reason = \"MissingOutputVariable\";\n      errorMessage = `The transaction reverted because it's missing an \"OutputVariable\".`;\n      break;\n    default:\n      reason = `revert_with_log`;\n      errorMessage = `The transaction reverted because a \"revert_with_log\" statement has thrown ${logs.length ? stringify(lastLog) : \"an error.\"}.`;\n      break;\n  }\n  return new FuelError8(ErrorCode8.SCRIPT_REVERTED, errorMessage, {\n    ...metadata,\n    reason\n  });\n}, \"assembleSignalErrorMessage\");\nfunction buildAbiErrorMessage(abiError, logs, metadata, reason) {\n  const { pos, msg } = abiError;\n  let errorMessage = \"\";\n  const positionMessage = pos ? `\n\nThis error originated at ${JSON.stringify(pos, null, 2)}` : \"\";\n  if (msg) {\n    errorMessage = `A sway \"panic\" expression was invoked with the message: \"${msg}\".${positionMessage}`;\n  } else {\n    const value = logs[logs.length - 1];\n    errorMessage = `A sway \"panic\" expression was invoked with the value: ${JSON.stringify(value)}.${positionMessage}`;\n  }\n  return new FuelError8(ErrorCode8.SCRIPT_REVERTED, errorMessage, {\n    ...metadata,\n    abiError,\n    reason\n  });\n}\n__name(buildAbiErrorMessage, \"buildAbiErrorMessage\");\nfunction findErrorInAbis(statusReason, abis = []) {\n  for (const abi of abis) {\n    if (abi.errorCodes?.[statusReason]) {\n      return abi.errorCodes[statusReason];\n    }\n  }\n  return void 0;\n}\n__name(findErrorInAbis, \"findErrorInAbis\");\nvar assembleRevertError = /* @__PURE__ */ __name((_receipts, logs, metadata, statusReason, abis) => {\n  const match = statusReason.match(/Revert\\((\\d+)\\)/);\n  const reason = match?.[1] ?? statusReason;\n  const reasonHex = bn7(reason).toHex();\n  if (Object.values(SwaySignalErrors).includes(reasonHex)) {\n    return assembleSignalErrorMessage(reasonHex, logs, metadata);\n  }\n  let abiError;\n  if (abis) {\n    const abisArr = [abis.main, ...Object.values(abis.otherContractsAbis)];\n    abiError = findErrorInAbis(reason, abisArr);\n  }\n  if (abiError) {\n    return buildAbiErrorMessage(abiError, logs, metadata, reason);\n  }\n  const errorMessage = `The transaction reverted with reason: ${reason}.`;\n  return new FuelError8(ErrorCode8.SCRIPT_REVERTED, errorMessage, {\n    ...metadata,\n    reason\n  });\n}, \"assembleRevertError\");\nvar extractTxError = /* @__PURE__ */ __name((params) => {\n  const { receipts, statusReason, logs, groupedLogs, abis } = params;\n  const isPanic = receipts.some(({ type }) => type === ReceiptType4.Panic);\n  const isRevert = receipts.some(({ type }) => type === ReceiptType4.Revert);\n  const metadata = {\n    logs,\n    groupedLogs,\n    receipts,\n    panic: isPanic,\n    revert: isRevert,\n    reason: \"\"\n  };\n  if (isPanic) {\n    return assemblePanicError(statusReason, metadata);\n  }\n  return assembleRevertError(receipts, logs, metadata, statusReason, abis);\n}, \"extractTxError\");\n\n// src/providers/utils/merge-quantities.ts\nvar mergeQuantities = /* @__PURE__ */ __name((...coinQuantities) => {\n  const resultMap = {};\n  function addToMap({ amount, assetId }) {\n    if (resultMap[assetId]) {\n      resultMap[assetId] = resultMap[assetId].add(amount);\n    } else {\n      resultMap[assetId] = amount;\n    }\n  }\n  __name(addToMap, \"addToMap\");\n  coinQuantities.forEach((arr) => arr.forEach(addToMap));\n  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));\n}, \"mergeQuantities\");\n\n// src/providers/transaction-request/errors.ts\nvar ChangeOutputCollisionError = class extends Error {\n  static {\n    __name(this, \"ChangeOutputCollisionError\");\n  }\n  name = \"ChangeOutputCollisionError\";\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n};\nvar NoWitnessAtIndexError = class extends Error {\n  constructor(index) {\n    super();\n    this.index = index;\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n  static {\n    __name(this, \"NoWitnessAtIndexError\");\n  }\n  name = \"NoWitnessAtIndexError\";\n};\nvar NoWitnessByOwnerError = class extends Error {\n  constructor(owner) {\n    super();\n    this.owner = owner;\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n  static {\n    __name(this, \"NoWitnessByOwnerError\");\n  }\n  name = \"NoWitnessByOwnerError\";\n};\n\n// src/providers/transaction-request/helpers.ts\nimport { ErrorCode as ErrorCode9, FuelError as FuelError9 } from \"@fuel-ts/errors\";\nimport { bn as bn8 } from \"@fuel-ts/math\";\nimport { InputType as InputType3, OutputType as OutputType3 } from \"@fuel-ts/transactions\";\nimport { hexlify as hexlify7 } from \"@fuel-ts/utils\";\nvar isRequestInputCoin = /* @__PURE__ */ __name((input) => input.type === InputType3.Coin, \"isRequestInputCoin\");\nvar isRequestInputMessage = /* @__PURE__ */ __name((input) => input.type === InputType3.Message, \"isRequestInputMessage\");\nvar isRequestInputMessageWithoutData = /* @__PURE__ */ __name((input) => input.type === InputType3.Message && bn8(input.data).isZero(), \"isRequestInputMessageWithoutData\");\nvar isRequestInputCoinOrMessage = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) || isRequestInputMessage(input), \"isRequestInputCoinOrMessage\");\nvar isRequestInputResource = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) || isRequestInputMessageWithoutData(input), \"isRequestInputResource\");\nvar getRequestInputResourceOwner = /* @__PURE__ */ __name((input) => isRequestInputCoin(input) ? input.owner : input.recipient, \"getRequestInputResourceOwner\");\nvar isRequestInputResourceFromOwner = /* @__PURE__ */ __name((input, owner) => getRequestInputResourceOwner(input) === owner.toB256(), \"isRequestInputResourceFromOwner\");\nvar isPredicate = /* @__PURE__ */ __name((input) => isRequestInputCoinOrMessage(input) && !!input.predicate && hexlify7(input.predicate) !== \"0x\", \"isPredicate\");\nvar getAssetAmountInRequestInputs = /* @__PURE__ */ __name((inputs, assetId, baseAsset) => inputs.filter(isRequestInputResource).reduce((acc, input) => {\n  if (isRequestInputCoin(input) && input.assetId === assetId) {\n    return acc.add(input.amount);\n  }\n  if (isRequestInputMessage(input) && assetId === baseAsset) {\n    return acc.add(input.amount);\n  }\n  return acc;\n}, bn8(0)), \"getAssetAmountInRequestInputs\");\nvar cacheRequestInputsResources = /* @__PURE__ */ __name((inputs) => inputs.filter(isRequestInputResource).reduce(\n  (cache2, input) => {\n    if (isRequestInputCoin(input)) {\n      cache2.utxos.push(input.id);\n    } else {\n      cache2.messages.push(input.nonce);\n    }\n    return cache2;\n  },\n  {\n    utxos: [],\n    messages: []\n  }\n), \"cacheRequestInputsResources\");\nvar cacheRequestInputsResourcesFromOwner = /* @__PURE__ */ __name((inputs, owner) => inputs.reduce(\n  (acc, input) => {\n    if (isRequestInputCoin(input) && input.owner === owner.toB256()) {\n      acc.utxos.push(input.id);\n    } else if (isRequestInputMessage(input) && input.recipient === owner.toB256()) {\n      acc.messages.push(input.nonce);\n    }\n    return acc;\n  },\n  {\n    utxos: [],\n    messages: []\n  }\n), \"cacheRequestInputsResourcesFromOwner\");\nvar getBurnableAssetCount = /* @__PURE__ */ __name((baseAssetId, transactionRequest) => {\n  const { inputs, outputs } = transactionRequest;\n  const coinInputs = new Set(inputs.filter(isRequestInputCoin).map((input) => input.assetId));\n  if (inputs.some((i) => isRequestInputMessage(i) && bn8(i.amount).gt(0))) {\n    coinInputs.add(baseAssetId);\n  }\n  const changeOutputs = new Set(\n    outputs.filter((output) => output.type === OutputType3.Change).map((output) => output.assetId)\n  );\n  const difference = new Set([...coinInputs].filter((x) => !changeOutputs.has(x)));\n  return difference.size;\n}, \"getBurnableAssetCount\");\nvar validateTransactionForAssetBurn = /* @__PURE__ */ __name((baseAssetId, transactionRequest, enableAssetBurn = false) => {\n  if (enableAssetBurn === true) {\n    return;\n  }\n  if (getBurnableAssetCount(baseAssetId, transactionRequest) <= 0) {\n    return;\n  }\n  const message = [\n    \"Asset burn detected.\",\n    \"Add the relevant change outputs to the transaction to avoid burning assets.\",\n    \"Or enable asset burn, upon sending the transaction.\"\n  ].join(\"\\n\");\n  throw new FuelError9(ErrorCode9.ASSET_BURN_DETECTED, message);\n}, \"validateTransactionForAssetBurn\");\n\n// src/providers/transaction-request/witness.ts\nimport { arrayify as arrayify4, hexlify as hexlify8 } from \"@fuel-ts/utils\";\nvar witnessify = /* @__PURE__ */ __name((value) => {\n  const data = arrayify4(value);\n  return {\n    data: hexlify8(data),\n    dataLength: data.length\n  };\n}, \"witnessify\");\n\n// src/providers/transaction-request/transaction-request.ts\nvar BaseTransactionRequest = class _BaseTransactionRequest {\n  static {\n    __name(this, \"BaseTransactionRequest\");\n  }\n  /** Gas price for transaction */\n  tip;\n  /** Block until which tx cannot be included */\n  maturity;\n  /** The block number after which the transaction is no longer valid. */\n  expiration;\n  /** The maximum fee payable by this transaction using BASE_ASSET. */\n  maxFee;\n  /** The maximum amount of witness data allowed for the transaction */\n  witnessLimit;\n  /** List of inputs */\n  inputs = [];\n  /** List of outputs */\n  outputs = [];\n  /** List of witnesses */\n  witnesses = [];\n  /**\n   * The current status of the transaction\n   */\n  flag = { state: void 0, transactionId: void 0, summary: void 0 };\n  /**\n   * Constructor for initializing a base transaction request.\n   *\n   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.\n   */\n  constructor({\n    tip,\n    maturity,\n    expiration,\n    maxFee,\n    witnessLimit,\n    inputs,\n    outputs,\n    witnesses,\n    flag\n  } = {}) {\n    this.tip = tip ? bn9(tip) : void 0;\n    this.maturity = maturity && maturity > 0 ? maturity : void 0;\n    this.expiration = expiration && expiration > 0 ? expiration : void 0;\n    this.witnessLimit = isDefined2(witnessLimit) ? bn9(witnessLimit) : void 0;\n    this.maxFee = bn9(maxFee);\n    this.inputs = inputs ?? [];\n    this.outputs = outputs ?? [];\n    this.witnesses = witnesses ?? [];\n    this.flag = flag ?? { state: void 0, transactionId: void 0, summary: void 0 };\n  }\n  static getPolicyMeta(req) {\n    let policyTypes = 0;\n    const policies = [];\n    const { tip, witnessLimit, maturity, expiration } = req;\n    if (bn9(tip).gt(0)) {\n      policyTypes += PolicyType.Tip;\n      policies.push({ data: bn9(tip), type: PolicyType.Tip });\n    }\n    if (isDefined2(witnessLimit) && bn9(witnessLimit).gte(0)) {\n      policyTypes += PolicyType.WitnessLimit;\n      policies.push({ data: bn9(witnessLimit), type: PolicyType.WitnessLimit });\n    }\n    if (maturity && maturity > 0) {\n      policyTypes += PolicyType.Maturity;\n      policies.push({ data: maturity, type: PolicyType.Maturity });\n    }\n    policyTypes += PolicyType.MaxFee;\n    policies.push({ data: req.maxFee, type: PolicyType.MaxFee });\n    if (expiration && expiration > 0) {\n      policyTypes += PolicyType.Expiration;\n      policies.push({ data: expiration, type: PolicyType.Expiration });\n    }\n    return {\n      policyTypes,\n      policies\n    };\n  }\n  /**\n   * Method to obtain the base transaction details.\n   *\n   * @returns The base transaction details.\n   */\n  getBaseTransaction() {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n    const { policyTypes, policies } = _BaseTransactionRequest.getPolicyMeta(this);\n    return {\n      policyTypes,\n      inputs,\n      outputs,\n      policies,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length\n    };\n  }\n  /**\n   * Converts the transaction request to a byte array.\n   *\n   * @returns The transaction bytes.\n   */\n  toTransactionBytes() {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n  /**\n   * @hidden\n   *\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  pushInput(input) {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n  /**\n   * @hidden\n   *\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  pushOutput(output) {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n  /**\n   * @hidden\n   *\n   * Pushes a witness to the list and returns the index\n   *\n   * @param signature - The signature to add to the witness.\n   * @returns The index of the created witness.\n   */\n  addWitness(signature) {\n    this.witnesses.push(signature);\n    return this.witnesses.length - 1;\n  }\n  /**\n   * @hidden\n   *\n   * Creates an empty witness without any side effects and returns the index\n   *\n   * @returns The index of the created witness.\n   */\n  addEmptyWitness() {\n    return this.addWitness(concat([ZeroBytes324, ZeroBytes324]));\n  }\n  /**\n   * Updates the witness for a given owner and signature.\n   *\n   * @param address - The address to get the coin input witness index for.\n   * @param signature - The signature to update the witness with.\n   */\n  updateWitnessByOwner(address, signature) {\n    const ownerAddress = new Address(address);\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(ownerAddress);\n    if (typeof witnessIndex === \"number\") {\n      this.updateWitness(witnessIndex, signature);\n    }\n  }\n  /**\n   * Updates an existing witness without any side effects.\n   *\n   * @param index - The index of the witness to update.\n   * @param witness - The new witness.\n   * @throws If the witness does not exist.\n   */\n  updateWitness(index, witness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n  /**\n   * Helper function to add an external signature to the transaction.\n   *\n   * @param account - The account/s to sign to the transaction.\n   * @returns The transaction with the signature witness added.\n   */\n  async addAccountWitnesses(account) {\n    const accounts = Array.isArray(account) ? account : [account];\n    await Promise.all(\n      accounts.map(async (acc) => {\n        this.addWitness(await acc.signTransaction(this));\n      })\n    );\n    return this;\n  }\n  /**\n   * Gets the coin inputs for a transaction.\n   *\n   * @returns The coin inputs.\n   */\n  getCoinInputs() {\n    return this.inputs.filter(\n      (input) => input.type === InputType4.Coin\n    );\n  }\n  /**\n   * Gets the coin outputs for a transaction.\n   *\n   * @returns The coin outputs.\n   */\n  getCoinOutputs() {\n    return this.outputs.filter(\n      (output) => output.type === OutputType4.Coin\n    );\n  }\n  /**\n   * Gets the change outputs for a transaction.\n   *\n   * @returns The change outputs.\n   */\n  getChangeOutputs() {\n    return this.outputs.filter(\n      (output) => output.type === OutputType4.Change\n    );\n  }\n  /**\n   * @hidden\n   *\n   * Returns the witnessIndex of the found CoinInput.\n   */\n  getCoinInputWitnessIndexByOwner(owner) {\n    const ownerAddress = addressify(owner);\n    const found = this.inputs.find((input) => {\n      switch (input.type) {\n        case InputType4.Coin:\n          return hexlify9(input.owner) === ownerAddress.toB256();\n        case InputType4.Message:\n          return hexlify9(input.recipient) === ownerAddress.toB256();\n        default:\n          return false;\n      }\n    });\n    return found?.witnessIndex;\n  }\n  /**\n   * Adds a single coin input to the transaction and a change output for the related\n   * assetId, if one it was not added yet.\n   *\n   * @param coin - Coin resource.\n   */\n  addCoinInput(coin) {\n    const { assetId, owner, amount, id, predicate, predicateData } = coin;\n    let witnessIndex;\n    if (coin.predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n      if (typeof witnessIndex !== \"number\") {\n        witnessIndex = this.addEmptyWitness();\n      }\n    }\n    const input = {\n      id,\n      type: InputType4.Coin,\n      owner: owner.toB256(),\n      amount,\n      assetId,\n      txPointer: \"0x00000000000000000000000000000000\",\n      witnessIndex,\n      predicate,\n      predicateData\n    };\n    this.pushInput(input);\n    this.addChangeOutput(owner, assetId);\n  }\n  /**\n   * Adds a single message input to the transaction and a change output for the\n   * asset against the message\n   *\n   * @param message - Message resource.\n   */\n  addMessageInput(message) {\n    const { recipient, sender, amount, predicate, nonce, predicateData } = message;\n    let witnessIndex;\n    if (message.predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);\n      if (typeof witnessIndex !== \"number\") {\n        witnessIndex = this.addEmptyWitness();\n      }\n    }\n    const input = {\n      nonce,\n      type: InputType4.Message,\n      sender: sender.toB256(),\n      recipient: recipient.toB256(),\n      data: isMessageCoin(message) ? \"0x\" : message.data,\n      amount,\n      witnessIndex,\n      predicate,\n      predicateData\n    };\n    this.pushInput(input);\n    if (isMessageCoin(message)) {\n      this.addChangeOutput(recipient, message.assetId);\n    }\n  }\n  /**\n   * Adds a single resource to the transaction by adding a coin/message input and a\n   * change output for the related assetId, if one it was not added yet.\n   *\n   * @param resource - The resource to add.\n   * @returns This transaction.\n   */\n  addResource(resource) {\n    if (isCoin(resource)) {\n      this.addCoinInput(resource);\n    } else {\n      this.addMessageInput(resource);\n    }\n    return this;\n  }\n  /**\n   * Adds multiple resources to the transaction by adding coin/message inputs and change\n   * outputs from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addResources(resources) {\n    resources.forEach((resource) => this.addResource(resource));\n    return this;\n  }\n  /**\n   * Adds a coin output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param amount - Amount of coin.\n   * @param assetId - Asset ID of coin.\n   */\n  addCoinOutput(to, amount, assetId) {\n    this.pushOutput({\n      type: OutputType4.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId\n    });\n    return this;\n  }\n  /**\n   * Adds multiple coin outputs to the transaction.\n   *\n   * @param to - Address of the destination.\n   * @param quantities - Quantities of coins.\n   */\n  addCoinOutputs(to, quantities) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType4.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId\n      });\n    });\n    return this;\n  }\n  /**\n   * Adds a change output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param assetId - Asset ID of coin.\n   */\n  addChangeOutput(to, assetId) {\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify9(output.assetId) === assetId\n    );\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType4.Change,\n        to: addressify(to).toB256(),\n        assetId\n      });\n    }\n  }\n  /**\n   * @hidden\n   */\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n  /**\n   * @hidden\n   */\n  metadataGas(_gasCosts) {\n    throw new FuelError10(FuelError10.CODES.NOT_IMPLEMENTED, \"Not implemented\");\n  }\n  /**\n   * @hidden\n   */\n  calculateMinGas(chainInfo) {\n    const { consensusParameters } = chainInfo;\n    const {\n      gasCosts,\n      feeParameters: { gasPerByte }\n    } = consensusParameters;\n    return getMinGas({\n      gasPerByte,\n      gasCosts,\n      inputs: this.inputs,\n      txBytesSize: this.byteSize(),\n      metadataGas: this.metadataGas(gasCosts)\n    });\n  }\n  calculateMaxGas(chainInfo, minGas) {\n    const { consensusParameters } = chainInfo;\n    const {\n      feeParameters: { gasPerByte },\n      txParameters: { maxGasPerTx }\n    } = consensusParameters;\n    const witnessesLength = this.toTransaction().witnesses.reduce(\n      (acc, wit) => acc + wit.dataLength,\n      0\n    );\n    return getMaxGas({\n      gasPerByte,\n      minGas,\n      witnessesLength,\n      witnessLimit: this.witnessLimit,\n      maxGasPerTx\n    });\n  }\n  /**\n   * Funds the transaction with fake UTXOs for each assetId and amount in the\n   * quantities array.\n   *\n   * @param quantities - CoinQuantity Array.\n   * @param baseAssetId - The base asset to fund the transaction.\n   * @deprecated - This method is deprecated and will be removed in future versions.\n   * Please use `Account.generateFakeResources` along with `this.addResources` instead.\n   */\n  fundWithFakeUtxos(quantities, baseAssetId, resourcesOwner) {\n    const findAssetInput = /* @__PURE__ */ __name((assetId) => this.inputs.find((input) => {\n      if (\"assetId\" in input) {\n        return input.assetId === assetId;\n      }\n      return false;\n    }), \"findAssetInput\");\n    const updateAssetInput = /* @__PURE__ */ __name((assetId, quantity) => {\n      const assetInput = findAssetInput(assetId);\n      let usedQuantity = quantity;\n      if (assetId === baseAssetId) {\n        usedQuantity = bn9(\"1000000000000000000\");\n      }\n      if (assetInput && \"assetId\" in assetInput) {\n        assetInput.id = hexlify9(randomBytes(UTXO_ID_LEN2));\n        assetInput.amount = usedQuantity;\n      } else {\n        this.addResources([\n          {\n            id: hexlify9(randomBytes(UTXO_ID_LEN2)),\n            amount: usedQuantity,\n            assetId,\n            owner: resourcesOwner || Address.fromRandom(),\n            blockCreated: bn9(1),\n            txCreatedIdx: bn9(1)\n          }\n        ]);\n      }\n    }, \"updateAssetInput\");\n    updateAssetInput(baseAssetId, bn9(1e11));\n    quantities.forEach((q) => updateAssetInput(q.assetId, q.amount));\n    return this;\n  }\n  /**\n   * Retrieves an array of CoinQuantity for each coin output present in the transaction.\n   * a transaction.\n   *\n   * @returns  CoinQuantity array.\n   */\n  getCoinOutputsQuantities() {\n    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({\n      amount: bn9(amount),\n      assetId: assetId.toString()\n    }));\n    return coinsQuantities;\n  }\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * @returns The transaction as a JSON object.\n   */\n  toJSON() {\n    return normalizeJSON(this);\n  }\n  removeWitness(index) {\n    this.witnesses.splice(index, 1);\n    this.adjustWitnessIndexes(index);\n  }\n  adjustWitnessIndexes(removedIndex) {\n    this.inputs.filter(isRequestInputResource).forEach((input) => {\n      if (input.witnessIndex > removedIndex) {\n        input.witnessIndex -= 1;\n      }\n    });\n  }\n  updatePredicateGasUsed(inputs) {\n    const inputsToExtractGasUsed = inputs.filter(isRequestInputCoinOrMessage);\n    this.inputs.filter(isRequestInputResource).forEach((i) => {\n      const owner = getRequestInputResourceOwner(i);\n      const correspondingInput = inputsToExtractGasUsed.find(\n        (x) => isRequestInputResourceFromOwner(x, new Address(String(owner)))\n      );\n      if (correspondingInput && \"predicateGasUsed\" in correspondingInput && bn9(correspondingInput.predicateGasUsed).gt(0)) {\n        i.predicateGasUsed = correspondingInput.predicateGasUsed;\n      }\n    });\n  }\n  byteLength() {\n    return this.toTransactionBytes().byteLength;\n  }\n  /**\n   * @hidden\n   *\n   * Used internally to update the state of a transaction request.\n   *\n   * @param state - The state to update.\n   */\n  updateState(chainId, state, summary) {\n    if (!state) {\n      this.flag = { state: void 0, transactionId: void 0, summary: void 0 };\n      return;\n    }\n    const transactionId = this.getTransactionId(chainId);\n    this.flag = { state, transactionId, summary };\n  }\n};\n\n// src/providers/transaction-request/blob-transaction-request.ts\nimport { clone as clone3 } from \"ramda\";\n\n// src/providers/transaction-request/hash-transaction.ts\nimport { ZeroBytes32 as ZeroBytes325 } from \"@fuel-ts/address/configs\";\nimport { uint64ToBytesBE, sha256 } from \"@fuel-ts/hasher\";\nimport { bn as bn10 } from \"@fuel-ts/math\";\nimport { TransactionType as TransactionType3, InputType as InputType5, OutputType as OutputType5, TransactionCoder as TransactionCoder2 } from \"@fuel-ts/transactions\";\nimport { concat as concat2 } from \"@fuel-ts/utils\";\nimport { clone as clone2 } from \"ramda\";\nfunction hashTransaction(transactionRequest, chainId) {\n  const transaction = transactionRequest.toTransaction();\n  if (transaction.type === TransactionType3.Script) {\n    transaction.receiptsRoot = ZeroBytes325;\n  }\n  transaction.inputs = transaction.inputs.map((input) => {\n    const inputClone = clone2(input);\n    switch (inputClone.type) {\n      // Zero out on signing: txPointer, predicateGasUsed\n      case InputType5.Coin: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0\n        };\n        inputClone.predicateGasUsed = bn10(0);\n        return inputClone;\n      }\n      // Zero out on signing: predicateGasUsed\n      case InputType5.Message: {\n        inputClone.predicateGasUsed = bn10(0);\n        return inputClone;\n      }\n      // Zero out on signing: txID, outputIndex, balanceRoot, stateRoot, and txPointer\n      case InputType5.Contract: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0\n        };\n        inputClone.txID = ZeroBytes325;\n        inputClone.outputIndex = 0;\n        inputClone.balanceRoot = ZeroBytes325;\n        inputClone.stateRoot = ZeroBytes325;\n        return inputClone;\n      }\n      default:\n        return inputClone;\n    }\n  });\n  transaction.outputs = transaction.outputs.map((output) => {\n    const outputClone = clone2(output);\n    switch (outputClone.type) {\n      // Zero out on signing: balanceRoot, stateRoot\n      case OutputType5.Contract: {\n        outputClone.balanceRoot = ZeroBytes325;\n        outputClone.stateRoot = ZeroBytes325;\n        return outputClone;\n      }\n      // Zero out on signing: amount\n      case OutputType5.Change: {\n        outputClone.amount = bn10(0);\n        return outputClone;\n      }\n      // Zero out on signing: amount, to and assetId\n      case OutputType5.Variable: {\n        outputClone.to = ZeroBytes325;\n        outputClone.amount = bn10(0);\n        outputClone.assetId = ZeroBytes325;\n        return outputClone;\n      }\n      default:\n        return outputClone;\n    }\n  });\n  transaction.witnessesCount = 0;\n  transaction.witnesses = [];\n  const chainIdBytes = uint64ToBytesBE(chainId);\n  const concatenatedData = concat2([chainIdBytes, new TransactionCoder2().encode(transaction)]);\n  return sha256(concatenatedData);\n}\n__name(hashTransaction, \"hashTransaction\");\n\n// src/providers/transaction-request/blob-transaction-request.ts\nvar BlobTransactionRequest = class extends BaseTransactionRequest {\n  static {\n    __name(this, \"BlobTransactionRequest\");\n  }\n  static from(obj) {\n    return new this(clone3(obj));\n  }\n  /** Type of the transaction */\n  type = TransactionType2.Blob;\n  /** Blob ID */\n  blobId;\n  /** Witness index of the bytecode to create */\n  witnessIndex;\n  /**\n   * Creates an instance `BlobTransactionRequest`.\n   *\n   * @param blobTransactionRequestLike - The initial values for the instance\n   */\n  constructor({ witnessIndex, blobId, ...rest }) {\n    super(rest);\n    this.blobId = blobId;\n    this.witnessIndex = witnessIndex ?? 0;\n  }\n  /**\n   * Converts the transaction request to a `TransactionBlob`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction() {\n    const baseTransaction = this.getBaseTransaction();\n    const { witnessIndex, blobId } = this;\n    return {\n      type: TransactionType2.Blob,\n      ...baseTransaction,\n      blobId,\n      witnessIndex\n    };\n  }\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId) {\n    return hashTransaction(this, chainId);\n  }\n  /**\n   * Calculates the metadata gas cost for a blob transaction.\n   *\n   * @param gasCosts - gas costs passed from the chain.\n   * @returns metadata gas cost for the blob transaction.\n   */\n  metadataGas(gasCosts) {\n    return calculateMetadataGasForTxBlob({\n      gasCosts,\n      txBytesSize: this.byteSize(),\n      witnessBytesSize: this.witnesses[this.witnessIndex].length\n    });\n  }\n};\n\n// src/providers/transaction-request/create-transaction-request.ts\nimport { ZeroBytes32 as ZeroBytes326 } from \"@fuel-ts/address/configs\";\nimport { bn as bn11 } from \"@fuel-ts/math\";\nimport { TransactionType as TransactionType4, OutputType as OutputType6 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify6, hexlify as hexlify11 } from \"@fuel-ts/utils\";\nimport { clone as clone4 } from \"ramda\";\n\n// src/providers/transaction-request/storage-slot.ts\nimport { arrayify as arrayify5, hexlify as hexlify10 } from \"@fuel-ts/utils\";\nvar getStorageValue = /* @__PURE__ */ __name((value) => {\n  const v = new Uint8Array(32);\n  v.set(arrayify5(value));\n  return v;\n}, \"getStorageValue\");\nvar storageSlotify = /* @__PURE__ */ __name((storageSlot) => {\n  let key;\n  let value;\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n  return {\n    key: hexlify10(key),\n    value: hexlify10(getStorageValue(value))\n  };\n}, \"storageSlotify\");\n\n// src/providers/transaction-request/create-transaction-request.ts\nvar CreateTransactionRequest = class extends BaseTransactionRequest {\n  static {\n    __name(this, \"CreateTransactionRequest\");\n  }\n  static from(obj) {\n    return new this(clone4(obj));\n  }\n  /** Type of the transaction */\n  type = TransactionType4.Create;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex;\n  /** Salt */\n  salt;\n  /** List of storage slots to initialize */\n  storageSlots;\n  /**\n   * Creates an instance `CreateTransactionRequest`.\n   *\n   * @param createTransactionRequestLike - The initial values for the instance\n   */\n  constructor({ bytecodeWitnessIndex, salt, storageSlots, ...rest }) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify11(salt ?? ZeroBytes326);\n    this.storageSlots = [...storageSlots ?? []];\n  }\n  /**\n   * Converts the transaction request to a `TransactionCreate`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction() {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType4.Create,\n      ...baseTransaction,\n      bytecodeWitnessIndex,\n      storageSlotsCount: bn11(storageSlots.length),\n      salt: this.salt ? hexlify11(this.salt) : ZeroBytes326,\n      storageSlots\n    };\n  }\n  /**\n   * Get contract created outputs for the transaction.\n   *\n   * @returns An array of contract created transaction request outputs.\n   */\n  getContractCreatedOutputs() {\n    return this.outputs.filter(\n      (output) => output.type === OutputType6.ContractCreated\n    );\n  }\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId) {\n    return hashTransaction(this, chainId);\n  }\n  /**\n   * Adds a contract created output to the transaction request.\n   *\n   * @param contractId - The contract ID.\n   * @param stateRoot - The state root.\n   */\n  addContractCreatedOutput(contractId, stateRoot) {\n    this.pushOutput({\n      type: OutputType6.ContractCreated,\n      contractId,\n      stateRoot\n    });\n  }\n  metadataGas(gasCosts) {\n    return calculateMetadataGasForTxCreate({\n      contractBytesSize: bn11(arrayify6(this.witnesses[this.bytecodeWitnessIndex] || \"0x\").length),\n      gasCosts,\n      stateRootSize: this.storageSlots.length,\n      txBytesSize: this.byteSize()\n    });\n  }\n};\n\n// src/providers/transaction-request/script-transaction-request.ts\nimport { Interface } from \"@fuel-ts/abi-coder\";\nimport { addressify as addressify2 } from \"@fuel-ts/address\";\nimport { ZeroBytes32 as ZeroBytes327 } from \"@fuel-ts/address/configs\";\nimport { bn as bn12 } from \"@fuel-ts/math\";\nimport { InputType as InputType6, OutputType as OutputType7, TransactionType as TransactionType5 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify8, hexlify as hexlify12 } from \"@fuel-ts/utils\";\nimport { clone as clone5 } from \"ramda\";\n\n// src/providers/transaction-request/scripts.ts\nimport { arrayify as arrayify7 } from \"@fuel-ts/utils\";\nvar returnZeroScript = {\n  /*\n      Opcode::RET(REG_ZERO)\n      Opcode::NOOP\n    */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify7(\"0x24000000\"),\n  encodeScriptData: /* @__PURE__ */ __name(() => new Uint8Array(0), \"encodeScriptData\")\n};\nvar withdrawScript = {\n  /*\n          The following code loads some basic values into registers and calls SMO to create an output message\n          5040C010 \t- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]\n          5D44C006\t- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]\n          4C400011\t- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]\n          24000000\t- RET                [return 0]\n          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]\n          00000000 00000000 [amount value]\n      */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: arrayify7(\"0x5040C0105D44C0064C40001124000000\"),\n  encodeScriptData: /* @__PURE__ */ __name(() => new Uint8Array(0), \"encodeScriptData\")\n};\n\n// src/providers/transaction-request/script-transaction-request.ts\nvar ScriptTransactionRequest = class extends BaseTransactionRequest {\n  static {\n    __name(this, \"ScriptTransactionRequest\");\n  }\n  static from(obj) {\n    return new this(clone5(obj));\n  }\n  /** Type of the transaction */\n  type = TransactionType5.Script;\n  /** Gas limit for transaction */\n  gasLimit;\n  /** Script to execute */\n  script;\n  /** Script input data (parameters) */\n  scriptData;\n  abis;\n  /**\n   * Constructor for `ScriptTransactionRequest`.\n   *\n   * @param scriptTransactionRequestLike - The initial values for the instance.\n   */\n  constructor({ script, scriptData, gasLimit, ...rest } = {}) {\n    super(rest);\n    this.gasLimit = bn12(gasLimit);\n    this.script = arrayify8(script ?? returnZeroScript.bytes);\n    this.scriptData = arrayify8(scriptData ?? returnZeroScript.encodeScriptData());\n    this.abis = rest.abis;\n  }\n  /**\n   * Helper function to estimate and fund the transaction request with a specified account.\n   *\n   * @param account - The account to fund the transaction.\n   * @param params - The parameters for the transaction cost.\n   * @returns The current instance of the `ScriptTransactionRequest` funded.\n   *\n   * @deprecated Use `provider.assembleTx` instead.\n   * Check the migration guide https://docs.fuel.network/guide/assembling-transactions/migration-guide.html for more information.\n   */\n  async estimateAndFund(account, {\n    signatureCallback,\n    quantities = [],\n    skipAutoConsolidation\n  } = {}) {\n    const txCost = await account.getTransactionCost(this, { signatureCallback, quantities });\n    this.maxFee = txCost.maxFee;\n    this.gasLimit = txCost.gasUsed;\n    await account.fund(this, txCost, { skipAutoConsolidation });\n    return this;\n  }\n  /**\n   * Converts the transaction request to a `TransactionScript`.\n   *\n   * @returns The transaction script object.\n   */\n  toTransaction() {\n    const script = arrayify8(this.script ?? \"0x\");\n    const scriptData = arrayify8(this.scriptData ?? \"0x\");\n    return {\n      type: TransactionType5.Script,\n      scriptGasLimit: this.gasLimit,\n      ...super.getBaseTransaction(),\n      scriptLength: bn12(script.length),\n      scriptDataLength: bn12(scriptData.length),\n      receiptsRoot: ZeroBytes327,\n      script: hexlify12(script),\n      scriptData: hexlify12(scriptData)\n    };\n  }\n  /**\n   * Get contract inputs for the transaction.\n   *\n   * @returns An array of contract transaction request inputs.\n   */\n  getContractInputs() {\n    return this.inputs.filter(\n      (input) => input.type === InputType6.Contract\n    );\n  }\n  /**\n   * Get contract outputs for the transaction.\n   *\n   * @returns An array of contract transaction request outputs.\n   */\n  getContractOutputs() {\n    return this.outputs.filter(\n      (output) => output.type === OutputType7.Contract\n    );\n  }\n  /**\n   * Get variable outputs for the transaction.\n   *\n   * @returns An array of variable transaction request outputs.\n   */\n  getVariableOutputs() {\n    return this.outputs.filter(\n      (output) => output.type === OutputType7.Variable\n    );\n  }\n  /**\n   * Set the script and its data.\n   *\n   * @param script - The abstract script request.\n   * @param data - The script data.\n   */\n  setScript(script, data) {\n    this.scriptData = script.encodeScriptData(data);\n    this.script = script.bytes;\n  }\n  /**\n   * Adds variable outputs to the transaction request.\n   *\n   * @param numberOfVariables - The number of variables to add.\n   * @returns The new length of the outputs array.\n   */\n  addVariableOutputs(numberOfVariables = 1) {\n    let outputsNumber = numberOfVariables;\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType7.Variable\n      });\n      outputsNumber -= 1;\n    }\n    return this.outputs.length - 1;\n  }\n  /**\n   * Adds a variable output to the transaction request.\n   *\n   * @param to - The recipient address as a BytesLike object. Defaults to ZeroBytes32 if not provided.\n   * @param amount - The amount to be transferred as a BigNumberish object. Defaults to 0 if not provided.\n   * @param assetId - The asset ID as a BytesLike object. Defaults to ZeroBytes32 if not provided.\n   */\n  addVariableOutput(to, amount, assetId) {\n    this.pushOutput({\n      type: OutputType7.Variable,\n      to,\n      amount,\n      assetId\n    });\n  }\n  /**\n   * Calculates the maximum gas for the transaction.\n   *\n   * @param chainInfo - The chain information.\n   * @param minGas - The minimum gas.\n   * @returns the maximum gas.\n   */\n  calculateMaxGas(chainInfo, minGas) {\n    const { consensusParameters } = chainInfo;\n    const {\n      feeParameters: { gasPerByte },\n      txParameters: { maxGasPerTx }\n    } = consensusParameters;\n    const witnessesLength = this.toTransaction().witnesses.reduce(\n      (acc, wit) => acc + wit.dataLength,\n      0\n    );\n    return getMaxGas({\n      gasPerByte,\n      minGas,\n      witnessesLength,\n      witnessLimit: this.witnessLimit,\n      gasLimit: this.gasLimit,\n      maxGasPerTx\n    });\n  }\n  /**\n   * Adds a contract input and output to the transaction request.\n   *\n   * @param contract - The contract ID.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  addContractInputAndOutput(contract) {\n    const contractAddress = addressify2(contract);\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return this;\n    }\n    const inputIndex = super.pushInput({\n      type: InputType6.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: \"0x00000000000000000000000000000000\"\n    });\n    this.pushOutput({\n      type: OutputType7.Contract,\n      inputIndex\n    });\n    return this;\n  }\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId) {\n    return hashTransaction(this, chainId);\n  }\n  /**\n   * Sets the data for the transaction request.\n   *\n   * @param abi - Script JSON ABI.\n   * @param args - The input arguments.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  setData(abi, args) {\n    const abiInterface = new Interface(abi);\n    this.scriptData = abiInterface.functions.main.encodeArguments(args);\n    return this;\n  }\n  metadataGas(gasCosts) {\n    return calculateMetadataGasForTxScript({\n      gasCosts,\n      txBytesSize: this.byteSize()\n    });\n  }\n};\n\n// src/providers/transaction-request/upgrade-transaction-request.ts\nimport { FuelError as FuelError11 } from \"@fuel-ts/errors\";\nimport { hash } from \"@fuel-ts/hasher\";\nimport {\n  TransactionType as TransactionType6,\n  UpgradePurposeTypeEnum\n} from \"@fuel-ts/transactions\";\nimport { hexlify as hexlify13 } from \"@fuel-ts/utils\";\nimport { clone as clone6 } from \"ramda\";\nvar UpgradeTransactionRequest = class _UpgradeTransactionRequest extends BaseTransactionRequest {\n  static {\n    __name(this, \"UpgradeTransactionRequest\");\n  }\n  static from(obj) {\n    if (obj instanceof _UpgradeTransactionRequest) {\n      return obj;\n    }\n    return new this(clone6(obj));\n  }\n  /** The type of transaction */\n  type = TransactionType6.Upgrade;\n  /** The upgrade purpose */\n  upgradePurpose;\n  /** Witness index of consensus */\n  bytecodeWitnessIndex;\n  /**\n   * Creates an instance `UpgradeTransactionRequest`.\n   *\n   * @param upgradeTransactionRequestLike - The initial values for the instance\n   */\n  constructor({\n    upgradePurpose,\n    bytecodeWitnessIndex,\n    ...rest\n  } = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.upgradePurpose = upgradePurpose ?? {\n      type: UpgradePurposeTypeEnum.ConsensusParameters,\n      checksum: \"0x\"\n    };\n  }\n  /**\n   * Adds a consensus parameters upgrade purpose.\n   *\n   * @param consensus - The consensus bytecode.\n   *\n   * @returns - The current instance of `UpgradeTransactionRequest`.\n   */\n  addConsensusParametersUpgradePurpose(consensus) {\n    this.bytecodeWitnessIndex = this.addWitness(consensus);\n    this.upgradePurpose = {\n      type: UpgradePurposeTypeEnum.ConsensusParameters,\n      checksum: hash(consensus)\n    };\n    return this;\n  }\n  /**\n   * Adds a state transition upgrade purpose.\n   *\n   * @param bytecodeRoot - The Merkle root of the state transition.\n   *\n   * @returns - The current instance of `UpgradeTransactionRequest`.\n   */\n  addStateTransitionUpgradePurpose(bytecodeRoot) {\n    this.upgradePurpose = {\n      type: UpgradePurposeTypeEnum.StateTransition,\n      data: hexlify13(bytecodeRoot)\n    };\n    return this;\n  }\n  /**\n   * Adds an upgrade purpose.\n   *\n   * @param type - The upgrade purpose type.\n   * @param data - The bytecode or merkle root of upgrade purpose\n   *\n   * @returns - The current instance of `UpgradeTransactionRequest`.\n   */\n  addUpgradePurpose(type, data) {\n    if (type === UpgradePurposeTypeEnum.ConsensusParameters) {\n      this.addConsensusParametersUpgradePurpose(data);\n    }\n    if (type === UpgradePurposeTypeEnum.StateTransition) {\n      this.addStateTransitionUpgradePurpose(data);\n    }\n    return this;\n  }\n  /**\n   * Converts the transaction request to a `TransactionUpgrade`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction() {\n    let upgradePurpose;\n    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {\n      upgradePurpose = {\n        type: UpgradePurposeTypeEnum.ConsensusParameters,\n        data: {\n          witnessIndex: this.bytecodeWitnessIndex,\n          checksum: this.upgradePurpose.checksum\n        }\n      };\n    } else if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {\n      upgradePurpose = {\n        type: UpgradePurposeTypeEnum.StateTransition,\n        data: {\n          bytecodeRoot: hexlify13(this.upgradePurpose.data)\n        }\n      };\n    } else {\n      throw new FuelError11(FuelError11.CODES.NOT_IMPLEMENTED, \"Invalid upgrade purpose\");\n    }\n    return {\n      type: TransactionType6.Upgrade,\n      ...super.getBaseTransaction(),\n      upgradePurpose\n    };\n  }\n  /**\n   * Gets the Transaction ID by hashing the transaction\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId) {\n    return hashTransaction(this, chainId);\n  }\n  /**\n   * Calculates the metadata gas cost for an upgrade transaction.\n   *\n   * @param gasCosts - gas costs passed from the chain.\n   *\n   * @returns metadata gas cost for the upgrade transaction.\n   */\n  metadataGas(gasCosts) {\n    const txBytesSize = this.byteSize();\n    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.ConsensusParameters) {\n      const witnessIndex = this.bytecodeWitnessIndex;\n      const consensusSize = this.witnesses[witnessIndex].length;\n      return calculateMetadataGasForTxUpgrade({\n        gasCosts,\n        txBytesSize,\n        consensusSize\n      });\n    }\n    if (this.upgradePurpose.type === UpgradePurposeTypeEnum.StateTransition) {\n      return calculateMetadataGasForTxUpgrade({\n        gasCosts,\n        txBytesSize\n      });\n    }\n    throw new FuelError11(FuelError11.CODES.NOT_IMPLEMENTED, \"Invalid upgrade purpose\");\n  }\n};\n\n// src/providers/transaction-request/upload-transaction-request.ts\nimport { ZeroBytes32 as ZeroBytes328 } from \"@fuel-ts/address/configs\";\nimport { TransactionType as TransactionType7 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify9, hexlify as hexlify14 } from \"@fuel-ts/utils\";\nimport { clone as clone7 } from \"ramda\";\nvar UploadTransactionRequest = class _UploadTransactionRequest extends BaseTransactionRequest {\n  static {\n    __name(this, \"UploadTransactionRequest\");\n  }\n  static from(obj) {\n    if (obj instanceof _UploadTransactionRequest) {\n      return obj;\n    }\n    return new this(clone7(obj));\n  }\n  /** Type of the transaction */\n  type = TransactionType7.Upload;\n  /** The witness index of the subsection of the bytecode. */\n  witnessIndex;\n  /** The subsection data. */\n  subsection;\n  /**\n   * Creates an instance `UploadTransactionRequest`.\n   *\n   * @param uploadTransactionRequestLike - The initial values for the instance\n   */\n  constructor({ witnessIndex, subsection, ...rest } = {}) {\n    super(rest);\n    this.witnessIndex = witnessIndex ?? 0;\n    this.subsection = subsection ?? {\n      proofSet: [],\n      root: ZeroBytes328,\n      subsectionIndex: 0,\n      subsectionsNumber: 0\n    };\n  }\n  /**\n   * Adds the subsection.\n   *\n   * @param subsection - The subsection data.\n   */\n  addSubsection(subsection) {\n    const { subsection: subsectionBytecode, ...rest } = subsection;\n    this.subsection = rest;\n    this.witnessIndex = this.addWitness(subsectionBytecode);\n  }\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId) {\n    return hashTransaction(this, chainId);\n  }\n  /**\n   * Converts the transaction request to a `TransactionUpload`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction() {\n    const baseTransaction = this.getBaseTransaction();\n    const { subsectionIndex, subsectionsNumber, root, proofSet } = this.subsection;\n    return {\n      type: TransactionType7.Upload,\n      ...baseTransaction,\n      subsectionIndex,\n      subsectionsNumber,\n      root: hexlify14(root),\n      proofSet: proofSet.map(hexlify14),\n      witnessIndex: this.witnessIndex,\n      proofSetCount: proofSet.length\n    };\n  }\n  /**\n   * Calculates the metadata gas cost for an upload transaction.\n   *\n   * @param gasCosts - gas costs passed from the chain.\n   *\n   * @returns metadata gas cost for the upload transaction.\n   */\n  metadataGas(gasCosts) {\n    return calculateMetadataGasForTxUpload({\n      gasCosts,\n      txBytesSize: this.byteSize(),\n      subsectionSize: arrayify9(this.witnesses[this.witnessIndex]).length,\n      subsectionsSize: this.subsection.subsectionsNumber\n    });\n  }\n  /**\n   * Calculates the minimum gas for an upload transaction.\n   *\n   * @param chainInfo - The chain information.\n   *\n   * @returns the minimum gas for the upload transaction\n   */\n  calculateMinGas(chainInfo) {\n    const minGas = super.calculateMinGas(chainInfo);\n    const { gasCosts } = chainInfo.consensusParameters;\n    const bytecode = this.witnesses[this.witnessIndex] ?? ZeroBytes328;\n    return calculateMinGasForTxUpload({\n      gasCosts,\n      baseMinGas: minGas.toNumber(),\n      subsectionSize: arrayify9(bytecode).length\n    });\n  }\n};\n\n// src/providers/transaction-request/types.ts\nvar AbstractScriptRequest = class {\n  static {\n    __name(this, \"AbstractScriptRequest\");\n  }\n};\n\n// src/providers/transaction-request/utils.ts\nimport { ErrorCode as ErrorCode10, FuelError as FuelError12 } from \"@fuel-ts/errors\";\nimport { TransactionType as TransactionType8 } from \"@fuel-ts/transactions\";\nvar transactionRequestify = /* @__PURE__ */ __name((obj) => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest || obj instanceof BlobTransactionRequest || obj instanceof UpgradeTransactionRequest || obj instanceof UploadTransactionRequest) {\n    return obj;\n  }\n  const { type } = obj;\n  switch (obj.type) {\n    case TransactionType8.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType8.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    case TransactionType8.Blob: {\n      return BlobTransactionRequest.from(obj);\n    }\n    case TransactionType8.Upgrade: {\n      return UpgradeTransactionRequest.from(obj);\n    }\n    case TransactionType8.Upload: {\n      return UploadTransactionRequest.from(obj);\n    }\n    default: {\n      throw new FuelError12(\n        ErrorCode10.UNSUPPORTED_TRANSACTION_TYPE,\n        `Unsupported transaction type: ${type}.`\n      );\n    }\n  }\n}, \"transactionRequestify\");\nvar isTransactionTypeScript = /* @__PURE__ */ __name((request2) => request2.type === TransactionType8.Script, \"isTransactionTypeScript\");\nvar isTransactionTypeCreate = /* @__PURE__ */ __name((request2) => request2.type === TransactionType8.Create, \"isTransactionTypeCreate\");\nvar isTransactionTypeBlob = /* @__PURE__ */ __name((request2) => request2.type === TransactionType8.Blob, \"isTransactionTypeBlob\");\nvar isTransactionTypeUpgrade = /* @__PURE__ */ __name((request2) => request2.type === TransactionType8.Upgrade, \"isTransactionTypeUpgrade\");\nvar isTransactionTypeUpload = /* @__PURE__ */ __name((request2) => request2.type === TransactionType8.Upload, \"isTransactionTypeUpload\");\n\n// src/providers/resource-cache.ts\nvar cache = /* @__PURE__ */ new Map();\nvar ResourceCache = class {\n  static {\n    __name(this, \"ResourceCache\");\n  }\n  ttl;\n  constructor(ttl) {\n    this.ttl = ttl;\n    if (typeof ttl !== \"number\" || this.ttl <= 0) {\n      throw new FuelError13(\n        ErrorCode11.INVALID_TTL,\n        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`\n      );\n    }\n  }\n  // Add resources to the cache\n  set(transactionId, inputs) {\n    const transactionResourceCache = this.setupResourcesCache(inputs);\n    cache.set(transactionId, transactionResourceCache);\n  }\n  unset(transactionId) {\n    cache.delete(transactionId);\n  }\n  getActiveData(owner) {\n    const activeData = { utxos: [], messages: [] };\n    const currentTime = Date.now();\n    const expired = [];\n    cache.forEach((resource, transactionId) => {\n      const isActive = currentTime - resource.timestamp < this.ttl;\n      if (isActive) {\n        const resourcesFromOwner = resource.owners.get(owner);\n        if (resourcesFromOwner) {\n          activeData.utxos.push(...resourcesFromOwner.utxos);\n          activeData.messages.push(...resourcesFromOwner.messages);\n        }\n      } else {\n        expired.push(transactionId);\n      }\n    });\n    expired.forEach(this.unset);\n    activeData.utxos.reverse();\n    activeData.messages.reverse();\n    return activeData;\n  }\n  isCached(owner, key) {\n    const currentTime = Date.now();\n    let cached = false;\n    const expired = [];\n    for (const [transactionId, resourceData] of cache.entries()) {\n      const isActive = currentTime - resourceData.timestamp < this.ttl;\n      if (isActive) {\n        const resourcesFromOwner = resourceData.owners.get(owner);\n        if (resourcesFromOwner?.utxos.has(key) || resourcesFromOwner?.messages.has(key)) {\n          cached = true;\n          break;\n        }\n      } else {\n        expired.push(transactionId);\n      }\n    }\n    expired.forEach(this.unset);\n    return cached;\n  }\n  clear() {\n    cache.clear();\n  }\n  setupResourcesCache(inputs) {\n    const currentTime = Date.now();\n    const transactionResourcesCache = {\n      owners: /* @__PURE__ */ new Map(),\n      timestamp: currentTime\n    };\n    inputs.filter(isRequestInputCoinOrMessage).forEach((input) => {\n      const { owner, key, type } = this.extractResourceData(input);\n      if (!transactionResourcesCache.owners.has(owner)) {\n        transactionResourcesCache.owners.set(owner, { utxos: /* @__PURE__ */ new Set(), messages: /* @__PURE__ */ new Set() });\n      }\n      if (type === \"utxo\") {\n        transactionResourcesCache.owners.get(owner)?.utxos.add(key);\n      } else {\n        transactionResourcesCache.owners.get(owner)?.messages.add(key);\n      }\n    });\n    return transactionResourcesCache;\n  }\n  extractResourceData(input) {\n    if (isRequestInputCoin(input)) {\n      return { owner: hexlify15(input.owner), key: hexlify15(input.id), type: \"utxo\" };\n    }\n    return { owner: hexlify15(input.recipient), key: hexlify15(input.nonce), type: \"message\" };\n  }\n};\n\n// src/providers/transaction-response/transaction-response.ts\nimport { ErrorCode as ErrorCode15, FuelError as FuelError17 } from \"@fuel-ts/errors\";\nimport { bn as bn17 } from \"@fuel-ts/math\";\nimport { TransactionCoder as TransactionCoder6, TxPointerCoder } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify12 } from \"@fuel-ts/utils\";\n\n// src/providers/transaction-summary/assemble-transaction-summary.ts\nimport { bn as bn16 } from \"@fuel-ts/math\";\nimport { PolicyType as PolicyType3, TransactionCoder as TransactionCoder5 } from \"@fuel-ts/transactions\";\nimport { DateTime, hexlify as hexlify16 } from \"@fuel-ts/utils\";\n\n// src/providers/transaction-summary/calculate-tx-fee-for-summary.ts\nimport { bn as bn13 } from \"@fuel-ts/math\";\nimport { PolicyType as PolicyType2, TransactionCoder as TransactionCoder3, TransactionType as TransactionType9 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify10 } from \"@fuel-ts/utils\";\nvar calculateTXFeeForSummary = /* @__PURE__ */ __name((params) => {\n  const {\n    gasPrice,\n    rawPayload,\n    tip,\n    consensusParameters: { gasCosts, feeParams, maxGasPerTx }\n  } = params;\n  const gasPerByte = bn13(feeParams.gasPerByte);\n  const gasPriceFactor = bn13(feeParams.gasPriceFactor);\n  const transactionBytes = arrayify10(rawPayload);\n  const [transaction] = new TransactionCoder3().decode(transactionBytes, 0);\n  const { type, witnesses, inputs, policies } = transaction;\n  let metadataGas = bn13(0);\n  let gasLimit = bn13(0);\n  if (type !== TransactionType9.Create && type !== TransactionType9.Script) {\n    return bn13(0);\n  }\n  if (type === TransactionType9.Create) {\n    const { bytecodeWitnessIndex, storageSlots } = transaction;\n    const contractBytesSize = bn13(arrayify10(witnesses[bytecodeWitnessIndex].data).length);\n    metadataGas = calculateMetadataGasForTxCreate({\n      contractBytesSize,\n      gasCosts,\n      stateRootSize: storageSlots.length || 0,\n      txBytesSize: transactionBytes.length\n    });\n  } else {\n    const { scriptGasLimit } = transaction;\n    if (scriptGasLimit) {\n      gasLimit = scriptGasLimit;\n    }\n    metadataGas = calculateMetadataGasForTxScript({\n      gasCosts,\n      txBytesSize: transactionBytes.length\n    });\n  }\n  const minGas = getMinGas({\n    gasCosts,\n    gasPerByte: bn13(gasPerByte),\n    inputs,\n    metadataGas,\n    txBytesSize: transactionBytes.length\n  });\n  const witnessLimit = policies.find((policy) => policy.type === PolicyType2.WitnessLimit)?.data;\n  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);\n  const maxGas = getMaxGas({\n    gasPerByte,\n    minGas,\n    witnessesLength,\n    gasLimit,\n    witnessLimit,\n    maxGasPerTx\n  });\n  const maxFee = calculateGasFee({\n    gasPrice,\n    gas: maxGas,\n    priceFactor: gasPriceFactor,\n    tip\n  });\n  return maxFee;\n}, \"calculateTXFeeForSummary\");\n\n// src/providers/transaction-summary/operations.ts\nimport { ZeroBytes32 as ZeroBytes329 } from \"@fuel-ts/address/configs\";\nimport { ErrorCode as ErrorCode13, FuelError as FuelError15 } from \"@fuel-ts/errors\";\nimport { bn as bn14, toBytes } from \"@fuel-ts/math\";\nimport { ReceiptType as ReceiptType5, TransactionCoder as TransactionCoder4, TransactionType as TransactionType10 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify11, concat as concat3 } from \"@fuel-ts/utils\";\n\n// src/providers/transaction-summary/call.ts\nimport { StdStringCoder } from \"@fuel-ts/abi-coder\";\nimport { Interface as Interface2 } from \"@fuel-ts/abi-coder\";\nvar getFunctionCall = /* @__PURE__ */ __name(({\n  abi,\n  receipt,\n  offset,\n  scriptData\n}) => {\n  const [functionSelector, argumentsOffset] = new StdStringCoder().decode(scriptData, offset);\n  const abiInterface = new Interface2(abi);\n  const functionFragment = abiInterface.getFunction(functionSelector);\n  const inputs = functionFragment.jsonFn.inputs;\n  let argumentsProvided;\n  if (inputs.length) {\n    const functionArgsBytes = scriptData.slice(argumentsOffset);\n    const decodedArguments = functionFragment.decodeArguments(functionArgsBytes);\n    argumentsProvided = inputs.reduce((prev, input, index) => {\n      const value = decodedArguments?.[index];\n      const name = input.name;\n      if (name) {\n        return {\n          ...prev,\n          // reparse to remove bn\n          [name]: JSON.parse(JSON.stringify(value))\n        };\n      }\n      return prev;\n    }, {});\n  }\n  return {\n    functionSignature: functionFragment.signature,\n    functionName: functionFragment.name,\n    argumentsProvided,\n    ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }\n  };\n}, \"getFunctionCall\");\n\n// src/providers/transaction-summary/input.ts\nimport { ErrorCode as ErrorCode12, FuelError as FuelError14 } from \"@fuel-ts/errors\";\nimport { BN } from \"@fuel-ts/math\";\nimport { InputType as InputType7 } from \"@fuel-ts/transactions\";\nfunction getInputsByTypes(inputs, types) {\n  return inputs.filter((i) => types.includes(i.type));\n}\n__name(getInputsByTypes, \"getInputsByTypes\");\nfunction getInputsByType(inputs, type) {\n  return inputs.filter((i) => i.type === type);\n}\n__name(getInputsByType, \"getInputsByType\");\nfunction getInputsCoin(inputs) {\n  return getInputsByType(inputs, InputType7.Coin);\n}\n__name(getInputsCoin, \"getInputsCoin\");\nfunction getInputsMessage(inputs) {\n  return getInputsByType(inputs, InputType7.Message);\n}\n__name(getInputsMessage, \"getInputsMessage\");\nfunction getInputsCoinAndMessage(inputs) {\n  return getInputsByTypes(inputs, [InputType7.Coin, InputType7.Message]);\n}\n__name(getInputsCoinAndMessage, \"getInputsCoinAndMessage\");\nfunction isInputCoin(input) {\n  return input.type === InputType7.Coin;\n}\n__name(isInputCoin, \"isInputCoin\");\nfunction getInputsContract(inputs) {\n  return getInputsByType(inputs, InputType7.Contract);\n}\n__name(getInputsContract, \"getInputsContract\");\nfunction findCoinInput(inputs, assetId) {\n  const coinInputs = getInputsCoin(inputs);\n  return coinInputs.find((i) => i.assetId === assetId);\n}\n__name(findCoinInput, \"findCoinInput\");\nfunction aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId) {\n  const aggregated = /* @__PURE__ */ new Map();\n  getInputsCoinAndMessage(inputs).forEach((input) => {\n    const assetId = isInputCoin(input) ? input.assetId : baseAssetId;\n    const owner = isInputCoin(input) ? input.owner : input.recipient;\n    let ownersMap = aggregated.get(assetId);\n    if (!ownersMap) {\n      ownersMap = /* @__PURE__ */ new Map();\n      aggregated.set(assetId, ownersMap);\n    }\n    let ownerBalance = ownersMap.get(owner);\n    if (!ownerBalance) {\n      ownerBalance = new BN(0);\n      ownersMap.set(owner, ownerBalance);\n    }\n    ownersMap.set(owner, ownerBalance.add(input.amount));\n  });\n  return aggregated;\n}\n__name(aggregateInputsAmountsByAssetAndOwner, \"aggregateInputsAmountsByAssetAndOwner\");\nfunction findMessageInput(inputs) {\n  return getInputsMessage(inputs)?.[0];\n}\n__name(findMessageInput, \"findMessageInput\");\nfunction getInputFromAssetId(inputs, assetId, isBaseAsset = false) {\n  const coinInput = findCoinInput(inputs, assetId);\n  if (coinInput) {\n    return coinInput;\n  }\n  if (isBaseAsset) {\n    return findMessageInput(inputs);\n  }\n  return void 0;\n}\n__name(getInputFromAssetId, \"getInputFromAssetId\");\nfunction getInputContractFromIndex(inputs, inputIndex) {\n  if (inputIndex == null) {\n    return void 0;\n  }\n  const contractInput = inputs?.[inputIndex];\n  if (!contractInput) {\n    return void 0;\n  }\n  if (contractInput.type !== InputType7.Contract) {\n    throw new FuelError14(\n      ErrorCode12.INVALID_TRANSACTION_INPUT,\n      `Contract input should be of type 'contract'.`\n    );\n  }\n  return contractInput;\n}\n__name(getInputContractFromIndex, \"getInputContractFromIndex\");\nfunction getInputAccountAddress(input) {\n  if (input.type === InputType7.Coin) {\n    return input.owner.toString();\n  }\n  if (input.type === InputType7.Message) {\n    return input.recipient.toString();\n  }\n  return \"\";\n}\n__name(getInputAccountAddress, \"getInputAccountAddress\");\n\n// src/providers/transaction-summary/output.ts\nimport { OutputType as OutputType8 } from \"@fuel-ts/transactions\";\nfunction getOutputsByType(outputs, type) {\n  return outputs.filter((o) => o.type === type);\n}\n__name(getOutputsByType, \"getOutputsByType\");\nfunction getOutputsContractCreated(outputs) {\n  return getOutputsByType(outputs, OutputType8.ContractCreated);\n}\n__name(getOutputsContractCreated, \"getOutputsContractCreated\");\nfunction getOutputsCoin(outputs) {\n  return getOutputsByType(outputs, OutputType8.Coin);\n}\n__name(getOutputsCoin, \"getOutputsCoin\");\nfunction getOutputsChange(outputs) {\n  return getOutputsByType(outputs, OutputType8.Change);\n}\n__name(getOutputsChange, \"getOutputsChange\");\nfunction getOutputsContract(outputs) {\n  return getOutputsByType(outputs, OutputType8.Contract);\n}\n__name(getOutputsContract, \"getOutputsContract\");\nfunction getOutputsVariable(outputs) {\n  return getOutputsByType(outputs, OutputType8.Variable);\n}\n__name(getOutputsVariable, \"getOutputsVariable\");\n\n// src/providers/transaction-summary/types.ts\nvar TransactionTypeName = /* @__PURE__ */ ((TransactionTypeName2) => {\n  TransactionTypeName2[\"Create\"] = \"Create\";\n  TransactionTypeName2[\"Mint\"] = \"Mint\";\n  TransactionTypeName2[\"Script\"] = \"Script\";\n  TransactionTypeName2[\"Upgrade\"] = \"Upgrade\";\n  TransactionTypeName2[\"Upload\"] = \"Upload\";\n  TransactionTypeName2[\"Blob\"] = \"Blob\";\n  return TransactionTypeName2;\n})(TransactionTypeName || {});\nvar TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {\n  TransactionStatus2[\"submitted\"] = \"submitted\";\n  TransactionStatus2[\"success\"] = \"success\";\n  TransactionStatus2[\"squeezedout\"] = \"squeezedout\";\n  TransactionStatus2[\"failure\"] = \"failure\";\n  TransactionStatus2[\"preconfirmationSuccess\"] = \"preconfirmationSuccess\";\n  TransactionStatus2[\"preconfirmationFailure\"] = \"preconfirmationFailure\";\n  return TransactionStatus2;\n})(TransactionStatus || {});\nvar OperationName = /* @__PURE__ */ ((OperationName2) => {\n  OperationName2[\"payBlockProducer\"] = \"Pay network fee to block producer\";\n  OperationName2[\"contractCreated\"] = \"Contract created\";\n  OperationName2[\"transfer\"] = \"Transfer asset\";\n  OperationName2[\"contractCall\"] = \"Contract call\";\n  OperationName2[\"receive\"] = \"Receive asset\";\n  OperationName2[\"withdrawFromFuel\"] = \"Withdraw from Fuel\";\n  return OperationName2;\n})(OperationName || {});\nvar AddressType = /* @__PURE__ */ ((AddressType2) => {\n  AddressType2[AddressType2[\"contract\"] = 0] = \"contract\";\n  AddressType2[AddressType2[\"account\"] = 1] = \"account\";\n  return AddressType2;\n})(AddressType || {});\nvar ChainName = /* @__PURE__ */ ((ChainName2) => {\n  ChainName2[\"ethereum\"] = \"ethereum\";\n  ChainName2[\"fuel\"] = \"fuel\";\n  return ChainName2;\n})(ChainName || {});\n\n// src/providers/transaction-summary/operations.ts\nfunction getReceiptsByType(receipts, type) {\n  return (receipts ?? []).filter((r) => r.type === type);\n}\n__name(getReceiptsByType, \"getReceiptsByType\");\nfunction getTransactionTypeName(transactionType) {\n  switch (transactionType) {\n    case TransactionType10.Mint:\n      return \"Mint\" /* Mint */;\n    case TransactionType10.Create:\n      return \"Create\" /* Create */;\n    case TransactionType10.Script:\n      return \"Script\" /* Script */;\n    case TransactionType10.Blob:\n      return \"Blob\" /* Blob */;\n    case TransactionType10.Upgrade:\n      return \"Upgrade\" /* Upgrade */;\n    case TransactionType10.Upload:\n      return \"Upload\" /* Upload */;\n    default:\n      throw new FuelError15(\n        ErrorCode13.UNSUPPORTED_TRANSACTION_TYPE,\n        `Unsupported transaction type: ${transactionType}.`\n      );\n  }\n}\n__name(getTransactionTypeName, \"getTransactionTypeName\");\nfunction isType(transactionType, type) {\n  const txType = getTransactionTypeName(transactionType);\n  return txType === type;\n}\n__name(isType, \"isType\");\nfunction isTypeMint(transactionType) {\n  return isType(transactionType, \"Mint\" /* Mint */);\n}\n__name(isTypeMint, \"isTypeMint\");\nfunction isTypeCreate(transactionType) {\n  return isType(transactionType, \"Create\" /* Create */);\n}\n__name(isTypeCreate, \"isTypeCreate\");\nfunction isTypeScript(transactionType) {\n  return isType(transactionType, \"Script\" /* Script */);\n}\n__name(isTypeScript, \"isTypeScript\");\nfunction isTypeUpgrade(transactionType) {\n  return isType(transactionType, \"Upgrade\" /* Upgrade */);\n}\n__name(isTypeUpgrade, \"isTypeUpgrade\");\nfunction isTypeUpload(transactionType) {\n  return isType(transactionType, \"Upload\" /* Upload */);\n}\n__name(isTypeUpload, \"isTypeUpload\");\nfunction isTypeBlob(transactionType) {\n  return isType(transactionType, \"Blob\" /* Blob */);\n}\n__name(isTypeBlob, \"isTypeBlob\");\nfunction hasSameAssetId(a) {\n  return (b) => a.assetId === b.assetId;\n}\n__name(hasSameAssetId, \"hasSameAssetId\");\nfunction getReceiptsCall(receipts) {\n  return getReceiptsByType(receipts, ReceiptType5.Call);\n}\n__name(getReceiptsCall, \"getReceiptsCall\");\nfunction getReceiptsMessageOut(receipts) {\n  return getReceiptsByType(receipts, ReceiptType5.MessageOut);\n}\n__name(getReceiptsMessageOut, \"getReceiptsMessageOut\");\nfunction mergeAssets(op1, op2) {\n  const assets1 = op1.assetsSent || [];\n  const assets2 = op2.assetsSent || [];\n  const assetMap = /* @__PURE__ */ new Map();\n  assets1.forEach((asset) => {\n    assetMap.set(asset.assetId, { ...asset });\n  });\n  assets2.forEach((asset) => {\n    const existingAsset = assetMap.get(asset.assetId);\n    if (existingAsset) {\n      existingAsset.amount = bn14(existingAsset.amount).add(asset.amount);\n    } else {\n      assetMap.set(asset.assetId, { ...asset });\n    }\n  });\n  return Array.from(assetMap.values());\n}\n__name(mergeAssets, \"mergeAssets\");\nfunction isSameOperation(a, b) {\n  return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;\n}\n__name(isSameOperation, \"isSameOperation\");\nfunction mergeAssetsSent(existing, toAdd) {\n  if (!toAdd.assetsSent?.length) {\n    return existing.assetsSent;\n  }\n  return existing.assetsSent?.length ? mergeAssets(existing, toAdd) : toAdd.assetsSent;\n}\n__name(mergeAssetsSent, \"mergeAssetsSent\");\nfunction mergeCalls(existing, toAdd) {\n  if (!toAdd.calls?.length) {\n    return existing.calls;\n  }\n  return [...existing.calls || [], ...toAdd.calls];\n}\n__name(mergeCalls, \"mergeCalls\");\nfunction mergeOperations(existing, toAdd) {\n  return {\n    ...existing,\n    assetsSent: mergeAssetsSent(existing, toAdd),\n    calls: mergeCalls(existing, toAdd),\n    receipts: [\n      ...existing.receipts || [],\n      ...toAdd.receipts?.filter((r) => !existing.receipts?.some((er) => er === r)) || []\n    ]\n  };\n}\n__name(mergeOperations, \"mergeOperations\");\nfunction addOperation(operations, toAdd) {\n  const existingIndex = operations.findIndex((op) => isSameOperation(op, toAdd));\n  if (existingIndex === -1) {\n    return [...operations, toAdd];\n  }\n  return operations.map((op, index) => index === existingIndex ? mergeOperations(op, toAdd) : op);\n}\n__name(addOperation, \"addOperation\");\nfunction getReceiptsTransferOut(receipts) {\n  return getReceiptsByType(receipts, ReceiptType5.TransferOut);\n}\n__name(getReceiptsTransferOut, \"getReceiptsTransferOut\");\nfunction getWithdrawFromFuelOperations({\n  inputs,\n  receipts,\n  baseAssetId\n}) {\n  const messageOutReceipts = getReceiptsMessageOut(receipts);\n  const withdrawFromFuelOperations = messageOutReceipts.reduce(\n    (prevWithdrawFromFuelOps, receipt) => {\n      const input = getInputFromAssetId(inputs, baseAssetId, true);\n      if (input) {\n        const inputAddress = getInputAccountAddress(input);\n        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {\n          name: \"Withdraw from Fuel\" /* withdrawFromFuel */,\n          from: {\n            type: 1 /* account */,\n            address: inputAddress\n          },\n          to: {\n            type: 1 /* account */,\n            address: receipt.recipient.toString(),\n            chain: \"ethereum\" /* ethereum */\n          },\n          assetsSent: [\n            {\n              amount: receipt.amount,\n              assetId: baseAssetId\n            }\n          ],\n          receipts: [receipt]\n        });\n        return newWithdrawFromFuelOps;\n      }\n      return prevWithdrawFromFuelOps;\n    },\n    []\n  );\n  return withdrawFromFuelOperations;\n}\n__name(getWithdrawFromFuelOperations, \"getWithdrawFromFuelOperations\");\nfunction findBytesSegmentIndex(whole, segment) {\n  for (let i = 0; i <= whole.length - segment.length; i++) {\n    let match = true;\n    for (let j = 0; j < segment.length; j++) {\n      if (whole[i + j] !== segment[j]) {\n        match = false;\n        break;\n      }\n    }\n    if (match) {\n      return i;\n    }\n  }\n  return -1;\n}\n__name(findBytesSegmentIndex, \"findBytesSegmentIndex\");\nfunction getContractCalls(contractInput, abiMap, receipt, scriptData) {\n  const calls = [];\n  const abi = abiMap?.[contractInput.contractID];\n  if (!abi || !scriptData) {\n    return calls;\n  }\n  const bytesSegment = concat3([\n    arrayify11(receipt.to),\n    // Contract ID (32 bytes)\n    toBytes(receipt.param1.toHex(), 8),\n    // Function selector offset (8 bytes)\n    toBytes(receipt.param2.toHex(), 8)\n    // Function args offset (8 bytes)\n  ]);\n  const segmentIndex = findBytesSegmentIndex(scriptData, bytesSegment);\n  const canDecodeFunctionCall = segmentIndex !== -1;\n  if (!canDecodeFunctionCall) {\n    return calls;\n  }\n  const offset = segmentIndex + bytesSegment.length;\n  const call = getFunctionCall({ abi, receipt, offset, scriptData });\n  calls.push(call);\n  return calls;\n}\n__name(getContractCalls, \"getContractCalls\");\nfunction getAssetsSent(receipt) {\n  return receipt.amount?.isZero() ? void 0 : [\n    {\n      amount: receipt.amount,\n      assetId: receipt.assetId\n    }\n  ];\n}\n__name(getAssetsSent, \"getAssetsSent\");\nfunction processCallReceipt(receipt, contractInput, inputs, abiMap, scriptData, baseAssetId) {\n  const assetId = receipt.assetId === ZeroBytes329 ? baseAssetId : receipt.assetId;\n  const input = getInputFromAssetId(inputs, assetId, assetId === baseAssetId);\n  if (!input) {\n    return [];\n  }\n  const inputAddress = getInputAccountAddress(input);\n  const calls = getContractCalls(contractInput, abiMap, receipt, scriptData);\n  return [\n    {\n      name: \"Contract call\" /* contractCall */,\n      from: {\n        type: 1 /* account */,\n        address: inputAddress\n      },\n      to: {\n        type: 0 /* contract */,\n        address: receipt.to\n      },\n      assetsSent: getAssetsSent(receipt),\n      calls,\n      receipts: [receipt]\n    }\n  ];\n}\n__name(processCallReceipt, \"processCallReceipt\");\nfunction getContractCallOperations({\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n  baseAssetId\n}) {\n  const contractCallReceipts = getReceiptsCall(receipts);\n  const contractOutputs = getOutputsContract(outputs);\n  return contractOutputs.flatMap((output) => {\n    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);\n    if (!contractInput) {\n      return [];\n    }\n    let scriptData;\n    if (rawPayload) {\n      const [transaction] = new TransactionCoder4().decode(arrayify11(rawPayload), 0);\n      if (transaction.type === TransactionType10.Script) {\n        scriptData = arrayify11(transaction.scriptData);\n      }\n    }\n    return contractCallReceipts.filter((receipt) => receipt.to === contractInput.contractID).flatMap(\n      (receipt) => processCallReceipt(receipt, contractInput, inputs, abiMap, scriptData, baseAssetId)\n    );\n  });\n}\n__name(getContractCallOperations, \"getContractCallOperations\");\nfunction extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs) {\n  const { to: toAddress, assetId, amount } = receipt;\n  let { id: fromAddress } = receipt;\n  const toType = contractInputs.some((input) => input.contractID === toAddress) ? 0 /* contract */ : 1 /* account */;\n  if (ZeroBytes329 === fromAddress) {\n    const change = changeOutputs.find((output) => output.assetId === assetId);\n    fromAddress = change?.to || fromAddress;\n  }\n  const fromType = contractInputs.some((input) => input.contractID === fromAddress) ? 0 /* contract */ : 1 /* account */;\n  return {\n    name: \"Transfer asset\" /* transfer */,\n    from: {\n      type: fromType,\n      address: fromAddress\n    },\n    to: {\n      type: toType,\n      address: toAddress\n    },\n    assetsSent: [\n      {\n        assetId: assetId.toString(),\n        amount\n      }\n    ],\n    receipts: [receipt]\n  };\n}\n__name(extractTransferOperationFromReceipt, \"extractTransferOperationFromReceipt\");\nfunction getTransferOperations({\n  inputs,\n  outputs,\n  receipts,\n  baseAssetId\n}) {\n  let operations = [];\n  const coinOutputs = getOutputsCoin(outputs);\n  const contractInputs = getInputsContract(inputs);\n  const changeOutputs = getOutputsChange(outputs);\n  const aggregated = aggregateInputsAmountsByAssetAndOwner(inputs, baseAssetId);\n  coinOutputs.forEach(({ amount, assetId, to }) => {\n    const txPayers = aggregated.get(assetId) || /* @__PURE__ */ new Map();\n    let selectedPayer;\n    let fallbackPayer;\n    for (const [address, payedAmount] of txPayers) {\n      if (!fallbackPayer) {\n        fallbackPayer = address;\n      }\n      if (payedAmount.gte(amount)) {\n        selectedPayer = address;\n        break;\n      }\n    }\n    selectedPayer = selectedPayer || fallbackPayer;\n    if (selectedPayer) {\n      operations = addOperation(operations, {\n        name: \"Transfer asset\" /* transfer */,\n        from: {\n          type: 1 /* account */,\n          address: selectedPayer\n        },\n        to: {\n          type: 1 /* account */,\n          address: to\n        },\n        assetsSent: [{ assetId, amount }]\n      });\n    }\n  });\n  const transferReceipts = getReceiptsByType(\n    receipts,\n    ReceiptType5.Transfer\n  );\n  const transferOutReceipts = getReceiptsByType(\n    receipts,\n    ReceiptType5.TransferOut\n  );\n  [...transferReceipts, ...transferOutReceipts].forEach((receipt) => {\n    const operation = extractTransferOperationFromReceipt(receipt, contractInputs, changeOutputs);\n    operations = addOperation(operations, operation);\n  });\n  return operations;\n}\n__name(getTransferOperations, \"getTransferOperations\");\nfunction getPayProducerOperations(outputs) {\n  const coinOutputs = getOutputsCoin(outputs);\n  const payProducerOperations = coinOutputs.reduce((prev, output) => {\n    const operations = addOperation(prev, {\n      name: \"Pay network fee to block producer\" /* payBlockProducer */,\n      from: {\n        type: 1 /* account */,\n        address: \"Network\"\n      },\n      to: {\n        type: 1 /* account */,\n        address: output.to.toString()\n      },\n      assetsSent: [\n        {\n          assetId: output.assetId.toString(),\n          amount: output.amount\n        }\n      ]\n    });\n    return operations;\n  }, []);\n  return payProducerOperations;\n}\n__name(getPayProducerOperations, \"getPayProducerOperations\");\nfunction getContractCreatedOperations({ inputs, outputs }) {\n  const contractCreatedOutputs = getOutputsContractCreated(outputs);\n  const input = getInputsCoinAndMessage(inputs)[0];\n  const fromAddress = getInputAccountAddress(input);\n  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {\n    const operations = addOperation(prev, {\n      name: \"Contract created\" /* contractCreated */,\n      from: {\n        type: 1 /* account */,\n        address: fromAddress\n      },\n      to: {\n        type: 0 /* contract */,\n        address: contractCreatedOutput?.contractId || \"\"\n      }\n    });\n    return operations;\n  }, []);\n  return contractCreatedOperations;\n}\n__name(getContractCreatedOperations, \"getContractCreatedOperations\");\nfunction getOperations({\n  transactionType,\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n  maxInputs,\n  baseAssetId\n}) {\n  if (isTypeCreate(transactionType)) {\n    return [...getContractCreatedOperations({ inputs, outputs })];\n  }\n  if (isTypeScript(transactionType)) {\n    return [\n      ...getTransferOperations({ inputs, outputs, receipts, baseAssetId }),\n      ...getContractCallOperations({\n        inputs,\n        outputs,\n        receipts,\n        abiMap,\n        rawPayload,\n        maxInputs,\n        baseAssetId\n      }),\n      ...getWithdrawFromFuelOperations({ inputs, receipts, baseAssetId })\n    ];\n  }\n  return [...getPayProducerOperations(outputs)];\n}\n__name(getOperations, \"getOperations\");\n\n// src/providers/transaction-summary/receipt.ts\nimport { ReceiptType as ReceiptType6 } from \"@fuel-ts/transactions\";\nvar processGqlReceipt = /* @__PURE__ */ __name((gqlReceipt) => deserializeReceipt(gqlReceipt), \"processGqlReceipt\");\nvar extractMintedAssetsFromReceipts = /* @__PURE__ */ __name((receipts) => {\n  const mintedAssets = [];\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType6.Mint) {\n      mintedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val\n      });\n    }\n  });\n  return mintedAssets;\n}, \"extractMintedAssetsFromReceipts\");\nvar extractBurnedAssetsFromReceipts = /* @__PURE__ */ __name((receipts) => {\n  const burnedAssets = [];\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType6.Burn) {\n      burnedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val\n      });\n    }\n  });\n  return burnedAssets;\n}, \"extractBurnedAssetsFromReceipts\");\n\n// src/providers/transaction-summary/status.ts\nimport { ErrorCode as ErrorCode14, FuelError as FuelError16 } from \"@fuel-ts/errors\";\nimport { bn as bn15 } from \"@fuel-ts/math\";\nvar getTransactionStatusName = /* @__PURE__ */ __name((gqlStatus) => {\n  switch (gqlStatus) {\n    case \"FailureStatus\":\n      return \"failure\" /* failure */;\n    case \"SuccessStatus\":\n      return \"success\" /* success */;\n    case \"SubmittedStatus\":\n      return \"submitted\" /* submitted */;\n    case \"SqueezedOutStatus\":\n      return \"squeezedout\" /* squeezedout */;\n    case \"PreconfirmationSuccessStatus\":\n      return \"preconfirmationSuccess\" /* preconfirmationSuccess */;\n    case \"PreconfirmationFailureStatus\":\n      return \"preconfirmationFailure\" /* preconfirmationFailure */;\n    default:\n      throw new FuelError16(\n        ErrorCode14.INVALID_TRANSACTION_STATUS,\n        `Invalid transaction status: ${gqlStatus}.`\n      );\n  }\n}, \"getTransactionStatusName\");\nvar extractResolvedOutputs = /* @__PURE__ */ __name((serializedOutputs) => {\n  const resolvedOutputs = [];\n  serializedOutputs?.forEach(\n    ({ utxoId, output }) => resolvedOutputs.push({\n      utxoId,\n      output: deserializeProcessedTxOutput(output)\n    })\n  );\n  return resolvedOutputs;\n}, \"extractResolvedOutputs\");\nvar processGraphqlStatus = /* @__PURE__ */ __name((gqlTransactionStatus) => {\n  let time;\n  let blockId;\n  let status;\n  let totalFee;\n  let totalGas;\n  let receipts;\n  let resolvedOutputs = [];\n  let errorReason;\n  let isStatusFailure = false;\n  let isStatusSuccess = false;\n  let isStatusPending = false;\n  let isStatusPreConfirmationSuccess = false;\n  let isStatusPreConfirmationFailure = false;\n  if (gqlTransactionStatus?.type) {\n    status = getTransactionStatusName(gqlTransactionStatus.type);\n    switch (gqlTransactionStatus.type) {\n      case \"SuccessStatus\":\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block?.id;\n        isStatusSuccess = true;\n        receipts = gqlTransactionStatus.receipts?.map(deserializeReceipt);\n        totalFee = bn15(gqlTransactionStatus.totalFee);\n        totalGas = bn15(gqlTransactionStatus.totalGas);\n        break;\n      case \"FailureStatus\":\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block?.id;\n        isStatusFailure = true;\n        totalFee = bn15(gqlTransactionStatus.totalFee);\n        receipts = gqlTransactionStatus.receipts?.map(deserializeReceipt);\n        totalGas = bn15(gqlTransactionStatus.totalGas);\n        break;\n      case \"SubmittedStatus\":\n        time = gqlTransactionStatus.time;\n        isStatusPending = true;\n        break;\n      case \"PreconfirmationSuccessStatus\":\n        isStatusPreConfirmationSuccess = true;\n        totalFee = bn15(gqlTransactionStatus.totalFee);\n        totalGas = bn15(gqlTransactionStatus.totalGas);\n        receipts = gqlTransactionStatus.preconfirmationReceipts?.map(deserializeReceipt);\n        resolvedOutputs = extractResolvedOutputs(gqlTransactionStatus.resolvedOutputs);\n        break;\n      case \"PreconfirmationFailureStatus\":\n        isStatusPreConfirmationFailure = true;\n        totalFee = bn15(gqlTransactionStatus.totalFee);\n        totalGas = bn15(gqlTransactionStatus.totalGas);\n        receipts = gqlTransactionStatus.preconfirmationReceipts?.map(deserializeReceipt);\n        resolvedOutputs = extractResolvedOutputs(gqlTransactionStatus.resolvedOutputs);\n        errorReason = gqlTransactionStatus.reason;\n        break;\n      default:\n    }\n  }\n  const processedGraphqlStatus = {\n    time,\n    blockId,\n    status,\n    totalFee,\n    totalGas,\n    receipts,\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    isStatusPreConfirmationSuccess,\n    isStatusPreConfirmationFailure,\n    resolvedOutputs,\n    errorReason\n  };\n  return processedGraphqlStatus;\n}, \"processGraphqlStatus\");\nvar getTotalFeeFromStatus = /* @__PURE__ */ __name((status) => status && \"totalFee\" in status ? bn15(status.totalFee) : void 0, \"getTotalFeeFromStatus\");\n\n// src/providers/transaction-summary/assemble-transaction-summary.ts\nfunction assembleTransactionSummary(params) {\n  const {\n    id,\n    receipts,\n    gasPerByte,\n    gasPriceFactor,\n    transaction,\n    transactionBytes,\n    gqlTransactionStatus,\n    abiMap = {},\n    maxInputs,\n    gasCosts,\n    maxGasPerTx,\n    gasPrice,\n    baseAssetId\n  } = params;\n  const gasUsed = getGasUsedFromReceipts(receipts);\n  const rawPayload = hexlify16(transactionBytes);\n  const operations = getOperations({\n    transactionType: transaction.type,\n    inputs: transaction.inputs || [],\n    outputs: transaction.outputs || [],\n    receipts,\n    rawPayload,\n    abiMap,\n    maxInputs,\n    baseAssetId\n  });\n  const typeName = getTransactionTypeName(transaction.type);\n  const tip = bn16(transaction.policies?.find((policy) => policy.type === PolicyType3.Tip)?.data);\n  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time, totalFee } = processGraphqlStatus(gqlTransactionStatus);\n  const fee = totalFee ?? calculateTXFeeForSummary({\n    gasPrice,\n    rawPayload,\n    tip,\n    consensusParameters: {\n      gasCosts,\n      maxGasPerTx,\n      feeParams: {\n        gasPerByte,\n        gasPriceFactor\n      }\n    }\n  });\n  const mintedAssets = extractMintedAssetsFromReceipts(receipts);\n  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);\n  let date;\n  if (time) {\n    date = DateTime.fromTai64(time);\n  }\n  const transactionSummary = {\n    id,\n    tip,\n    fee,\n    gasUsed,\n    operations,\n    type: typeName,\n    blockId,\n    time,\n    status,\n    receipts,\n    mintedAssets,\n    burnedAssets,\n    isTypeMint: isTypeMint(transaction.type),\n    isTypeCreate: isTypeCreate(transaction.type),\n    isTypeScript: isTypeScript(transaction.type),\n    isTypeUpgrade: isTypeUpgrade(transaction.type),\n    isTypeUpload: isTypeUpload(transaction.type),\n    isTypeBlob: isTypeBlob(transaction.type),\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    date,\n    transaction\n  };\n  return transactionSummary;\n}\n__name(assembleTransactionSummary, \"assembleTransactionSummary\");\nfunction assemblePreConfirmationTransactionSummary(params) {\n  const { id, gqlTransactionStatus, transactionRequest, baseAssetId, maxInputs, abiMap } = params;\n  let type;\n  let operations;\n  let gasUsed;\n  let tip;\n  let transaction;\n  let mintedAssets;\n  let burnedAssets;\n  const {\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    status,\n    receipts,\n    resolvedOutputs,\n    errorReason,\n    totalFee,\n    isStatusPreConfirmationFailure,\n    isStatusPreConfirmationSuccess\n  } = processGraphqlStatus(gqlTransactionStatus);\n  if (receipts) {\n    gasUsed = getGasUsedFromReceipts(receipts);\n    mintedAssets = extractMintedAssetsFromReceipts(receipts);\n    burnedAssets = extractBurnedAssetsFromReceipts(receipts);\n  }\n  if (transactionRequest) {\n    transaction = transactionRequest.toTransaction();\n    type = getTransactionTypeName(transaction.type);\n    tip = bn16(transaction.policies?.find((policy) => policy.type === PolicyType3.Tip)?.data);\n    if (receipts) {\n      const rawPayload = hexlify16(new TransactionCoder5().encode(transaction));\n      operations = getOperations({\n        transactionType: transaction.type,\n        inputs: transaction.inputs || [],\n        outputs: transaction.outputs || [],\n        receipts,\n        rawPayload,\n        abiMap,\n        maxInputs,\n        baseAssetId\n      });\n    }\n  }\n  const transactionSummary = {\n    id,\n    fee: totalFee,\n    type,\n    status,\n    receipts,\n    gasUsed,\n    tip,\n    isStatusPreConfirmationFailure,\n    isStatusPreConfirmationSuccess,\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    ...transaction && {\n      isTypeMint: isTypeMint(transaction.type),\n      isTypeCreate: isTypeCreate(transaction.type),\n      isTypeScript: isTypeScript(transaction.type),\n      isTypeUpgrade: isTypeUpgrade(transaction.type),\n      isTypeUpload: isTypeUpload(transaction.type),\n      isTypeBlob: isTypeBlob(transaction.type)\n    },\n    mintedAssets,\n    burnedAssets,\n    resolvedOutputs,\n    errorReason,\n    transaction,\n    operations\n  };\n  return transactionSummary;\n}\n__name(assemblePreConfirmationTransactionSummary, \"assemblePreConfirmationTransactionSummary\");\n\n// src/providers/transaction-response/getAllDecodedLogs.ts\nimport { Interface as Interface3, BigNumberCoder } from \"@fuel-ts/abi-coder\";\nimport { ZeroBytes32 as ZeroBytes3210 } from \"@fuel-ts/address/configs\";\nimport { ReceiptType as ReceiptType7 } from \"@fuel-ts/transactions\";\nfunction getAllDecodedLogs(opts) {\n  const { receipts, mainAbi, externalAbis = {} } = opts;\n  let mainContract = \"\";\n  if (mainAbi.programType === \"contract\") {\n    const firstCallReceipt = receipts.find(\n      (r) => r.type === ReceiptType7.Call && r.id === ZeroBytes3210\n    );\n    if (firstCallReceipt) {\n      mainContract = firstCallReceipt.to;\n    }\n  }\n  return receipts.reduce(\n    ({ logs, groupedLogs }, receipt) => {\n      if (receipt.type === ReceiptType7.LogData || receipt.type === ReceiptType7.Log) {\n        const isLogFromMainAbi = receipt.id === ZeroBytes3210 || mainContract === receipt.id;\n        const isDecodable = isLogFromMainAbi || externalAbis[receipt.id];\n        if (isDecodable) {\n          const interfaceToUse = isLogFromMainAbi ? new Interface3(mainAbi) : new Interface3(externalAbis[receipt.id]);\n          const data = receipt.type === ReceiptType7.Log ? new BigNumberCoder(\"u64\").encode(receipt.ra) : receipt.data;\n          const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());\n          logs.push(decodedLog);\n          groupedLogs[receipt.id] = [...groupedLogs[receipt.id] || [], decodedLog];\n        }\n      }\n      return { logs, groupedLogs };\n    },\n    { logs: [], groupedLogs: {} }\n  );\n}\n__name(getAllDecodedLogs, \"getAllDecodedLogs\");\n\n// src/providers/transaction-response/transaction-response.ts\nvar TransactionResponse = class _TransactionResponse {\n  static {\n    __name(this, \"TransactionResponse\");\n  }\n  /** Transaction ID */\n  id;\n  /** Current provider */\n  provider;\n  /** Gas used on the transaction */\n  gasUsed = bn17(0);\n  /** The graphql Transaction with receipts object. */\n  gqlTransaction;\n  request;\n  status;\n  abis;\n  submitTxSubscription;\n  preConfirmationStatus;\n  waitingForStreamData = false;\n  statusResolvers = /* @__PURE__ */ new Map();\n  /**\n   * Constructor for `TransactionResponse`.\n   */\n  constructor(constructorParams, provider, chainId, abis, submitTxSubscription) {\n    let tx;\n    let _provider;\n    let _chainId;\n    let _abis;\n    if (typeof constructorParams === \"object\" && \"provider\" in constructorParams && arguments.length === 1) {\n      tx = constructorParams.transactionRequestOrId;\n      _provider = constructorParams.provider;\n      _chainId = constructorParams.chainId;\n      _abis = constructorParams.abis;\n      this.submitTxSubscription = constructorParams.submitAndAwaitSubscription;\n    } else {\n      tx = constructorParams;\n      _provider = provider;\n      _chainId = chainId;\n      _abis = abis;\n      this.submitTxSubscription = submitTxSubscription;\n    }\n    if (typeof tx === \"string\") {\n      this.id = tx;\n    } else {\n      this.id = tx.getTransactionId(_chainId);\n      this.request = tx;\n    }\n    this.provider = _provider;\n    this.abis = _abis;\n    this.waitForResult = this.waitForResult.bind(this);\n    this.waitForPreConfirmation = this.waitForPreConfirmation.bind(this);\n  }\n  /**\n   * Async constructor for `TransactionResponse`. This method can be used to create\n   * an instance of `TransactionResponse` and wait for the transaction to be fetched\n   * from the chain, ensuring that the `gqlTransaction` property is set.\n   *\n   * @param id - The transaction ID.\n   * @param provider - The provider.\n   */\n  static async create(id, provider, abis) {\n    const chainId = await provider.getChainId();\n    const response = new _TransactionResponse(id, provider, chainId, abis);\n    await response.fetch();\n    return response;\n  }\n  applyMalleableSubscriptionFields(transaction) {\n    const status = this.status;\n    if (!status) {\n      return;\n    }\n    const tx = transaction;\n    if (status.type === \"SuccessStatus\" || status.type === \"FailureStatus\") {\n      tx.inputs = tx.inputs.map((input, idx) => {\n        if (\"txPointer\" in input) {\n          const correspondingInput = status.transaction.inputs?.[idx];\n          return {\n            ...input,\n            txPointer: TxPointerCoder.decodeFromGqlScalar(correspondingInput.txPointer)\n          };\n        }\n        return input;\n      });\n      tx.outputs = status.transaction.outputs.map(deserializeProcessedTxOutput);\n      if (status.transaction.receiptsRoot) {\n        tx.receiptsRoot = status.transaction.receiptsRoot;\n      }\n    }\n  }\n  async getTransaction() {\n    if (this.request) {\n      const tx2 = this.request.toTransaction();\n      this.applyMalleableSubscriptionFields(tx2);\n      return {\n        tx: tx2,\n        bytes: this.request.toTransactionBytes()\n      };\n    }\n    const gqlTransaction = this.gqlTransaction ?? await this.fetch();\n    const { rawPayload } = gqlTransaction;\n    const bytes = arrayify12(rawPayload);\n    const [tx] = new TransactionCoder6().decode(bytes, 0);\n    return {\n      tx,\n      bytes\n    };\n  }\n  /**\n   *\n   * NOTE: This method is only called within `getTransactionSummary`, which is invoked after `getTransaction`.\n   * Since `getTransaction` only resolves once the transaction has been processed,\n   * the status at this point is guaranteed to be either `SuccessStatus` or `FailureStatus`.\n   */\n  getReceipts() {\n    const status = this.getTransactionStatus();\n    switch (status?.type) {\n      case \"SuccessStatus\":\n      case \"FailureStatus\":\n        return status.receipts.map(deserializeReceipt);\n      default:\n        return [];\n    }\n  }\n  /**\n   * Fetch the transaction with receipts from the provider.\n   *\n   * @returns Transaction with receipts query result.\n   */\n  async fetch() {\n    const response = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id\n    });\n    if (!response.transaction) {\n      const subscription = await this.provider.operations.statusChange({\n        transactionId: this.id\n      });\n      for await (const { statusChange } of subscription) {\n        if (statusChange) {\n          this.status = statusChange;\n          break;\n        }\n      }\n      return this.fetch();\n    }\n    this.gqlTransaction = response.transaction;\n    return response.transaction;\n  }\n  /**\n   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will\n   * fetch it from the provider\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   * @returns\n   */\n  async getTransactionSummary(contractsAbiMap) {\n    const { tx: transaction, bytes: transactionBytes } = await this.getTransaction();\n    const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await this.provider.getGasConfig();\n    const transactionStatus = this.getTransactionStatus();\n    const totalFee = getTotalFeeFromStatus(transactionStatus);\n    const gasPrice = totalFee ? bn17(0) : await this.provider.getLatestGasPrice();\n    const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;\n    const baseAssetId = await this.provider.getBaseAssetId();\n    const transactionSummary = assembleTransactionSummary({\n      id: this.id,\n      receipts: this.getReceipts(),\n      transaction,\n      transactionBytes,\n      gqlTransactionStatus: transactionStatus,\n      gasPerByte,\n      gasPriceFactor,\n      abiMap: contractsAbiMap,\n      maxInputs,\n      gasCosts,\n      maxGasPerTx,\n      gasPrice,\n      baseAssetId\n    });\n    return transactionSummary;\n  }\n  async getPreConfirmationTransactionSummary(contractsAbiMap) {\n    const baseAssetId = await this.provider.getBaseAssetId();\n    const maxInputs = (await this.provider.getChain()).consensusParameters.txParameters.maxInputs;\n    const transactionSummary = assemblePreConfirmationTransactionSummary({\n      id: this.id,\n      gqlTransactionStatus: this.preConfirmationStatus || this.status,\n      baseAssetId,\n      maxInputs,\n      abiMap: contractsAbiMap,\n      transactionRequest: this.request\n    });\n    return transactionSummary;\n  }\n  resolveStatus(type) {\n    const resolvers = this.statusResolvers.get(type) || [];\n    resolvers.forEach((resolve) => resolve());\n    this.statusResolvers.delete(type);\n  }\n  async waitForStatus(type) {\n    return new Promise((resolve, reject) => {\n      const resolvers = this.statusResolvers.get(type) || [];\n      resolvers.push(() => {\n        resolve();\n      });\n      this.statusResolvers.set(type, resolvers);\n      this.waitForStatusChange().catch(reject);\n    });\n  }\n  /**\n   * Waits for the status change of the transaction.\n   * If the transaction is already in a final state, it will return immediately.\n   * If the transaction is not in a final state, it will wait for the status change.\n   * If we are already subscribed to the status change, it will return immediately.\n   */\n  async waitForStatusChange() {\n    const type = this.status?.type;\n    if (type && (type === \"FailureStatus\" || type === \"SuccessStatus\")) {\n      this.resolveStatus(\"preConfirmation\");\n      this.resolveStatus(\"confirmation\");\n      return;\n    }\n    if (this.waitingForStreamData) {\n      return;\n    }\n    this.waitingForStreamData = true;\n    const subscription = this.submitTxSubscription ?? await this.provider.operations.statusChange({\n      transactionId: this.id,\n      includePreConfirmation: true\n    });\n    for await (const sub2 of subscription) {\n      const statusChange = \"statusChange\" in sub2 ? sub2.statusChange : sub2.submitAndAwaitStatus;\n      this.status = statusChange;\n      if (statusChange.type === \"SqueezedOutStatus\") {\n        throw new FuelError17(\n          ErrorCode15.TRANSACTION_SQUEEZED_OUT,\n          `Transaction Squeezed Out with reason: ${statusChange.reason}`\n        );\n      }\n      if (statusChange.type === \"PreconfirmationSuccessStatus\" || statusChange.type === \"PreconfirmationFailureStatus\") {\n        this.preConfirmationStatus = statusChange;\n        this.resolveStatus(\"preConfirmation\");\n        const pendingConfirmationResolvers = this.statusResolvers.get(\"confirmation\");\n        if (!pendingConfirmationResolvers) {\n          this.waitingForStreamData = false;\n          break;\n        }\n      }\n      if (statusChange.type === \"SuccessStatus\" || statusChange.type === \"FailureStatus\") {\n        this.resolveStatus(\"confirmation\");\n        this.resolveStatus(\"preConfirmation\");\n        this.waitingForStreamData = false;\n        break;\n      }\n    }\n  }\n  async waitForConfirmationStatuses() {\n    try {\n      await this.waitForStatus(\"confirmation\");\n    } catch (error) {\n      this.unsetResourceCache();\n      throw error;\n    }\n  }\n  async waitForPreConfirmationStatuses() {\n    try {\n      await this.waitForStatus(\"preConfirmation\");\n    } catch (error) {\n      this.unsetResourceCache();\n      throw error;\n    }\n  }\n  /**\n   * Assembles the result of a transaction by retrieving the transaction summary,\n   * decoding logs (if available), and handling transaction failure.\n   *\n   * This method can be used to obtain the result of a transaction that has just\n   * been submitted or one that has already been processed.\n   *\n   * @template TTransactionType - The type of the transaction.\n   * @param contractsAbiMap - The map of contract ABIs.\n   * @returns - The assembled transaction result.\n   * @throws If the transaction status is a failure.\n   */\n  async assembleResult(contractsAbiMap) {\n    const transactionSummary = await this.getTransactionSummary(contractsAbiMap);\n    const transactionResult = {\n      ...transactionSummary\n    };\n    let { logs, groupedLogs } = { logs: [], groupedLogs: {} };\n    let abis;\n    if (this.abis) {\n      ({ logs, groupedLogs } = getAllDecodedLogs({\n        receipts: transactionSummary.receipts,\n        mainAbi: this.abis.main,\n        externalAbis: this.abis.otherContractsAbis\n      }));\n      transactionResult.logs = logs;\n      transactionResult.groupedLogs = groupedLogs;\n      abis = this.abis;\n    }\n    const { receipts } = transactionResult;\n    const status = this.getTransactionStatus();\n    if (status?.type === \"FailureStatus\") {\n      const { reason } = status;\n      throw extractTxError({\n        receipts,\n        statusReason: reason,\n        logs,\n        groupedLogs,\n        abis\n      });\n    }\n    return transactionResult;\n  }\n  async assemblePreConfirmationResult(contractsAbiMap) {\n    const transactionSummary = await this.getPreConfirmationTransactionSummary(contractsAbiMap);\n    const transactionResult = {\n      ...transactionSummary,\n      logs: [],\n      groupedLogs: {}\n    };\n    let { logs, groupedLogs } = { logs: [], groupedLogs: {} };\n    if (this.abis && transactionSummary.receipts) {\n      ({ logs, groupedLogs } = getAllDecodedLogs({\n        receipts: transactionSummary.receipts,\n        mainAbi: this.abis.main,\n        externalAbis: this.abis.otherContractsAbis\n      }));\n      transactionResult.logs = logs;\n      transactionResult.groupedLogs = groupedLogs;\n    }\n    return transactionResult;\n  }\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @returns The completed transaction result\n   */\n  async waitForResult(contractsAbiMap) {\n    await this.waitForConfirmationStatuses();\n    this.unsetResourceCache();\n    return this.assembleResult(contractsAbiMap);\n  }\n  /**\n   * Waits for the transaction's pre-confirmation and returns the result.\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   * @returns The pre-confirmed transaction result\n   */\n  async waitForPreConfirmation(contractsAbiMap) {\n    await this.waitForPreConfirmationStatuses();\n    this.unsetResourceCache();\n    return this.assemblePreConfirmationResult(contractsAbiMap);\n  }\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   */\n  async wait(contractsAbiMap) {\n    return this.waitForResult(contractsAbiMap);\n  }\n  unsetResourceCache() {\n    this.provider.cache?.unset(this.id);\n  }\n  getTransactionStatus() {\n    return this.status ?? this.gqlTransaction?.status;\n  }\n};\n\n// src/providers/transaction-response/getDecodedLogs.ts\nimport { Interface as Interface4, BigNumberCoder as BigNumberCoder2 } from \"@fuel-ts/abi-coder\";\nimport { ZeroBytes32 as ZeroBytes3211 } from \"@fuel-ts/address/configs\";\nimport { ReceiptType as ReceiptType8 } from \"@fuel-ts/transactions\";\nfunction getDecodedLogs(receipts, mainAbi, externalAbis = {}) {\n  let mainContract = \"\";\n  if (mainAbi.programType === \"contract\") {\n    const firstCallReceipt = receipts.find(\n      (r) => r.type === ReceiptType8.Call && r.id === ZeroBytes3211\n    );\n    mainContract = firstCallReceipt.to;\n  }\n  return receipts.reduce((logs, receipt) => {\n    if (receipt.type === ReceiptType8.LogData || receipt.type === ReceiptType8.Log) {\n      const isLogFromMainAbi = receipt.id === ZeroBytes3211 || mainContract === receipt.id;\n      const isDecodable = isLogFromMainAbi || externalAbis[receipt.id];\n      if (isDecodable) {\n        const interfaceToUse = isLogFromMainAbi ? new Interface4(mainAbi) : new Interface4(externalAbis[receipt.id]);\n        const data = receipt.type === ReceiptType8.Log ? new BigNumberCoder2(\"u64\").encode(receipt.ra) : receipt.data;\n        const [decodedLog] = interfaceToUse.decodeLog(data, receipt.rb.toString());\n        logs.push(decodedLog);\n      }\n    }\n    return logs;\n  }, []);\n}\n__name(getDecodedLogs, \"getDecodedLogs\");\n\n// src/providers/utils/auto-retry-fetch.ts\nimport { sleep } from \"@fuel-ts/utils\";\nfunction getWaitDelay(options, retryAttemptNum) {\n  const duration = options.baseDelay ?? 150;\n  switch (options.backoff) {\n    case \"linear\":\n      return duration * retryAttemptNum;\n    case \"fixed\":\n      return duration;\n    case \"exponential\":\n    default:\n      return 2 ** (retryAttemptNum - 1) * duration;\n  }\n}\n__name(getWaitDelay, \"getWaitDelay\");\nfunction autoRetryFetch(fetchFn, options, retryAttemptNum = 0) {\n  if (options === void 0) {\n    return fetchFn;\n  }\n  return async (...args) => {\n    try {\n      return await fetchFn(...args);\n    } catch (_error) {\n      const error = _error;\n      if (error.cause?.code !== \"ECONNREFUSED\") {\n        throw error;\n      }\n      const retryNum = retryAttemptNum + 1;\n      if (retryNum > options.maxRetries) {\n        throw error;\n      }\n      const delay = getWaitDelay(options, retryNum);\n      await sleep(delay);\n      return autoRetryFetch(fetchFn, options, retryNum)(...args);\n    }\n  };\n}\n__name(autoRetryFetch, \"autoRetryFetch\");\n\n// src/providers/utils/parse-graphql-response.ts\nvar parseGraphqlResponse = /* @__PURE__ */ __name(async (options) => {\n  const { response, isSubscription } = options;\n  let extensions;\n  const responseClone = response.clone();\n  if (isSubscription) {\n    const reader = responseClone.body?.getReader();\n    const { event } = await FuelGraphqlSubscriber.readEvent(reader);\n    extensions = event?.extensions;\n  } else {\n    extensions = (await responseClone.json()).extensions;\n  }\n  return {\n    extensions\n  };\n}, \"parseGraphqlResponse\");\n\n// src/providers/utils/validate-pagination-args.ts\nimport { FuelError as FuelError18, ErrorCode as ErrorCode16 } from \"@fuel-ts/errors\";\nvar validatePaginationArgs = /* @__PURE__ */ __name((params) => {\n  const { paginationLimit, inputArgs = {} } = params;\n  const { first, last, after, before } = inputArgs;\n  if (after && before) {\n    throw new FuelError18(\n      ErrorCode16.INVALID_INPUT_PARAMETERS,\n      'Pagination arguments \"after\" and \"before\" cannot be used together'\n    );\n  }\n  if ((first || 0) > paginationLimit || (last || 0) > paginationLimit) {\n    throw new FuelError18(\n      ErrorCode16.INVALID_INPUT_PARAMETERS,\n      `Pagination limit for this query cannot exceed ${paginationLimit} items`\n    );\n  }\n  if (first && before) {\n    throw new FuelError18(\n      ErrorCode16.INVALID_INPUT_PARAMETERS,\n      'The use of pagination argument \"first\" with \"before\" is not supported'\n    );\n  }\n  if (last && after) {\n    throw new FuelError18(\n      ErrorCode16.INVALID_INPUT_PARAMETERS,\n      'The use of pagination argument \"last\" with \"after\" is not supported'\n    );\n  }\n  if (!first && !last) {\n    inputArgs.first = paginationLimit;\n  }\n  return inputArgs;\n}, \"validatePaginationArgs\");\n\n// src/providers/provider.ts\nvar MAX_RETRIES = 10;\nvar RESOURCES_PAGE_SIZE_LIMIT = 512;\nvar TRANSACTIONS_PAGE_SIZE_LIMIT = 60;\nvar BALANCES_PAGE_SIZE_LIMIT = 100;\nvar NON_PAGINATED_BALANCES_SIZE = 1e4;\nvar BLOCKS_PAGE_SIZE_LIMIT = 5;\nvar DEFAULT_RESOURCE_CACHE_TTL = 2e4;\nvar GAS_USED_MODIFIER = 1.2;\nvar WRITE_OPERATIONS = [\n  \"submit\",\n  \"submitAndAwaitStatus\",\n  \"produceBlocks\"\n];\nvar Provider = class _Provider {\n  static {\n    __name(this, \"Provider\");\n  }\n  operations;\n  cache;\n  /**\n   * @hidden\n   * @param url - If provided, clears cache only for given url\n   */\n  static clearChainAndNodeCaches(url) {\n    if (url) {\n      delete _Provider.inflightFetchChainAndNodeInfoRequests[url];\n      delete _Provider.chainInfoCache[url];\n      delete _Provider.nodeInfoCache[url];\n      delete _Provider.currentBlockHeightCache[url];\n      return;\n    }\n    _Provider.inflightFetchChainAndNodeInfoRequests = {};\n    _Provider.nodeInfoCache = {};\n    _Provider.chainInfoCache = {};\n    _Provider.currentBlockHeightCache = {};\n  }\n  /** @hidden */\n  url;\n  /** @hidden */\n  urlWithoutAuth;\n  /**\n   * Governs whether to include the required block height in the request body\n   * for block-sensitive operations like when submitting a transaction.\n   *\n   * This ensures that the operation is executed at the correct block height,\n   * regardless of which node in the network the request is routed to.\n   *\n   * `true` by default.\n   */\n  static ENABLE_RPC_CONSISTENCY = true;\n  /** @hidden */\n  static inflightFetchChainAndNodeInfoRequests = {};\n  /** @hidden */\n  static chainInfoCache = {};\n  /** @hidden */\n  static nodeInfoCache = {};\n  /** @hidden */\n  static currentBlockHeightCache = {};\n  /** @hidden */\n  static incompatibleNodeVersionMessage = \"\";\n  /** @hidden */\n  consensusParametersTimestamp;\n  options = {\n    timeout: void 0,\n    resourceCacheTTL: void 0,\n    fetch: void 0,\n    retryOptions: void 0,\n    headers: void 0,\n    cache: void 0\n  };\n  static extractOperationName(body) {\n    return body?.toString().match(/\"operationName\":\"(.+)\"/)?.[1];\n  }\n  static isWriteOperation(body) {\n    return WRITE_OPERATIONS.includes(this.extractOperationName(body));\n  }\n  static normalizeUrl(url) {\n    return url.replace(/-sub$/, \"\");\n  }\n  static hasWriteOperationHappened(url) {\n    return isDefined3(_Provider.currentBlockHeightCache[this.normalizeUrl(url)]);\n  }\n  /**\n   * @hidden\n   */\n  static getFetchFn(options) {\n    const { retryOptions, timeout, headers } = options;\n    return autoRetryFetch(async (...args) => {\n      const url = args[0];\n      const request2 = args[1];\n      const signal = timeout ? AbortSignal.timeout(timeout) : void 0;\n      let fullRequest = {\n        ...request2,\n        signal,\n        headers: { ...request2?.headers, ...headers }\n      };\n      if (options.requestMiddleware) {\n        fullRequest = await options.requestMiddleware(fullRequest);\n      }\n      if (_Provider.ENABLE_RPC_CONSISTENCY && _Provider.hasWriteOperationHappened(url)) {\n        _Provider.applyBlockHeight(fullRequest, url);\n      }\n      const response = await _Provider.fetchAndProcessBlockHeight(url, fullRequest, options);\n      if (response.body === null) {\n        throw new FuelError19(\n          ErrorCode17.RESPONSE_BODY_EMPTY,\n          \"The response from the server is missing the body\",\n          { timestamp: (/* @__PURE__ */ new Date()).toISOString(), request: request2, response }\n        );\n      }\n      return response;\n    }, retryOptions);\n  }\n  static applyBlockHeight(request2, url) {\n    const normalizedUrl = this.normalizeUrl(url);\n    const currentBlockHeight = _Provider.currentBlockHeightCache[normalizedUrl] ?? 0;\n    request2.body = request2.body?.toString().replace(/}$/, `,\"extensions\":{\"required_fuel_block_height\":${currentBlockHeight}}}`);\n  }\n  static async fetchAndProcessBlockHeight(url, request2, options) {\n    const fetchFn = /* @__PURE__ */ __name(() => options.fetch ? options.fetch(url, request2, options) : fetch(url, request2), \"fetchFn\");\n    const isWriteOperation = _Provider.isWriteOperation(request2.body);\n    if (isWriteOperation && !_Provider.hasWriteOperationHappened(url)) {\n      _Provider.currentBlockHeightCache[_Provider.normalizeUrl(url)] = 0;\n    }\n    let response = await fetchFn();\n    if (!_Provider.ENABLE_RPC_CONSISTENCY) {\n      return response;\n    }\n    const retryOptions = {\n      maxRetries: 5,\n      baseDelay: 500\n    };\n    for (let retriesLeft = retryOptions.maxRetries; retriesLeft > 0; --retriesLeft) {\n      if (response.body) {\n        const { extensions } = await parseGraphqlResponse({\n          response,\n          isSubscription: url.endsWith(\"-sub\")\n        });\n        _Provider.setCurrentBlockHeight(url, extensions?.current_fuel_block_height);\n        if (!extensions?.fuel_block_height_precondition_failed) {\n          break;\n        }\n      }\n      const retryAttempt = retryOptions.maxRetries - retriesLeft + 1;\n      const sleepTime = getWaitDelay(retryOptions, retryAttempt);\n      await sleep2(sleepTime);\n      response = await fetchFn();\n    }\n    return response;\n  }\n  static setCurrentBlockHeight(url, height) {\n    const writeOperationHappened = _Provider.hasWriteOperationHappened(url);\n    if (!isDefined3(height) || !writeOperationHappened) {\n      return;\n    }\n    const normalizedUrl = _Provider.normalizeUrl(url);\n    if (height > _Provider.currentBlockHeightCache[normalizedUrl]) {\n      _Provider.currentBlockHeightCache[normalizedUrl] = height;\n    }\n  }\n  /**\n   * Constructor to initialize a Provider.\n   *\n   * @param url - GraphQL endpoint of the Fuel node\n   * @param options - Additional options for the provider\n   * @hidden\n   */\n  constructor(url, options = {}) {\n    const { url: rawUrl, urlWithoutAuth, headers: authHeaders } = _Provider.extractBasicAuth(url);\n    this.url = rawUrl;\n    this.urlWithoutAuth = urlWithoutAuth;\n    this.url = url;\n    const { FUELS } = versions;\n    const headers = { ...authHeaders, ...options.headers, Source: `ts-sdk-${FUELS}` };\n    this.options = {\n      ...this.options,\n      ...options,\n      headers\n    };\n    this.operations = this.createOperations();\n    const { resourceCacheTTL, cache: cache2 } = this.options;\n    if (cache2) {\n      const { consensusParametersTimestamp, chain, nodeInfo } = deserializeProviderCache(cache2);\n      this.consensusParametersTimestamp = consensusParametersTimestamp;\n      _Provider.chainInfoCache[this.urlWithoutAuth] = chain;\n      _Provider.nodeInfoCache[this.urlWithoutAuth] = nodeInfo;\n    }\n    if (isDefined3(resourceCacheTTL)) {\n      if (resourceCacheTTL !== -1) {\n        this.cache = new ResourceCache(resourceCacheTTL);\n      } else {\n        this.cache = void 0;\n      }\n    } else {\n      this.cache = new ResourceCache(DEFAULT_RESOURCE_CACHE_TTL);\n    }\n  }\n  static extractBasicAuth(url) {\n    let parsedUrl;\n    try {\n      parsedUrl = new URL(url);\n    } catch (error) {\n      throw new FuelError19(FuelError19.CODES.INVALID_URL, \"Invalid URL provided.\", { url }, error);\n    }\n    const username = parsedUrl.username;\n    const password = parsedUrl.password;\n    const urlWithoutAuth = `${parsedUrl.origin}${parsedUrl.pathname}`;\n    if (!(username && password)) {\n      return { url, urlWithoutAuth: url, headers: void 0 };\n    }\n    return {\n      url,\n      urlWithoutAuth,\n      headers: { Authorization: `Basic ${btoa(`${username}:${password}`)}` }\n    };\n  }\n  /**\n   * Initialize Provider async stuff\n   */\n  async init() {\n    await this.fetchChainAndNodeInfo();\n    return this;\n  }\n  /**\n   * Returns the `chainInfo` for the current network.\n   *\n   * @returns the chain information configuration.\n   */\n  async getChain() {\n    await this.init();\n    return _Provider.chainInfoCache[this.urlWithoutAuth];\n  }\n  /**\n   * Returns the `nodeInfo` for the current network.\n   *\n   * @returns the node information configuration.\n   */\n  async getNode() {\n    await this.init();\n    return _Provider.nodeInfoCache[this.urlWithoutAuth];\n  }\n  /**\n   * Returns some helpful parameters related to gas fees.\n   */\n  async getGasConfig() {\n    await this.init();\n    const {\n      txParameters: { maxGasPerTx },\n      predicateParameters: { maxGasPerPredicate },\n      feeParameters: { gasPriceFactor, gasPerByte },\n      gasCosts\n    } = (await this.getChain()).consensusParameters;\n    return {\n      maxGasPerTx,\n      maxGasPerPredicate,\n      gasPriceFactor,\n      gasPerByte,\n      gasCosts\n    };\n  }\n  /**\n   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.\n   *\n   * @param url - The URL to connect to.\n   * @param options - Additional options for the provider.\n   */\n  async connect(url, options) {\n    const { url: rawUrl, urlWithoutAuth, headers } = _Provider.extractBasicAuth(url);\n    this.url = rawUrl;\n    this.urlWithoutAuth = urlWithoutAuth;\n    this.options = options ?? this.options;\n    this.options = { ...this.options, headers: { ...this.options.headers, ...headers } };\n    this.operations = this.createOperations();\n    await this.init();\n  }\n  /**\n   * Return the chain and node information.\n   * @param ignoreCache - If true, ignores the cache and re-fetch configs.\n   * @returns A promise that resolves to the Chain and NodeInfo.\n   */\n  async fetchChainAndNodeInfo(ignoreCache = false) {\n    const nodeInfo = _Provider.nodeInfoCache[this.urlWithoutAuth];\n    const chain = _Provider.chainInfoCache[this.urlWithoutAuth];\n    const hasCache = nodeInfo && chain;\n    if (hasCache && !ignoreCache) {\n      return { nodeInfo, chain };\n    }\n    const inflightRequest = _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];\n    if (inflightRequest) {\n      return inflightRequest.then((data) => {\n        this.consensusParametersTimestamp = data.consensusParametersTimestamp;\n        return {\n          nodeInfo: _Provider.nodeInfoCache[this.urlWithoutAuth],\n          chain: _Provider.chainInfoCache[this.urlWithoutAuth]\n        };\n      });\n    }\n    const getChainAndNodeInfoFromNetwork = this.operations.getChainAndNodeInfo().then((data) => ({\n      chain: deserializeChain(data.chain),\n      nodeInfo: deserializeNodeInfo(data.nodeInfo),\n      consensusParametersTimestamp: Date.now()\n    })).then((data) => {\n      _Provider.setIncompatibleNodeVersionMessage(data.nodeInfo);\n      _Provider.chainInfoCache[this.urlWithoutAuth] = data.chain;\n      _Provider.nodeInfoCache[this.urlWithoutAuth] = data.nodeInfo;\n      this.consensusParametersTimestamp = data.consensusParametersTimestamp;\n      return data;\n    }).catch((err) => {\n      const error = new FuelError19(\n        FuelError19.CODES.CONNECTION_REFUSED,\n        \"Unable to fetch chain and node info from the network\",\n        { url: this.urlWithoutAuth },\n        err\n      );\n      error.cause = { code: \"ECONNREFUSED\" };\n      throw error;\n    }).finally(() => {\n      delete _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];\n    });\n    _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth] = getChainAndNodeInfoFromNetwork;\n    return _Provider.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth].then((data) => {\n      this.consensusParametersTimestamp = data.consensusParametersTimestamp;\n      return {\n        nodeInfo: _Provider.nodeInfoCache[this.urlWithoutAuth],\n        chain: _Provider.chainInfoCache[this.urlWithoutAuth]\n      };\n    });\n  }\n  /**\n   * @hidden\n   */\n  static setIncompatibleNodeVersionMessage(nodeInfo) {\n    const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);\n    if (!isMajorSupported || !isMinorSupported) {\n      _Provider.incompatibleNodeVersionMessage = [\n        `The Fuel Node that you are trying to connect to is using fuel-core version ${nodeInfo.nodeVersion}.`,\n        `The TS SDK currently supports fuel-core version ${supportedVersion}.`,\n        `Things may not work as expected.`\n      ].join(\"\\n\");\n      FuelGraphqlSubscriber.incompatibleNodeVersionMessage = _Provider.incompatibleNodeVersionMessage;\n    }\n  }\n  /**\n   * Create GraphQL client and set operations.\n   *\n   * @returns The operation SDK object\n   * @hidden\n   */\n  createOperations() {\n    const fetchFn = _Provider.getFetchFn(this.options);\n    const gqlClient = new GraphQLClient(this.urlWithoutAuth, {\n      fetch: /* @__PURE__ */ __name((input, requestInit) => fetchFn(input.toString(), requestInit || {}, this.options), \"fetch\"),\n      responseMiddleware: /* @__PURE__ */ __name((response) => {\n        if (\"response\" in response) {\n          const graphQlResponse = response.response;\n          assertGqlResponseHasNoErrors(\n            graphQlResponse.errors,\n            _Provider.incompatibleNodeVersionMessage\n          );\n        }\n      }, \"responseMiddleware\")\n    });\n    const executeQuery = /* @__PURE__ */ __name((query, vars) => {\n      const opDefinition = query.definitions.find((x) => x.kind === \"OperationDefinition\");\n      const isSubscription = opDefinition?.operation === \"subscription\";\n      if (isSubscription) {\n        return FuelGraphqlSubscriber.create({\n          url: this.urlWithoutAuth,\n          query,\n          fetchFn: /* @__PURE__ */ __name((url, requestInit) => fetchFn(url, requestInit, this.options), \"fetchFn\"),\n          variables: vars,\n          operationName: opDefinition.name.value,\n          onEvent: /* @__PURE__ */ __name((event) => {\n            _Provider.setCurrentBlockHeight(\n              this.urlWithoutAuth,\n              event.extensions?.current_fuel_block_height\n            );\n          }, \"onEvent\")\n        });\n      }\n      return gqlClient.request(query, vars);\n    }, \"executeQuery\");\n    const customOperations = /* @__PURE__ */ __name((requester) => ({\n      getBlobs(variables) {\n        const queryParams = variables.blobIds.map((_, i) => `$blobId${i}: BlobId!`).join(\", \");\n        const blobParams = variables.blobIds.map((_, i) => `blob${i}: blob(id: $blobId${i}) { id }`).join(\"\\n\");\n        const updatedVariables = variables.blobIds.reduce(\n          (acc, blobId, i) => {\n            acc[`blobId${i}`] = blobId;\n            return acc;\n          },\n          {}\n        );\n        const document2 = gql2`\n          query getBlobs(${queryParams}) {\n            ${blobParams}\n          }\n        `;\n        return requester(document2, updatedVariables);\n      }\n    }), \"customOperations\");\n    return { ...getSdk(executeQuery), ...customOperations(executeQuery) };\n  }\n  /**\n   * Returns the version of the connected node.\n   *\n   * @returns A promise that resolves to the version string.\n   */\n  async getVersion() {\n    const {\n      nodeInfo: { nodeVersion }\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n  /**\n   * Returns the latest block number.\n   *\n   * @returns A promise that resolves to the latest block number.\n   */\n  async getBlockNumber() {\n    const {\n      chain: {\n        latestBlock: { height }\n      }\n    } = await this.operations.getLatestBlockHeight();\n    return bn18(height);\n  }\n  /**\n   * Returns the node information for the current provider network.\n   *\n   * @returns a promise that resolves to the node information.\n   */\n  async fetchNode() {\n    const { nodeInfo } = await this.operations.getNodeInfo();\n    const processedNodeInfo = deserializeNodeInfo(nodeInfo);\n    _Provider.nodeInfoCache[this.urlWithoutAuth] = processedNodeInfo;\n    return processedNodeInfo;\n  }\n  /**\n   * Returns the chain information for the current provider network.\n   *\n   * @returns a promise that resolves to the chain information.\n   */\n  async fetchChain() {\n    const { chain } = await this.operations.getChain();\n    const processedChain = deserializeChain(chain);\n    _Provider.chainInfoCache[this.urlWithoutAuth] = processedChain;\n    return processedChain;\n  }\n  /**\n   * Returns the chain ID for the current provider network.\n   *\n   * @returns A promise that resolves to the chain ID number.\n   */\n  async getChainId() {\n    const {\n      consensusParameters: { chainId }\n    } = await this.getChain();\n    return chainId.toNumber();\n  }\n  /**\n   * Returns the base asset ID for the current provider network.\n   *\n   * @returns the base asset ID.\n   */\n  async getBaseAssetId() {\n    const all = await this.getChain();\n    const {\n      consensusParameters: { baseAssetId }\n    } = all;\n    return baseAssetId;\n  }\n  /**\n   * Retrieves the details of an asset given its ID.\n   *\n   * @param assetId - The unique identifier of the asset.\n   * @returns A promise that resolves to an object containing the asset details.\n   */\n  async getAssetDetails(assetId) {\n    const { assetMetadata } = await this.getNodeFeatures();\n    if (!assetMetadata) {\n      throw new FuelError19(\n        ErrorCode17.UNSUPPORTED_FEATURE,\n        \"The current node does not supports fetching asset details\"\n      );\n    }\n    const { assetDetails } = await this.operations.getAssetDetails({ assetId });\n    const { contractId, subId, totalSupply } = assetDetails;\n    return {\n      subId,\n      contractId,\n      totalSupply: bn18(totalSupply)\n    };\n  }\n  /**\n   * @hidden\n   */\n  #cacheInputs(inputs, transactionId) {\n    if (!this.cache) {\n      return;\n    }\n    this.cache.set(transactionId, inputs);\n  }\n  /**\n   * @hidden\n   */\n  async validateTransaction(tx) {\n    const {\n      consensusParameters: {\n        txParameters: { maxInputs, maxOutputs }\n      }\n    } = await this.getChain();\n    if (bn18(tx.inputs.length).gt(maxInputs)) {\n      throw new FuelError19(\n        ErrorCode17.MAX_INPUTS_EXCEEDED,\n        `The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${tx.inputs.length}, max inputs: ${maxInputs}`\n      );\n    }\n    if (bn18(tx.outputs.length).gt(maxOutputs)) {\n      throw new FuelError19(\n        ErrorCode17.MAX_OUTPUTS_EXCEEDED,\n        `The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${tx.outputs.length}, max outputs: ${maxOutputs}`\n      );\n    }\n  }\n  /**\n   * Submits a transaction to the chain to be executed.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param sendTransactionParams - The provider send transaction parameters (optional).\n   * @returns A promise that resolves to the transaction response object.\n   */\n  async sendTransaction(transactionRequestLike, {\n    enableAssetBurn,\n    estimateTxDependencies = true,\n    includePreConfirmation: _includePreConfirmation = true\n  } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    validateTransactionForAssetBurn(\n      await this.getBaseAssetId(),\n      transactionRequest,\n      enableAssetBurn\n    );\n    if (estimateTxDependencies) {\n      await this.estimateTxDependencies(transactionRequest);\n    }\n    await this.validateTransaction(transactionRequest);\n    const encodedTransaction = hexlify17(transactionRequest.toTransactionBytes());\n    let abis;\n    if (isTransactionTypeScript(transactionRequest)) {\n      abis = transactionRequest.abis;\n    }\n    const subscription = await this.operations.submitAndAwaitStatus({\n      encodedTransaction,\n      includePreConfirmation: true\n    });\n    this.#cacheInputs(\n      transactionRequest.inputs,\n      transactionRequest.getTransactionId(await this.getChainId())\n    );\n    const chainId = await this.getChainId();\n    return new TransactionResponse({\n      transactionRequestOrId: transactionRequest,\n      provider: this,\n      chainId,\n      abis,\n      submitAndAwaitSubscription: subscription\n    });\n  }\n  /**\n   * Executes a transaction without actually submitting it to the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param sendTransactionParams - The provider call parameters (optional).\n   * @returns A promise that resolves to the call result object.\n   */\n  async dryRun(transactionRequestLike, { utxoValidation, estimateTxDependencies = true } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      return this.estimateTxDependencies(transactionRequest);\n    }\n    const encodedTransaction = hexlify17(transactionRequest.toTransactionBytes());\n    const { dryRun: dryRunStatuses } = await this.operations.dryRun({\n      encodedTransactions: encodedTransaction,\n      utxoValidation: utxoValidation || false\n    });\n    const [{ receipts: rawReceipts, status: dryRunStatus }] = dryRunStatuses;\n    const receipts = rawReceipts.map(deserializeReceipt);\n    return { receipts, dryRunStatus };\n  }\n  /**\n   * Estimates the gas usage for predicates in a transaction request.\n   *\n   * @template T - The type of the transaction request object.\n   *\n   * @param transactionRequest - The transaction request to estimate predicates for.\n   * @returns A promise that resolves to the updated transaction request with estimated gas usage for predicates.\n   */\n  async estimatePredicates(transactionRequest) {\n    const shouldEstimatePredicates = transactionRequest.inputs.some(\n      (input) => isPredicate(input) && bn18(input.predicateGasUsed).isZero()\n    );\n    if (!shouldEstimatePredicates) {\n      return transactionRequest;\n    }\n    const encodedTransaction = hexlify17(transactionRequest.toTransactionBytes());\n    const response = await this.operations.estimatePredicates({\n      encodedTransaction\n    });\n    const { estimatePredicates } = response;\n    transactionRequest = this.parseEstimatePredicatesResponse(\n      transactionRequest,\n      estimatePredicates\n    );\n    return transactionRequest;\n  }\n  /**\n   * Estimates the gas price and predicates for a given transaction request and block horizon.\n   *\n   * @param transactionRequest - The transaction request to estimate predicates and gas price for.\n   * @param blockHorizon - The block horizon to use for gas price estimation.\n   * @returns A promise that resolves to an object containing the updated transaction\n   * request and the estimated gas price.\n   */\n  async estimatePredicatesAndGasPrice(transactionRequest, blockHorizon) {\n    const shouldEstimatePredicates = transactionRequest.inputs.some(\n      (input) => isPredicate(input) && bn18(input.predicateGasUsed).isZero()\n    );\n    if (!shouldEstimatePredicates) {\n      const gasPrice2 = await this.estimateGasPrice(blockHorizon);\n      return { transactionRequest, gasPrice: gasPrice2 };\n    }\n    const {\n      estimateGasPrice: { gasPrice },\n      estimatePredicates\n    } = await this.operations.estimatePredicatesAndGasPrice({\n      blockHorizon: String(blockHorizon),\n      encodedTransaction: hexlify17(transactionRequest.toTransactionBytes())\n    });\n    transactionRequest = this.parseEstimatePredicatesResponse(\n      transactionRequest,\n      estimatePredicates\n    );\n    return { transactionRequest, gasPrice: bn18(gasPrice) };\n  }\n  /**\n   * Will dryRun a transaction and check for missing dependencies.\n   *\n   * If there are missing variable outputs,\n   * `addVariableOutputs` is called on the transaction.\n   *\n   * @param transactionRequest - The transaction request object.\n   * @param gasPrice - The gas price to use for the transaction, if not provided it will be fetched.\n   * @returns A promise that resolves to the estimate transaction dependencies.\n   */\n  async estimateTxDependencies(transactionRequest, { gasPrice: gasPriceParam } = {}) {\n    if (isTransactionTypeCreate(transactionRequest)) {\n      return {\n        rawReceipts: [],\n        receipts: [],\n        outputVariables: 0,\n        missingContractIds: []\n      };\n    }\n    let rawReceipts = [];\n    let receipts = [];\n    const missingContractIds = [];\n    let outputVariables = 0;\n    let dryRunStatus;\n    await this.validateTransaction(transactionRequest);\n    const gasPrice = gasPriceParam ?? await this.estimateGasPrice(10);\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n      const {\n        dryRun: [{ receipts: serializedReceipts, status }]\n      } = await this.operations.dryRun({\n        encodedTransactions: [hexlify17(transactionRequest.toTransactionBytes())],\n        utxoValidation: false,\n        gasPrice: gasPrice.toString()\n      });\n      rawReceipts = serializedReceipts;\n      receipts = serializedReceipts.map(deserializeReceipt);\n      dryRunStatus = status;\n      const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);\n      const hasMissingOutputs = missingOutputVariables.length !== 0 || missingOutputContractIds.length !== 0;\n      if (hasMissingOutputs && isTransactionTypeScript(transactionRequest)) {\n        outputVariables += missingOutputVariables.length;\n        transactionRequest.addVariableOutputs(missingOutputVariables.length);\n        missingOutputContractIds.forEach(({ contractId }) => {\n          transactionRequest.addContractInputAndOutput(new Address2(contractId));\n          missingContractIds.push(contractId);\n        });\n        const { maxFee } = await this.estimateTxGasAndFee({\n          transactionRequest,\n          gasPrice\n        });\n        transactionRequest.maxFee = maxFee;\n      } else {\n        break;\n      }\n    }\n    return {\n      rawReceipts,\n      receipts,\n      outputVariables,\n      missingContractIds,\n      dryRunStatus\n    };\n  }\n  /**\n   * Dry runs multiple transactions and checks for missing dependencies in batches.\n   *\n   * Transactions are dry run in batches. After each dry run, transactions requiring\n   * further modifications are identified. The method iteratively updates these transactions\n   * and performs subsequent dry runs until all dependencies for each transaction are satisfied.\n   *\n   * @param transactionRequests - Array of transaction request objects.\n   * @returns A promise that resolves to an array of results for each transaction.\n   */\n  async estimateMultipleTxDependencies(transactionRequests) {\n    const results = transactionRequests.map(() => ({\n      rawReceipts: [],\n      receipts: [],\n      outputVariables: 0,\n      missingContractIds: [],\n      dryRunStatus: void 0\n    }));\n    const allRequests = clone8(transactionRequests);\n    const serializedTransactionsMap = /* @__PURE__ */ new Map();\n    allRequests.forEach((req, index) => {\n      if (isTransactionTypeScript(req)) {\n        serializedTransactionsMap.set(index, hexlify17(req.toTransactionBytes()));\n      }\n    });\n    let transactionsToProcess = Array.from(serializedTransactionsMap.keys());\n    let attempt = 0;\n    while (transactionsToProcess.length > 0 && attempt < MAX_RETRIES) {\n      const encodedTransactions = transactionsToProcess.map(\n        (index) => serializedTransactionsMap.get(index)\n      );\n      const dryRunResults = await this.operations.dryRun({\n        encodedTransactions,\n        utxoValidation: false\n      });\n      const nextRoundTransactions = [];\n      for (let i = 0; i < dryRunResults.dryRun.length; i++) {\n        const requestIdx = transactionsToProcess[i];\n        const { receipts: rawReceipts, status } = dryRunResults.dryRun[i];\n        const result = results[requestIdx];\n        result.receipts = rawReceipts.map(deserializeReceipt);\n        result.dryRunStatus = status;\n        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(\n          result.receipts\n        );\n        const hasMissingOutputs = missingOutputVariables.length > 0 || missingOutputContractIds.length > 0;\n        const request2 = allRequests[requestIdx];\n        if (hasMissingOutputs && isTransactionTypeScript(request2)) {\n          result.outputVariables += missingOutputVariables.length;\n          request2.addVariableOutputs(missingOutputVariables.length);\n          missingOutputContractIds.forEach(({ contractId }) => {\n            request2.addContractInputAndOutput(new Address2(contractId));\n            result.missingContractIds.push(contractId);\n          });\n          const { maxFee } = await this.estimateTxGasAndFee({\n            transactionRequest: request2\n          });\n          request2.maxFee = maxFee;\n          serializedTransactionsMap.set(requestIdx, hexlify17(request2.toTransactionBytes()));\n          nextRoundTransactions.push(requestIdx);\n        }\n      }\n      transactionsToProcess = nextRoundTransactions;\n      attempt += 1;\n    }\n    return results;\n  }\n  /**\n   * Dry runs multiple transactions.\n   *\n   * @param transactionRequests - Array of transaction request objects.\n   * @param sendTransactionParams - The provider call parameters (optional).\n   *\n   * @returns A promise that resolves to an array of results for each transaction call.\n   */\n  async dryRunMultipleTransactions(transactionRequests, { utxoValidation, estimateTxDependencies = true } = {}) {\n    if (estimateTxDependencies) {\n      return this.estimateMultipleTxDependencies(transactionRequests);\n    }\n    const encodedTransactions = transactionRequests.map((tx) => hexlify17(tx.toTransactionBytes()));\n    const { dryRun: dryRunStatuses } = await this.operations.dryRun({\n      encodedTransactions,\n      utxoValidation: utxoValidation || false\n    });\n    const results = dryRunStatuses.map(({ receipts: rawReceipts, status }) => {\n      const receipts = rawReceipts.map(deserializeReceipt);\n      return { receipts, dryRunStatus: status };\n    });\n    return results;\n  }\n  async autoRefetchConfigs() {\n    const now = Date.now();\n    const diff = now - (this.consensusParametersTimestamp ?? 0);\n    if (diff < 6e4) {\n      return;\n    }\n    if (!_Provider.chainInfoCache?.[this.urlWithoutAuth]) {\n      await this.fetchChainAndNodeInfo(true);\n      return;\n    }\n    const chainInfo = _Provider.chainInfoCache[this.urlWithoutAuth];\n    const {\n      latestBlock: {\n        header: { consensusParametersVersion: previous }\n      }\n    } = chainInfo;\n    const {\n      chain: {\n        latestBlock: {\n          header: { consensusParametersVersion: current }\n        }\n      }\n    } = await this.operations.getConsensusParametersVersion();\n    if (previous !== current) {\n      await this.fetchChainAndNodeInfo(true);\n    }\n  }\n  /**\n   * Estimates the transaction gas and fee based on the provided transaction request.\n   * @param params - The parameters for estimating the transaction gas and fee.\n   * @returns An object containing the estimated minimum gas, minimum fee, maximum gas, and maximum fee.\n   */\n  async estimateTxGasAndFee(params) {\n    const { transactionRequest, gasPrice: gasPriceParam } = params;\n    let gasPrice = gasPriceParam;\n    await this.autoRefetchConfigs();\n    const chainInfo = await this.getChain();\n    const { gasPriceFactor, maxGasPerTx } = await this.getGasConfig();\n    const minGas = transactionRequest.calculateMinGas(chainInfo);\n    if (!isDefined3(gasPrice)) {\n      gasPrice = await this.estimateGasPrice(10);\n    }\n    const minFee = calculateGasFee({\n      gasPrice: bn18(gasPrice),\n      gas: minGas,\n      priceFactor: gasPriceFactor,\n      tip: transactionRequest.tip\n    }).add(1);\n    let gasLimit = bn18(0);\n    if (isTransactionTypeScript(transactionRequest)) {\n      gasLimit = transactionRequest.gasLimit;\n      if (transactionRequest.gasLimit.eq(0)) {\n        transactionRequest.gasLimit = minGas;\n        transactionRequest.gasLimit = maxGasPerTx.sub(\n          transactionRequest.calculateMaxGas(chainInfo, minGas)\n        );\n        gasLimit = transactionRequest.gasLimit;\n      }\n    }\n    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);\n    const maxFee = calculateGasFee({\n      gasPrice: bn18(gasPrice),\n      gas: maxGas,\n      priceFactor: gasPriceFactor,\n      tip: transactionRequest.tip\n    }).add(1);\n    return {\n      minGas,\n      minFee,\n      maxGas,\n      maxFee,\n      gasPrice,\n      gasLimit\n    };\n  }\n  /**\n   * Executes a signed transaction without applying the states changes\n   * on the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param estimateTxParams - The estimate transaction params (optional).\n   * @returns A promise that resolves to the call result object.\n   */\n  async simulate(transactionRequestLike, { estimateTxDependencies = true } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      return this.estimateTxDependencies(transactionRequest);\n    }\n    const encodedTransactions = [hexlify17(transactionRequest.toTransactionBytes())];\n    const { dryRun: dryRunStatuses } = await this.operations.dryRun({\n      encodedTransactions,\n      utxoValidation: true\n    });\n    const callResult = dryRunStatuses.map((dryRunStatus) => {\n      const { id, receipts, status } = dryRunStatus;\n      const processedReceipts = receipts.map(deserializeReceipt);\n      return { id, receipts: processedReceipts, status };\n    });\n    return { receipts: callResult[0].receipts };\n  }\n  /**\n   * @hidden\n   *\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the transaction.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param transactionCostParams - The transaction cost parameters (optional).\n   *\n   * @returns A promise that resolves to the transaction cost object.\n   *\n   * @deprecated Use provider.assembleTx instead\n   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.\n   */\n  async getTransactionCost(transactionRequestLike, { signatureCallback, gasPrice: gasPriceParam } = {}) {\n    const txRequestClone = clone8(transactionRequestify(transactionRequestLike));\n    const updateMaxFee = txRequestClone.maxFee.eq(0);\n    const isScriptTransaction = isTransactionTypeScript(txRequestClone);\n    if (isScriptTransaction) {\n      txRequestClone.gasLimit = bn18(0);\n    }\n    const signedRequest = clone8(txRequestClone);\n    let addedSignatures = 0;\n    if (signatureCallback && isTransactionTypeScript(signedRequest)) {\n      const lengthBefore = signedRequest.witnesses.length;\n      await signatureCallback(signedRequest);\n      addedSignatures = signedRequest.witnesses.length - lengthBefore;\n    }\n    let gasPrice;\n    if (gasPriceParam) {\n      gasPrice = gasPriceParam;\n      await this.estimatePredicates(signedRequest);\n    } else {\n      ({ gasPrice } = await this.estimatePredicatesAndGasPrice(signedRequest, 10));\n    }\n    txRequestClone.updatePredicateGasUsed(signedRequest.inputs);\n    let { maxFee, maxGas, minFee, minGas, gasLimit } = await this.estimateTxGasAndFee({\n      // Fetches and returns a gas price\n      transactionRequest: signedRequest,\n      gasPrice\n    });\n    let rawReceipts = [];\n    let receipts = [];\n    let dryRunStatus;\n    let missingContractIds = [];\n    let outputVariables = 0;\n    let gasUsed = bn18(0);\n    txRequestClone.maxFee = maxFee;\n    if (isScriptTransaction) {\n      txRequestClone.gasLimit = gasLimit;\n      if (signatureCallback) {\n        await signatureCallback(txRequestClone);\n      }\n      ({ rawReceipts, receipts, missingContractIds, outputVariables, dryRunStatus } = await this.estimateTxDependencies(txRequestClone, { gasPrice }));\n      if (dryRunStatus && \"reason\" in dryRunStatus) {\n        throw this.extractDryRunError(txRequestClone, receipts, dryRunStatus.reason);\n      }\n      const { maxGasPerTx } = await this.getGasConfig();\n      const pristineGasUsed = getGasUsedFromReceipts(receipts);\n      gasUsed = bn18(pristineGasUsed.muln(GAS_USED_MODIFIER)).max(maxGasPerTx.sub(minGas));\n      txRequestClone.gasLimit = gasUsed;\n      ({ maxFee, maxGas, minFee, minGas } = await this.estimateTxGasAndFee({\n        transactionRequest: txRequestClone,\n        gasPrice\n      }));\n    }\n    const transactionSummary = {\n      gasPrice: gasPrice.toString(),\n      receipts: rawReceipts\n    };\n    return {\n      rawReceipts,\n      receipts,\n      gasUsed,\n      gasPrice,\n      minGas,\n      maxGas,\n      minFee,\n      maxFee,\n      outputVariables,\n      missingContractIds,\n      addedSignatures,\n      estimatedPredicates: txRequestClone.inputs,\n      dryRunStatus,\n      updateMaxFee,\n      transactionSummary\n    };\n  }\n  /**\n   * Assembles a transaction by completely estimating and funding it.\n   *\n   * @param params - Parameters used to assemble the transaction.\n   *\n   * @returns The assembled transaction request, estimated gas price, and receipts\n   */\n  async assembleTx(params) {\n    const {\n      request: request2,\n      reserveGas,\n      resourcesIdsToIgnore,\n      feePayerAccount,\n      blockHorizon = 10,\n      estimatePredicates = true,\n      accountCoinQuantities = []\n    } = params;\n    const allAddresses = /* @__PURE__ */ new Set();\n    const baseAssetId = await this.getBaseAssetId();\n    let feePayerIndex = -1;\n    let baseAssetChange;\n    const requiredBalances = accountCoinQuantities.map((quantity, index) => {\n      const { amount, assetId, account = feePayerAccount, changeOutputAccount } = quantity;\n      const changeAccountAddress = changeOutputAccount ? changeOutputAccount.address.toB256() : account.address.toB256();\n      allAddresses.add(account.address.toB256());\n      const changePolicy = {\n        change: changeAccountAddress\n      };\n      if (assetId === baseAssetId) {\n        baseAssetChange = changePolicy.change;\n      }\n      if (account.address.equals(feePayerAccount.address)) {\n        feePayerIndex = index;\n      }\n      const requiredBalance = {\n        account: resolveAccountForAssembleTxParams(account),\n        amount: bn18(amount).toString(10),\n        assetId,\n        changePolicy\n      };\n      return requiredBalance;\n    });\n    if (feePayerIndex === -1) {\n      allAddresses.add(feePayerAccount.address.toB256());\n      const newLength = requiredBalances.push({\n        account: resolveAccountForAssembleTxParams(feePayerAccount),\n        amount: bn18(0).toString(10),\n        // Since the correct fee amount cannot be determined yet, we can use 0\n        assetId: baseAssetId,\n        changePolicy: {\n          change: baseAssetChange || feePayerAccount.address.toB256()\n        }\n      });\n      feePayerIndex = newLength - 1;\n    }\n    const excludeInput = await this.adjustResourcesToIgnoreForAddresses(\n      Array.from(allAddresses),\n      resourcesIdsToIgnore\n    );\n    const {\n      assembleTx: { status, transaction: gqlTransaction, gasPrice }\n    } = await this.operations.assembleTx({\n      tx: hexlify17(request2.toTransactionBytes()),\n      blockHorizon: String(blockHorizon),\n      feeAddressIndex: String(feePayerIndex),\n      requiredBalances,\n      estimatePredicates,\n      excludeInput,\n      reserveGas: reserveGas ? bn18(reserveGas).toString(10) : void 0\n    });\n    if (status.type === \"DryRunFailureStatus\") {\n      const parsedReceipts = status.receipts.map(deserializeReceipt);\n      throw this.extractDryRunError(request2, parsedReceipts, status.reason);\n    }\n    request2.witnesses = gqlTransaction.witnesses || request2.witnesses;\n    request2.inputs = gqlTransaction.inputs?.map(deserializeInput) || request2.inputs;\n    request2.outputs = gqlTransaction.outputs?.map(deserializeOutput) || request2.outputs;\n    if (gqlTransaction.policies?.maxFee) {\n      request2.maxFee = bn18(gqlTransaction.policies.maxFee);\n    }\n    if (request2.type === TransactionType11.Script) {\n      request2.gasLimit = bn18(gqlTransaction.scriptGasLimit).add(bn18(reserveGas));\n    }\n    const rawReceipts = status.receipts;\n    const chainId = await this.getChainId();\n    request2.updateState(chainId, \"funded\", {\n      gasPrice: gasPrice.toString(),\n      receipts: rawReceipts\n    });\n    return {\n      assembledRequest: request2,\n      gasPrice: bn18(gasPrice),\n      receipts: status.receipts.map(deserializeReceipt),\n      rawReceipts\n    };\n  }\n  /**\n   * Returns coins for the given owner.\n   *\n   * @param owner - The address to get coins for.\n   * @param assetId - The asset ID of coins to get (optional).\n   * @param paginationArgs - Pagination arguments (optional).\n   *\n   * @returns A promise that resolves to the coins.\n   */\n  async getCoins(owner, assetId, paginationArgs) {\n    const ownerAddress = new Address2(owner);\n    const {\n      coins: { edges, pageInfo }\n    } = await this.operations.getCoins({\n      ...validatePaginationArgs({\n        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT,\n        inputArgs: paginationArgs\n      }),\n      filter: { owner: ownerAddress.toB256(), assetId: assetId && hexlify17(assetId) }\n    });\n    const coins = edges.map(({ node }) => ({\n      id: node.utxoId,\n      assetId: node.assetId,\n      amount: bn18(node.amount),\n      owner: ownerAddress,\n      blockCreated: bn18(node.blockCreated),\n      txCreatedIdx: bn18(node.txCreatedIdx)\n    }));\n    return {\n      coins,\n      pageInfo\n    };\n  }\n  /**\n   * Returns resources for the given owner satisfying the spend query.\n   *\n   * @param owner - The address to get resources for.\n   * @param quantities - The coin quantities to get.\n   * @param resourcesIdsToIgnore - IDs of excluded resources from the selection (optional).\n   * @returns A promise that resolves to the resources.\n   */\n  async getResourcesToSpend(owner, quantities, resourcesIdsToIgnore) {\n    const ownerAddress = new Address2(owner);\n    const excludedIds = await this.adjustResourcesToIgnoreForAddresses(\n      [ownerAddress.b256Address],\n      resourcesIdsToIgnore\n    );\n    const coinsQuery = {\n      owner: ownerAddress.toB256(),\n      queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({\n        assetId: hexlify17(assetId),\n        amount: (amount.eqn(0) ? bn18(1) : amount).toString(10),\n        max: maxPerAsset ? maxPerAsset.toString(10) : void 0\n      })),\n      excludedIds\n    };\n    const result = await this.operations.getCoinsToSpend(coinsQuery);\n    const coins = result.coinsToSpend.flat().map((coin) => {\n      switch (coin.type) {\n        case \"MessageCoin\":\n          return {\n            amount: bn18(coin.amount),\n            assetId: coin.assetId,\n            daHeight: bn18(coin.daHeight),\n            sender: new Address2(coin.sender),\n            recipient: new Address2(coin.recipient),\n            nonce: coin.nonce\n          };\n        case \"Coin\":\n          return {\n            id: coin.utxoId,\n            amount: bn18(coin.amount),\n            assetId: coin.assetId,\n            owner: ownerAddress,\n            blockCreated: bn18(coin.blockCreated),\n            txCreatedIdx: bn18(coin.txCreatedIdx)\n          };\n        default:\n          return null;\n      }\n    }).filter((v) => !!v);\n    return coins;\n  }\n  /**\n   * Returns an array of blobIds that exist on chain, for a given array of blobIds.\n   *\n   * @param blobIds - blobIds to check.\n   * @returns - A promise that resolves to an array of blobIds that exist on chain.\n   */\n  async getBlobs(blobIds) {\n    const res = await this.operations.getBlobs({ blobIds });\n    const blobs = [];\n    Object.keys(res).forEach((key) => {\n      const val = res[key];\n      blobs.push(val?.id ?? null);\n    });\n    return blobs.filter((v) => v);\n  }\n  /**\n   * Returns block matching the given ID or height.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block or null.\n   */\n  async getBlock(idOrHeight) {\n    let block;\n    if (idOrHeight === \"latest\") {\n      const {\n        chain: { latestBlock }\n      } = await this.operations.getLatestBlock();\n      block = latestBlock;\n    } else {\n      const isblockId = typeof idOrHeight === \"string\" && isB256(idOrHeight);\n      const variables = isblockId ? { blockId: idOrHeight } : { height: bn18(idOrHeight).toString(10) };\n      const response = await this.operations.getBlock(variables);\n      block = response.block;\n    }\n    if (!block) {\n      return null;\n    }\n    const { header, height, id, transactions } = block;\n    return {\n      id,\n      height: bn18(height),\n      time: header.time,\n      header: {\n        applicationHash: header.applicationHash,\n        daHeight: bn18(header.daHeight),\n        eventInboxRoot: header.eventInboxRoot,\n        messageOutboxRoot: header.messageOutboxRoot,\n        prevRoot: header.prevRoot,\n        stateTransitionBytecodeVersion: header.stateTransitionBytecodeVersion,\n        transactionsCount: header.transactionsCount,\n        transactionsRoot: header.transactionsRoot\n      },\n      transactionIds: transactions.map((tx) => tx.id)\n    };\n  }\n  /**\n   * Returns all the blocks matching the given parameters.\n   *\n   * @param params - The parameters to query blocks.\n   * @returns A promise that resolves to the blocks.\n   */\n  async getBlocks(params) {\n    const {\n      blocks: { edges, pageInfo }\n    } = await this.operations.getBlocks({\n      ...validatePaginationArgs({\n        paginationLimit: BLOCKS_PAGE_SIZE_LIMIT,\n        inputArgs: params\n      })\n    });\n    const blocks = edges.map(({ node: block }) => ({\n      id: block.id,\n      height: bn18(block.height),\n      time: block.header.time,\n      header: {\n        applicationHash: block.header.applicationHash,\n        daHeight: bn18(block.header.daHeight),\n        eventInboxRoot: block.header.eventInboxRoot,\n        messageOutboxRoot: block.header.messageOutboxRoot,\n        prevRoot: block.header.prevRoot,\n        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,\n        transactionsCount: block.header.transactionsCount,\n        transactionsRoot: block.header.transactionsRoot\n      },\n      transactionIds: block.transactions.map((tx) => tx.id)\n    }));\n    return { blocks, pageInfo };\n  }\n  /**\n   * Returns block matching the given ID or type, including transaction data.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block.\n   */\n  async getBlockWithTransactions(idOrHeight) {\n    let variables;\n    if (typeof idOrHeight === \"number\") {\n      variables = { blockHeight: bn18(idOrHeight).toString(10) };\n    } else if (idOrHeight === \"latest\") {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else if (typeof idOrHeight === \"string\" && isB256(idOrHeight)) {\n      variables = { blockId: idOrHeight };\n    } else {\n      variables = { blockHeight: bn18(idOrHeight).toString() };\n    }\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n    if (!block) {\n      return null;\n    }\n    return {\n      id: block.id,\n      height: bn18(block.height, 10),\n      time: block.header.time,\n      header: {\n        applicationHash: block.header.applicationHash,\n        daHeight: bn18(block.header.daHeight),\n        eventInboxRoot: block.header.eventInboxRoot,\n        messageOutboxRoot: block.header.messageOutboxRoot,\n        prevRoot: block.header.prevRoot,\n        stateTransitionBytecodeVersion: block.header.stateTransitionBytecodeVersion,\n        transactionsCount: block.header.transactionsCount,\n        transactionsRoot: block.header.transactionsRoot\n      },\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder7().decode(arrayify13(tx.rawPayload), 0)?.[0]\n      )\n    };\n  }\n  /**\n   * Get transaction with the given ID.\n   *\n   * @param transactionId - ID of the transaction.\n   * @returns A promise that resolves to the transaction.\n   */\n  async getTransaction(transactionId) {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    try {\n      return new TransactionCoder7().decode(\n        arrayify13(transaction.rawPayload),\n        0\n      )?.[0];\n    } catch (error) {\n      if (error instanceof FuelError19 && error.code === ErrorCode17.UNSUPPORTED_TRANSACTION_TYPE) {\n        console.warn(\"Unsupported transaction type encountered\");\n        return null;\n      }\n      throw error;\n    }\n  }\n  /**\n   * Retrieves transactions based on the provided pagination arguments.\n   * @param paginationArgs - The pagination arguments for retrieving transactions.\n   * @returns A promise that resolves to an object containing the retrieved transactions and pagination information.\n   */\n  async getTransactions(paginationArgs) {\n    const {\n      transactions: { edges, pageInfo }\n    } = await this.operations.getTransactions({\n      ...validatePaginationArgs({\n        inputArgs: paginationArgs,\n        paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT\n      })\n    });\n    const coder = new TransactionCoder7();\n    const transactions = edges.map(({ node: { rawPayload } }) => {\n      try {\n        return coder.decode(arrayify13(rawPayload), 0)[0];\n      } catch (error) {\n        if (error instanceof FuelError19 && error.code === ErrorCode17.UNSUPPORTED_TRANSACTION_TYPE) {\n          console.warn(\"Unsupported transaction type encountered\");\n          return null;\n        }\n        throw error;\n      }\n    }).filter((tx) => tx !== null);\n    return { transactions, pageInfo };\n  }\n  /**\n   * Fetches a compressed block at the specified height.\n   *\n   * @param height - The height of the block to fetch.\n   * @returns The compressed block if available, otherwise `null`.\n   */\n  async daCompressedBlock(height) {\n    const { daCompressedBlock } = await this.operations.daCompressedBlock({\n      height\n    });\n    if (!daCompressedBlock) {\n      return null;\n    }\n    return daCompressedBlock;\n  }\n  /**\n   * Get deployed contract with the given ID.\n   *\n   * @param contractId - ID of the contract.\n   * @returns A promise that resolves to the contract.\n   */\n  async getContract(contractId) {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n  /**\n   * Returns the balance for the given contract for the given asset ID.\n   *\n   * @param contractId - The contract ID to get the balance for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getContractBalance(contractId, assetId) {\n    const { contractBalance } = await this.operations.getContractBalance({\n      contract: new Address2(contractId).toB256(),\n      asset: hexlify17(assetId)\n    });\n    return bn18(contractBalance.amount, 10);\n  }\n  /**\n   * Returns the balance for the given owner for the given asset ID.\n   *\n   * @param owner - The address to get coins for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getBalance(owner, assetId) {\n    const { balance } = await this.operations.getBalanceV2({\n      owner: new Address2(owner).toB256(),\n      assetId: hexlify17(assetId)\n    });\n    return bn18(balance.amountU128, 10);\n  }\n  /**\n   * Returns balances for the given owner.\n   *\n   * @param owner - The address to get coins for.\n   * @param paginationArgs - Pagination arguments (optional).\n   * @returns A promise that resolves to the balances.\n   */\n  async getBalances(owner, paginationArgs) {\n    let args = { first: NON_PAGINATED_BALANCES_SIZE };\n    const { balancesPagination: supportsPagination } = await this.getNodeFeatures();\n    if (supportsPagination) {\n      args = validatePaginationArgs({\n        inputArgs: paginationArgs,\n        paginationLimit: BALANCES_PAGE_SIZE_LIMIT\n      });\n    }\n    const {\n      balances: { edges, pageInfo }\n    } = await this.operations.getBalancesV2({\n      ...args,\n      filter: { owner: new Address2(owner).toB256() },\n      supportsPagination\n    });\n    const balances = edges.map(({ node }) => ({\n      assetId: node.assetId,\n      amount: bn18(node.amountU128)\n    }));\n    return {\n      balances,\n      ...supportsPagination ? { pageInfo } : {}\n    };\n  }\n  /**\n   * Returns message for the given address.\n   *\n   * @param address - The address to get message from.\n   * @param paginationArgs - Pagination arguments (optional).\n   * @returns A promise that resolves to the messages.\n   */\n  async getMessages(address, paginationArgs) {\n    const {\n      messages: { edges, pageInfo }\n    } = await this.operations.getMessages({\n      ...validatePaginationArgs({\n        inputArgs: paginationArgs,\n        paginationLimit: RESOURCES_PAGE_SIZE_LIMIT\n      }),\n      owner: new Address2(address).toB256()\n    });\n    const messages = edges.map(({ node }) => ({\n      messageId: InputMessageCoder2.getMessageId({\n        sender: node.sender,\n        recipient: node.recipient,\n        nonce: node.nonce,\n        amount: bn18(node.amount),\n        data: node.data\n      }),\n      sender: new Address2(node.sender),\n      recipient: new Address2(node.recipient),\n      nonce: node.nonce,\n      amount: bn18(node.amount),\n      data: InputMessageCoder2.decodeData(node.data),\n      daHeight: bn18(node.daHeight)\n    }));\n    return {\n      messages,\n      pageInfo\n    };\n  }\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param transactionId - The transaction to get message from.\n   * @param messageId - The message id from MessageOut receipt.\n   * @param commitBlockId - The commit block id (optional).\n   * @param commitBlockHeight - The commit block height (optional).\n   * @returns A promise that resolves to the message proof.\n   */\n  async getMessageProof(transactionId, nonce, commitBlockId, commitBlockHeight) {\n    let inputObject = {\n      transactionId,\n      nonce\n    };\n    if (commitBlockId && commitBlockHeight) {\n      throw new FuelError19(\n        ErrorCode17.INVALID_INPUT_PARAMETERS,\n        \"commitBlockId and commitBlockHeight cannot be used together\"\n      );\n    }\n    if (commitBlockId) {\n      inputObject = {\n        ...inputObject,\n        commitBlockId\n      };\n    }\n    if (commitBlockHeight) {\n      inputObject = {\n        ...inputObject,\n        // Convert BN into a number string required on the query\n        // This should probably be fixed on the fuel client side\n        commitBlockHeight: commitBlockHeight.toNumber().toString()\n      };\n    }\n    const result = await this.operations.getMessageProof(inputObject);\n    const {\n      messageProof,\n      messageBlockHeader,\n      commitBlockHeader,\n      blockProof,\n      sender,\n      recipient,\n      amount,\n      data\n    } = result.messageProof;\n    return {\n      messageProof: {\n        proofIndex: bn18(messageProof.proofIndex),\n        proofSet: messageProof.proofSet\n      },\n      blockProof: {\n        proofIndex: bn18(blockProof.proofIndex),\n        proofSet: blockProof.proofSet\n      },\n      messageBlockHeader: {\n        id: messageBlockHeader.id,\n        daHeight: bn18(messageBlockHeader.daHeight),\n        transactionsCount: Number(messageBlockHeader.transactionsCount),\n        transactionsRoot: messageBlockHeader.transactionsRoot,\n        height: bn18(messageBlockHeader.height),\n        prevRoot: messageBlockHeader.prevRoot,\n        time: messageBlockHeader.time,\n        applicationHash: messageBlockHeader.applicationHash,\n        messageReceiptCount: Number(messageBlockHeader.messageReceiptCount),\n        messageOutboxRoot: messageBlockHeader.messageOutboxRoot,\n        consensusParametersVersion: Number(messageBlockHeader.consensusParametersVersion),\n        eventInboxRoot: messageBlockHeader.eventInboxRoot,\n        stateTransitionBytecodeVersion: Number(messageBlockHeader.stateTransitionBytecodeVersion)\n      },\n      commitBlockHeader: {\n        id: commitBlockHeader.id,\n        daHeight: bn18(commitBlockHeader.daHeight),\n        transactionsCount: Number(commitBlockHeader.transactionsCount),\n        transactionsRoot: commitBlockHeader.transactionsRoot,\n        height: bn18(commitBlockHeader.height),\n        prevRoot: commitBlockHeader.prevRoot,\n        time: commitBlockHeader.time,\n        applicationHash: commitBlockHeader.applicationHash,\n        messageReceiptCount: Number(commitBlockHeader.messageReceiptCount),\n        messageOutboxRoot: commitBlockHeader.messageOutboxRoot,\n        consensusParametersVersion: Number(commitBlockHeader.consensusParametersVersion),\n        eventInboxRoot: commitBlockHeader.eventInboxRoot,\n        stateTransitionBytecodeVersion: Number(commitBlockHeader.stateTransitionBytecodeVersion)\n      },\n      sender: new Address2(sender),\n      recipient: new Address2(recipient),\n      nonce,\n      amount: bn18(amount),\n      data\n    };\n  }\n  /**\n   * Get the latest gas price from the node.\n   *\n   * @returns A promise that resolves to the latest gas price.\n   */\n  async getLatestGasPrice() {\n    const { latestGasPrice } = await this.operations.getLatestGasPrice();\n    return bn18(latestGasPrice.gasPrice);\n  }\n  /**\n   * Returns the estimate gas price for the given block horizon.\n   *\n   * @param blockHorizon - The block horizon to estimate gas price for.\n   * @returns A promise that resolves to the estimated gas price.\n   */\n  async estimateGasPrice(blockHorizon) {\n    const { estimateGasPrice } = await this.operations.estimateGasPrice({\n      blockHorizon: String(blockHorizon)\n    });\n    return bn18(estimateGasPrice.gasPrice);\n  }\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param nonce - The nonce of the message to get status from.\n   * @returns A promise that resolves to the message status\n   */\n  async getMessageStatus(nonce) {\n    const result = await this.operations.getMessageStatus({ nonce });\n    return result.messageStatus;\n  }\n  /**\n   * Lets you produce blocks with custom timestamps and the block number of the last block produced.\n   *\n   * @param amount - The amount of blocks to produce.\n   * @param startTime - The UNIX timestamp (milliseconds) to set for the first produced block (optional).\n   * @returns A promise that resolves to the block number of the last produced block.\n   */\n  async produceBlocks(amount, startTime) {\n    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({\n      blocksToProduce: bn18(amount).toString(10),\n      startTimestamp: startTime ? DateTime2.fromUnixMilliseconds(startTime).toTai64() : void 0\n    });\n    return bn18(latestBlockHeight);\n  }\n  /**\n   * Check if the given ID is an account.\n   *\n   * @param id - The ID to check.\n   * @returns A promise that resolves to the result of the check.\n   */\n  async isUserAccount(id) {\n    const type = await this.getAddressType(id);\n    return type === \"Account\";\n  }\n  /**\n   * Determines the type of address based on the provided ID.\n   *\n   * @param id - The ID to be checked.\n   * @returns A promise that resolves to a string indicating the type of address.\n   */\n  async getAddressType(id) {\n    const { contract, blob, transaction } = await this.operations.isUserAccount({\n      blobId: id,\n      contractId: id,\n      transactionId: id\n    });\n    if (contract) {\n      return \"Contract\";\n    }\n    if (blob) {\n      return \"Blob\";\n    }\n    if (transaction) {\n      return \"Transaction\";\n    }\n    try {\n      const asset = await this.getAssetDetails(id);\n      if (asset) {\n        return \"Asset\";\n      }\n    } catch (e) {\n    }\n    return \"Account\";\n  }\n  /**\n   * Get the transaction response for the given transaction ID.\n   *\n   * @param transactionId - The transaction ID to get the response for.\n   * @returns A promise that resolves to the transaction response.\n   */\n  async getTransactionResponse(transactionId) {\n    const chainId = await this.getChainId();\n    return new TransactionResponse({\n      transactionRequestOrId: transactionId,\n      provider: this,\n      chainId\n    });\n  }\n  /**\n   * Returns Message for given nonce.\n   *\n   * @param nonce - The nonce of the message to retrieve.\n   * @returns A promise that resolves to the Message object or null.\n   */\n  async getMessageByNonce(nonce) {\n    const { message: rawMessage } = await this.operations.getMessageByNonce({ nonce });\n    if (!rawMessage) {\n      return null;\n    }\n    const message = {\n      messageId: InputMessageCoder2.getMessageId({\n        sender: rawMessage.sender,\n        recipient: rawMessage.recipient,\n        nonce,\n        amount: bn18(rawMessage.amount),\n        data: rawMessage.data\n      }),\n      sender: new Address2(rawMessage.sender),\n      recipient: new Address2(rawMessage.recipient),\n      nonce,\n      amount: bn18(rawMessage.amount),\n      data: InputMessageCoder2.decodeData(rawMessage.data),\n      daHeight: bn18(rawMessage.daHeight)\n    };\n    return message;\n  }\n  /**\n   * Get the relayed transaction for the given transaction ID.\n   *\n   * @param relayedTransactionId - The relayed transaction ID to get the response for.\n   * @returns A promise that resolves to the relayed transaction.\n   */\n  async getRelayedTransactionStatus(relayedTransactionId) {\n    const { relayedTransactionStatus } = await this.operations.getRelayedTransactionStatus({\n      relayedTransactionId\n    });\n    if (!relayedTransactionStatus) {\n      return null;\n    }\n    return relayedTransactionStatus;\n  }\n  /**\n   * @hidden\n   */\n  extractDryRunError(transactionRequest, receipts, reason) {\n    let logs = [];\n    let groupedLogs = {};\n    let abis;\n    if (transactionRequest.type === TransactionType11.Script && transactionRequest.abis) {\n      ({ logs, groupedLogs } = getAllDecodedLogs({\n        receipts,\n        mainAbi: transactionRequest.abis.main,\n        externalAbis: transactionRequest.abis.otherContractsAbis\n      }));\n      abis = transactionRequest.abis;\n    }\n    return extractTxError({\n      logs,\n      groupedLogs,\n      receipts,\n      statusReason: reason,\n      abis\n    });\n  }\n  /**\n   * @hidden\n   */\n  async getNodeFeatures() {\n    const { indexation } = await this.getNode();\n    return {\n      assetMetadata: Boolean(indexation?.assetMetadata),\n      balancesPagination: Boolean(indexation?.balances),\n      coinsToSpend: Boolean(indexation?.coinsToSpend)\n    };\n  }\n  /**\n   * @hidden\n   */\n  parseEstimatePredicatesResponse(transactionRequest, { inputs }) {\n    if (inputs) {\n      inputs.forEach((input, i) => {\n        if (input && \"predicateGasUsed\" in input && bn18(input.predicateGasUsed).gt(0)) {\n          transactionRequest.inputs[i].predicateGasUsed = input.predicateGasUsed;\n        }\n      });\n    }\n    return transactionRequest;\n  }\n  /**\n   * @hidden\n   *\n   * This helper adjusts the resources to be excluded for a given set of addresses.\n   * Supporting multiple addresses is important because of the `assembleTx` method,\n   * which may be invoked with different addresses. It handles both messages and UTXOs,\n   * ensuring the total number of inputs does not exceed the maximum allowed by the chain's\n   * consensus parameters. The resources specified in the `resourcesIdsToIgnore` parameter have priority\n   * over those retrieved from the cache.\n   */\n  async adjustResourcesToIgnoreForAddresses(addresses, resourcesIdsToIgnore) {\n    const final = {\n      messages: resourcesIdsToIgnore?.messages?.map((nonce) => hexlify17(nonce)) || [],\n      utxos: resourcesIdsToIgnore?.utxos?.map((id) => hexlify17(id)) || []\n    };\n    if (this.cache) {\n      const cache2 = this.cache;\n      const allCached = addresses.map((address) => cache2.getActiveData(address));\n      const {\n        consensusParameters: {\n          txParameters: { maxInputs: maxInputsBn }\n        }\n      } = await this.getChain();\n      const maxInputs = maxInputsBn.toNumber();\n      for (let i = 0; i < allCached.length; i++) {\n        let total = final.utxos.length + final.messages.length;\n        if (total >= maxInputs) {\n          break;\n        }\n        final.utxos = [...final.utxos, ...allCached[i].utxos.slice(0, maxInputs - total)];\n        total = final.utxos.length + final.messages.length;\n        if (total >= maxInputs) {\n          break;\n        }\n        final.messages = [...final.messages, ...allCached[i].messages.slice(0, maxInputs - total)];\n      }\n    }\n    return final;\n  }\n};\n\n// src/providers/transaction-summary/get-transaction-summary.ts\nimport { ErrorCode as ErrorCode18, FuelError as FuelError20 } from \"@fuel-ts/errors\";\nimport { bn as bn19 } from \"@fuel-ts/math\";\nimport { TransactionCoder as TransactionCoder8 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify14 } from \"@fuel-ts/utils\";\nasync function getTransactionSummary(params) {\n  const { id, provider, abiMap } = params;\n  const { transaction: gqlTransaction } = await provider.operations.getTransactionWithReceipts({\n    transactionId: id\n  });\n  if (!gqlTransaction) {\n    throw new FuelError20(\n      ErrorCode18.TRANSACTION_NOT_FOUND,\n      `Transaction not found for given id: ${id}.`\n    );\n  }\n  const [decodedTransaction] = new TransactionCoder8().decode(\n    arrayify14(gqlTransaction.rawPayload),\n    0\n  );\n  let txReceipts = [];\n  if (gqlTransaction?.status && \"receipts\" in gqlTransaction.status) {\n    txReceipts = gqlTransaction.status.receipts;\n  }\n  const receipts = txReceipts.map(deserializeReceipt);\n  const {\n    consensusParameters: {\n      feeParameters: { gasPerByte, gasPriceFactor },\n      txParameters: { maxInputs, maxGasPerTx },\n      gasCosts\n    }\n  } = await provider.getChain();\n  const totalFee = getTotalFeeFromStatus(gqlTransaction.status);\n  const gasPrice = totalFee ? bn19(0) : await provider.getLatestGasPrice();\n  const baseAssetId = await provider.getBaseAssetId();\n  const transactionInfo = assembleTransactionSummary({\n    id: gqlTransaction.id,\n    receipts,\n    transaction: decodedTransaction,\n    transactionBytes: arrayify14(gqlTransaction.rawPayload),\n    gqlTransactionStatus: gqlTransaction.status,\n    gasPerByte: bn19(gasPerByte),\n    gasPriceFactor: bn19(gasPriceFactor),\n    abiMap,\n    maxInputs,\n    gasCosts,\n    maxGasPerTx,\n    gasPrice,\n    baseAssetId\n  });\n  return {\n    ...transactionInfo\n  };\n}\n__name(getTransactionSummary, \"getTransactionSummary\");\nasync function getTransactionSummaryFromRequest(params) {\n  const { provider, transactionRequest, abiMap } = params;\n  const { receipts } = await provider.dryRun(transactionRequest);\n  const { gasPerByte, gasPriceFactor, gasCosts, maxGasPerTx } = await provider.getGasConfig();\n  const maxInputs = (await provider.getChain()).consensusParameters.txParameters.maxInputs;\n  const transaction = transactionRequest.toTransaction();\n  const transactionBytes = transactionRequest.toTransactionBytes();\n  const gasPrice = await provider.getLatestGasPrice();\n  const baseAssetId = await provider.getBaseAssetId();\n  const transactionSummary = assembleTransactionSummary({\n    id: transactionRequest.getTransactionId(await provider.getChainId()),\n    receipts,\n    transaction,\n    transactionBytes,\n    abiMap,\n    gasPerByte,\n    gasPriceFactor,\n    maxInputs,\n    gasCosts,\n    maxGasPerTx,\n    gasPrice,\n    baseAssetId\n  });\n  return transactionSummary;\n}\n__name(getTransactionSummaryFromRequest, \"getTransactionSummaryFromRequest\");\nasync function getTransactionsSummaries(params) {\n  const { filters, provider, abiMap } = params;\n  const { owner, ...inputArgs } = filters;\n  const validPaginationParams = validatePaginationArgs({\n    inputArgs,\n    paginationLimit: TRANSACTIONS_PAGE_SIZE_LIMIT\n  });\n  const { transactionsByOwner } = await provider.operations.getTransactionsByOwner({\n    ...validPaginationParams,\n    owner\n  });\n  const { edges, pageInfo } = transactionsByOwner;\n  const {\n    consensusParameters: {\n      feeParameters: { gasPerByte, gasPriceFactor },\n      txParameters: { maxInputs, maxGasPerTx },\n      gasCosts\n    }\n  } = await provider.getChain();\n  const gasPrice = await provider.getLatestGasPrice();\n  const baseAssetId = await provider.getBaseAssetId();\n  const transactions = edges.map((edge) => {\n    const { node: gqlTransaction } = edge;\n    const { id, rawPayload, status } = gqlTransaction;\n    const [decodedTransaction] = new TransactionCoder8().decode(arrayify14(rawPayload), 0);\n    let txReceipts = [];\n    if (gqlTransaction?.status && \"receipts\" in gqlTransaction.status) {\n      txReceipts = gqlTransaction.status.receipts;\n    }\n    const receipts = txReceipts.map(deserializeReceipt);\n    const transactionSummary = assembleTransactionSummary({\n      id,\n      receipts,\n      transaction: decodedTransaction,\n      transactionBytes: arrayify14(rawPayload),\n      gqlTransactionStatus: status,\n      abiMap,\n      gasPerByte,\n      gasPriceFactor,\n      maxInputs,\n      gasCosts,\n      maxGasPerTx,\n      gasPrice,\n      baseAssetId\n    });\n    const output = {\n      ...transactionSummary\n    };\n    return output;\n  });\n  return {\n    transactions,\n    pageInfo\n  };\n}\n__name(getTransactionsSummaries, \"getTransactionsSummaries\");\n\n// src/providers/transaction-summary/assemble-transaction-summary-from-serialized.ts\nimport { bn as bn20 } from \"@fuel-ts/math\";\nimport { TransactionCoder as TransactionCoder9 } from \"@fuel-ts/transactions\";\nimport { arrayify as arrayify15 } from \"@fuel-ts/utils\";\nvar assembleTransactionSummaryFromJson = /* @__PURE__ */ __name(async (opts) => {\n  const { provider, transactionSummary } = opts;\n  const { id, transactionBytes, gasPrice, receipts } = transactionSummary;\n  const {\n    consensusParameters: {\n      baseAssetId,\n      txParameters: { maxInputs, maxGasPerTx },\n      feeParameters: { gasPriceFactor, gasPerByte },\n      gasCosts\n    }\n  } = await provider.getChain();\n  const deserializedTransactionBytes = arrayify15(transactionBytes);\n  const [transaction] = new TransactionCoder9().decode(deserializedTransactionBytes, 0);\n  return assembleTransactionSummary({\n    id,\n    transaction,\n    transactionBytes: deserializedTransactionBytes,\n    receipts: receipts.map(deserializeReceipt),\n    gasPrice: bn20(gasPrice),\n    // From chain\n    baseAssetId,\n    maxInputs,\n    gasCosts,\n    maxGasPerTx,\n    gasPerByte,\n    gasPriceFactor\n  });\n}, \"assembleTransactionSummaryFromJson\");\n\n// src/providers/utils/transaction-response-serialization.ts\nvar serializeTransactionResponseJson = /* @__PURE__ */ __name(async (response) => {\n  const { id, status, abis, request: request2, provider, gqlTransaction, preConfirmationStatus } = response;\n  return {\n    id,\n    status,\n    abis,\n    requestJson: request2 ? JSON.stringify(request2.toJSON()) : void 0,\n    providerUrl: provider.url,\n    providerCache: await serializeProviderCache(provider),\n    gqlTransaction,\n    preConfirmationStatus\n  };\n}, \"serializeTransactionResponseJson\");\nvar deserializeTransactionResponseJson = /* @__PURE__ */ __name((json) => {\n  const {\n    id,\n    abis,\n    status,\n    providerUrl,\n    requestJson,\n    providerCache,\n    gqlTransaction,\n    preConfirmationStatus\n  } = json;\n  const provider = new Provider(providerUrl, { cache: providerCache });\n  const { chainId } = providerCache.chain.consensusParameters;\n  const response = new TransactionResponse({\n    transactionRequestOrId: id,\n    provider,\n    chainId: Number(chainId),\n    abis\n  });\n  if (requestJson) {\n    response.request = transactionRequestify(JSON.parse(requestJson));\n  }\n  response.status = status;\n  response.gqlTransaction = gqlTransaction;\n  response.preConfirmationStatus = preConfirmationStatus;\n  return response;\n}, \"deserializeTransactionResponseJson\");\n\n// src/types.ts\nvar AbstractAccount = class {\n  static {\n    __name(this, \"AbstractAccount\");\n  }\n};\n\n// src/utils/consolidate-coins.ts\nimport { Address as Address3 } from \"@fuel-ts/address\";\nimport { ErrorCode as ErrorCode19, FuelError as FuelError21 } from \"@fuel-ts/errors\";\nimport { bn as bn21 } from \"@fuel-ts/math\";\nimport { OutputType as OutputType9 } from \"@fuel-ts/transactions\";\nimport { splitEvery } from \"ramda\";\nvar CONSOLIDATABLE_ERROR_CODES = [ErrorCode19.MAX_COINS_REACHED];\nvar consolidateCoinsIfRequired = /* @__PURE__ */ __name(async (opts) => {\n  const { error: errorUnknown, account, skipAutoConsolidation = false } = opts;\n  if (skipAutoConsolidation) {\n    return false;\n  }\n  const error = FuelError21.parse(errorUnknown);\n  if (CONSOLIDATABLE_ERROR_CODES.includes(error.code)) {\n    const { assetId, owner } = error.metadata;\n    return account.startConsolidation({\n      owner,\n      assetId\n    });\n  }\n  return false;\n}, \"consolidateCoinsIfRequired\");\nvar getAllCoins = /* @__PURE__ */ __name(async (account, assetId) => {\n  const all = [];\n  let hasNextPage = true;\n  let after;\n  while (hasNextPage) {\n    const { coins, pageInfo } = await account.getCoins(assetId, { after });\n    all.push(...coins);\n    after = coins.pop()?.id;\n    hasNextPage = pageInfo.hasNextPage;\n  }\n  return { coins: all };\n}, \"getAllCoins\");\nvar sortCoins = /* @__PURE__ */ __name(({ coins }) => coins.sort((a, b) => b.amount.cmp(a.amount)), \"sortCoins\");\nvar createOuputCoin = /* @__PURE__ */ __name((opts) => {\n  const { transactionId, outputs, baseAssetId } = opts;\n  const outputChangeIndex = outputs.findIndex(\n    (output) => output.type === OutputType9.Change && output.assetId === baseAssetId\n  );\n  if (outputChangeIndex === -1) {\n    throw new FuelError21(ErrorCode19.UNKNOWN, \"No change output found\");\n  }\n  const outputCoin = outputs[outputChangeIndex];\n  const outputIndexPadded = Number(outputChangeIndex).toString().padStart(4, \"0\");\n  return {\n    id: `${transactionId}${outputIndexPadded}`,\n    assetId: outputCoin.assetId,\n    amount: outputCoin.amount,\n    owner: new Address3(outputCoin.to),\n    blockCreated: bn21(0),\n    txCreatedIdx: bn21(0)\n  };\n}, \"createOuputCoin\");\nvar consolidateCoins = /* @__PURE__ */ __name(async ({\n  account,\n  assetId\n}) => {\n  const chainInfo = await account.provider.getChain();\n  const chainId = chainInfo.consensusParameters.chainId.toNumber();\n  const gasPrice = await account.provider.estimateGasPrice(10);\n  const maxInputs = chainInfo.consensusParameters.txParameters.maxInputs.toNumber();\n  const baseAssetId = await account.provider.getBaseAssetId();\n  const isBaseAsset = assetId === baseAssetId;\n  const batchSize = maxInputs;\n  const numberOfFundingCoins = maxInputs;\n  let funding = [];\n  let dust = [];\n  if (isBaseAsset) {\n    const coins = await getAllCoins(account, baseAssetId).then(sortCoins);\n    funding = coins.slice(0, numberOfFundingCoins);\n    dust = coins.slice(numberOfFundingCoins);\n  } else {\n    funding = await getAllCoins(account, baseAssetId).then(sortCoins).then((coins) => coins.slice(0, numberOfFundingCoins));\n    dust = await getAllCoins(account, assetId).then(({ coins }) => coins);\n  }\n  if (funding.length === 0) {\n    throw new FuelError21(\n      ErrorCode19.INSUFFICIENT_FUNDS,\n      `Insufficient funds to consolidate.\n\tAsset ID: ${baseAssetId}\n\tOwner: ${account.address.toB256()}`\n    );\n  }\n  const batches = [\n    ...splitEvery(batchSize, funding),\n    // We leave one coin for the funding coin\n    ...splitEvery(batchSize - 1, dust)\n  ];\n  const txs = batches.map((batch) => {\n    const request2 = new ScriptTransactionRequest({\n      scriptData: \"0x\"\n    });\n    request2.addResources(batch);\n    return request2;\n  });\n  const submitAll = /* @__PURE__ */ __name(async (opts = {}) => {\n    const txResponses = [];\n    let previousTx;\n    for (let i = 0; i < txs.length; i++) {\n      let currentTx = txs[i];\n      const step = i + 1;\n      if (previousTx) {\n        const coin = createOuputCoin({\n          transactionId: previousTx.transactionId,\n          outputs: previousTx.outputs,\n          baseAssetId\n        });\n        currentTx.addResource(coin);\n      }\n      if (\"populateTransactionPredicateData\" in account && typeof account.populateTransactionPredicateData === \"function\") {\n        currentTx = account.populateTransactionPredicateData(currentTx);\n        currentTx = await account.provider.estimatePredicates(currentTx);\n      }\n      const fee = calculateGasFee({\n        gasPrice,\n        gas: currentTx.calculateMinGas(chainInfo),\n        priceFactor: chainInfo.consensusParameters.feeParameters.gasPriceFactor,\n        tip: currentTx.tip\n      });\n      currentTx.maxFee = fee;\n      currentTx.gasLimit = bn21(1e3);\n      opts.onTransactionStart?.({\n        tx: currentTx,\n        step,\n        assetId,\n        transactionId: currentTx.getTransactionId(chainId)\n      });\n      const response = await account.sendTransaction(currentTx);\n      const result = await response.waitForResult();\n      txResponses.push(result);\n      previousTx = {\n        transactionId: response.id,\n        outputs: result.transaction.outputs\n      };\n    }\n    return {\n      txResponses,\n      errors: []\n    };\n  }, \"submitAll\");\n  return {\n    txs,\n    totalFeeCost: txs.reduce((acc, request2) => acc.add(request2.maxFee), bn21(0)),\n    submitAll\n  };\n}, \"consolidateCoins\");\n\n// src/utils/formatTransferToContractScriptData.ts\nimport { ASSET_ID_LEN, BigNumberCoder as BigNumberCoder3, CONTRACT_ID_LEN, WORD_SIZE } from \"@fuel-ts/abi-coder\";\nimport { Address as Address4 } from \"@fuel-ts/address\";\nimport { arrayify as arrayify16, concat as concat4 } from \"@fuel-ts/utils\";\nimport * as asm from \"@fuels/vm-asm\";\nvar formatTransferToContractScriptData = /* @__PURE__ */ __name((transferParams) => {\n  const numberCoder = new BigNumberCoder3(\"u64\");\n  return transferParams.reduce((acc, transferParam) => {\n    const { assetId, amount, contractId } = transferParam;\n    const encoded = numberCoder.encode(amount);\n    const scriptData = concat4([new Address4(contractId).toBytes(), encoded, arrayify16(assetId)]);\n    return concat4([acc, scriptData]);\n  }, new Uint8Array());\n}, \"formatTransferToContractScriptData\");\nvar assembleTransferToContractScript = /* @__PURE__ */ __name(async (transferParams) => {\n  const scriptData = formatTransferToContractScriptData(transferParams);\n  await asm.initWasm();\n  let script = new Uint8Array();\n  transferParams.forEach((_, i) => {\n    const offset = (CONTRACT_ID_LEN + WORD_SIZE + ASSET_ID_LEN) * i;\n    script = concat4([\n      script,\n      // Load ScriptData into register 0x10.\n      asm.gtf(16, 0, asm.GTFArgs.ScriptData).to_bytes(),\n      // Add the offset to 0x10 so it will point to the current contract ID, store in 0x11.\n      asm.addi(17, 16, offset).to_bytes(),\n      // Add CONTRACT_ID_LEN to 0x11 to point to the amount in the ScriptData, store in 0x12.\n      asm.addi(18, 17, CONTRACT_ID_LEN).to_bytes(),\n      // Load word to the amount at 0x12 into register 0x13.\n      asm.lw(19, 18, 0).to_bytes(),\n      // Add WORD_SIZE to 0x12 to point to the asset ID in the ScriptData, store in 0x14.\n      asm.addi(20, 18, WORD_SIZE).to_bytes(),\n      // Perform the transfer using contract ID in 0x11, amount in 0x13, and asset ID in 0x14.\n      asm.tr(17, 19, 20).to_bytes()\n    ]);\n  });\n  script = concat4([script, asm.ret(1).to_bytes()]);\n  return { script, scriptData };\n}, \"assembleTransferToContractScript\");\n\n// src/utils/split-coins-into-batches.ts\nvar splitCoinsIntoBatches = /* @__PURE__ */ __name((coins, maxBatchLength) => {\n  const batchesNum = Math.ceil(coins.length / maxBatchLength);\n  const batches = [];\n  for (let i = 0; i < batchesNum; i += 1) {\n    const batchStart = i * maxBatchLength;\n    const batchEnd = (i + 1) * maxBatchLength;\n    batches.push(coins.slice(batchStart, batchEnd));\n  }\n  return batches;\n}, \"splitCoinsIntoBatches\");\n\n// src/account.ts\nvar MAX_FUNDING_ATTEMPTS = 5;\nvar Account = class extends AbstractAccount {\n  static {\n    __name(this, \"Account\");\n  }\n  /**\n   * The address associated with the account.\n   */\n  address;\n  /**\n   * The provider used to interact with the network.\n   */\n  _provider;\n  /**\n   * The connector for use with external wallets\n   */\n  _connector;\n  /**\n   * Creates a new Account instance.\n   *\n   * @param address - The address of the account.\n   * @param provider - A Provider instance  (optional).\n   * @param connector - A FuelConnector instance (optional).\n   */\n  constructor(address, provider, connector) {\n    super();\n    this._provider = provider;\n    this._connector = connector;\n    this.address = new Address5(address);\n  }\n  /**\n   * The provider used to interact with the network.\n   *\n   * @returns A Provider instance.\n   *\n   * @throws `FuelError` if the provider is not set.\n   */\n  get provider() {\n    if (!this._provider) {\n      throw new FuelError22(ErrorCode20.MISSING_PROVIDER, \"Provider not set\");\n    }\n    return this._provider;\n  }\n  /**\n   * Sets the provider for the account.\n   *\n   * @param provider - A Provider instance.\n   */\n  set provider(provider) {\n    this._provider = provider;\n  }\n  /**\n   * Changes the provider connection for the account.\n   *\n   * @param provider - A Provider instance.\n   * @returns The updated Provider instance.\n   */\n  connect(provider) {\n    this._provider = provider;\n    return this.provider;\n  }\n  /**\n   * Retrieves resources satisfying the spend query for the account.\n   *\n   * @param quantities - Quantities of resources to be obtained.\n   * @param resourcesIdsToIgnore - IDs of resources to be excluded from the query (optional).\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to an array of Resources.\n   */\n  async getResourcesToSpend(quantities, resourcesIdsToIgnore, { skipAutoConsolidation } = {}) {\n    const getResourcesToSpend = /* @__PURE__ */ __name(() => this.provider.getResourcesToSpend(this.address, quantities, resourcesIdsToIgnore), \"getResourcesToSpend\");\n    try {\n      return await getResourcesToSpend();\n    } catch (error) {\n      const shouldRetry = await consolidateCoinsIfRequired({\n        error,\n        account: this,\n        skipAutoConsolidation\n      });\n      if (!shouldRetry) {\n        throw error;\n      }\n      return await getResourcesToSpend();\n    }\n  }\n  /**\n   * Retrieves coins owned by the account.\n   *\n   * @param assetId - The asset ID of the coins to retrieve (optional).\n   * @returns A promise that resolves to an array of Coins.\n   */\n  async getCoins(assetId, paginationArgs) {\n    return this.provider.getCoins(this.address, assetId, paginationArgs);\n  }\n  /**\n   * Retrieves messages owned by the account.\n   *\n   * @returns A promise that resolves to an array of Messages.\n   */\n  async getMessages(paginationArgs) {\n    return this.provider.getMessages(this.address, paginationArgs);\n  }\n  /**\n   * Retrieves the balance of the account for the given asset.\n   *\n   * @param assetId - The asset ID to check the balance for (optional).\n   * @returns A promise that resolves to the balance amount.\n   */\n  async getBalance(assetId) {\n    const assetIdToFetch = assetId ?? await this.provider.getBaseAssetId();\n    const amount = await this.provider.getBalance(this.address, assetIdToFetch);\n    return amount;\n  }\n  /**\n   * Retrieves all the balances for the account.\n   *\n   * @returns A promise that resolves to an array of Coins and their quantities.\n   */\n  async getBalances() {\n    return this.provider.getBalances(this.address);\n  }\n  /**\n   * Funds a transaction request by adding the necessary resources.\n   *\n   * @typeParam T - The type of the TransactionRequest.\n   * @param request - The transaction request to fund.\n   * @param params - The estimated transaction parameters.\n   * @returns A promise that resolves to the funded transaction request.\n   *\n   * @deprecated Use provider.assembleTx instead\n   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.\n   */\n  async fund(request2, params, { skipAutoConsolidation } = {}) {\n    const {\n      addedSignatures,\n      estimatedPredicates,\n      requiredQuantities,\n      updateMaxFee,\n      gasPrice,\n      transactionSummary\n    } = params;\n    const chainId = await this.provider.getChainId();\n    const fee = request2.maxFee;\n    const baseAssetId = await this.provider.getBaseAssetId();\n    const requiredInBaseAsset = requiredQuantities.find((quantity) => quantity.assetId === baseAssetId)?.amount || bn22(0);\n    const requiredQuantitiesWithFee = addAmountToCoinQuantities({\n      amount: bn22(fee),\n      assetId: baseAssetId,\n      coinQuantities: requiredQuantities\n    });\n    const quantitiesDict = {};\n    requiredQuantitiesWithFee.forEach(({ amount, assetId }) => {\n      quantitiesDict[assetId] = {\n        required: amount,\n        owned: bn22(0)\n      };\n    });\n    request2.inputs.filter(isRequestInputResource).forEach((input) => {\n      const isCoin2 = isRequestInputCoin(input);\n      const assetId = isCoin2 ? String(input.assetId) : baseAssetId;\n      if (quantitiesDict[assetId]) {\n        quantitiesDict[assetId].owned = quantitiesDict[assetId].owned.add(input.amount);\n      }\n    });\n    let missingQuantities = [];\n    Object.entries(quantitiesDict).forEach(([assetId, { owned, required }]) => {\n      if (owned.lt(required)) {\n        missingQuantities.push({\n          assetId,\n          amount: required.sub(owned)\n        });\n      }\n    });\n    let needsToBeFunded = missingQuantities.length > 0;\n    let fundingAttempts = 0;\n    while (needsToBeFunded && fundingAttempts < MAX_FUNDING_ATTEMPTS) {\n      const resources = await this.getResourcesToSpend(\n        missingQuantities,\n        cacheRequestInputsResourcesFromOwner(request2.inputs, this.address),\n        { skipAutoConsolidation }\n      );\n      request2.addResources(resources);\n      request2.updatePredicateGasUsed(estimatedPredicates);\n      const requestToReestimate2 = clone9(request2);\n      if (addedSignatures) {\n        Array.from({ length: addedSignatures }).forEach(\n          () => requestToReestimate2.addEmptyWitness()\n        );\n      }\n      if (!updateMaxFee) {\n        needsToBeFunded = false;\n        break;\n      }\n      const { maxFee: newFee } = await this.provider.estimateTxGasAndFee({\n        transactionRequest: requestToReestimate2,\n        gasPrice\n      });\n      const totalBaseAssetOnInputs = getAssetAmountInRequestInputs(\n        request2.inputs.filter(isRequestInputResource),\n        baseAssetId,\n        baseAssetId\n      );\n      const totalBaseAssetRequiredWithFee = requiredInBaseAsset.add(newFee);\n      if (totalBaseAssetOnInputs.gt(totalBaseAssetRequiredWithFee)) {\n        needsToBeFunded = false;\n      } else {\n        missingQuantities = [\n          {\n            amount: totalBaseAssetRequiredWithFee.sub(totalBaseAssetOnInputs),\n            assetId: baseAssetId\n          }\n        ];\n      }\n      fundingAttempts += 1;\n    }\n    if (needsToBeFunded) {\n      throw new FuelError22(\n        ErrorCode20.INSUFFICIENT_FUNDS,\n        `The account ${this.address} does not have enough base asset funds to cover the transaction execution.`\n      );\n    }\n    request2.updateState(chainId, \"funded\", transactionSummary);\n    await this.provider.validateTransaction(request2);\n    request2.updatePredicateGasUsed(estimatedPredicates);\n    const requestToReestimate = clone9(request2);\n    if (addedSignatures) {\n      Array.from({ length: addedSignatures }).forEach(() => requestToReestimate.addEmptyWitness());\n    }\n    if (!updateMaxFee) {\n      return request2;\n    }\n    const { maxFee } = await this.provider.estimateTxGasAndFee({\n      transactionRequest: requestToReestimate,\n      gasPrice\n    });\n    request2.maxFee = maxFee;\n    return request2;\n  }\n  /**\n   * A helper that creates a transfer transaction request and returns it.\n   *\n   * @param destination - The address of the destination.\n   * @param amount - The amount of coins to transfer.\n   * @param assetId - The asset ID of the coins to transfer (optional).\n   * @param txParams - The transaction parameters (optional).\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to the prepared transaction request.\n   */\n  async createTransfer(destination, amount, assetId, txParams = {}, { skipAutoConsolidation } = {}) {\n    let request2 = new ScriptTransactionRequest(txParams);\n    request2 = this.addTransfer(request2, {\n      destination,\n      amount,\n      assetId: assetId || await this.provider.getBaseAssetId()\n    });\n    const { gasPrice, transactionRequest } = await this.assembleTx({\n      transactionRequest: request2,\n      skipAutoConsolidation\n    });\n    request2 = await setAndValidateGasAndFeeForAssembledTx({\n      gasPrice,\n      provider: this.provider,\n      transactionRequest,\n      setGasLimit: txParams?.gasLimit,\n      setMaxFee: txParams?.maxFee\n    });\n    return request2;\n  }\n  /**\n   * Transfers coins to a destination address.\n   *\n   * @param destination - The address of the destination.\n   * @param amount - The amount of coins to transfer.\n   * @param assetId - The asset ID of the coins to transfer (optional).\n   * @param txParams - The transaction parameters (optional).\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to the transaction response.\n   */\n  async transfer(destination, amount, assetId, txParams = {}, { skipAutoConsolidation } = {}) {\n    const request2 = await this.createTransfer(destination, amount, assetId, txParams, {\n      skipAutoConsolidation\n    });\n    return this.sendTransaction(request2, { estimateTxDependencies: false });\n  }\n  /**\n   * Transfers multiple amounts of a token to multiple recipients.\n   *\n   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.\n   * @param txParams - Optional transaction parameters.\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to a `TransactionResponse` object representing the transaction result.\n   */\n  async batchTransfer(transferParams, txParams = {}, { skipAutoConsolidation } = {}) {\n    let request2 = new ScriptTransactionRequest(txParams);\n    request2 = this.addBatchTransfer(request2, transferParams);\n    const { gasPrice, transactionRequest } = await this.assembleTx({\n      transactionRequest: request2,\n      skipAutoConsolidation\n    });\n    request2 = await setAndValidateGasAndFeeForAssembledTx({\n      gasPrice,\n      provider: this.provider,\n      transactionRequest,\n      setGasLimit: txParams?.gasLimit,\n      setMaxFee: txParams?.maxFee\n    });\n    return this.sendTransaction(request2, { estimateTxDependencies: false });\n  }\n  /**\n   * Adds a transfer to the given transaction request.\n   *\n   * @param request - The script transaction request to add transfers to.\n   * @param transferParams - The object representing the transfer to be made.\n   * @returns The updated transaction request with the added transfer.\n   */\n  addTransfer(request2, transferParams) {\n    const { destination, amount, assetId } = transferParams;\n    this.validateTransferAmount(amount);\n    request2.addCoinOutput(new Address5(destination), amount, assetId);\n    return request2;\n  }\n  /**\n   * Adds multiple transfers to a script transaction request.\n   *\n   * @param request - The script transaction request to add transfers to.\n   * @param transferParams - An array of `TransferParams` objects representing the transfers to be made.\n   * @returns The updated script transaction request.\n   */\n  addBatchTransfer(request2, transferParams) {\n    transferParams.forEach(({ destination, amount, assetId }) => {\n      this.addTransfer(request2, {\n        destination,\n        amount,\n        assetId\n      });\n    });\n    return request2;\n  }\n  /**\n   * Transfers coins to a contract address.\n   *\n   * @param contractId - The address of the contract.\n   * @param amount - The amount of coins to transfer.\n   * @param assetId - The asset ID of the coins to transfer (optional).\n   * @param txParams - The transaction parameters (optional).\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to the transaction response.\n   */\n  async transferToContract(contractId, amount, assetId, txParams = {}, { skipAutoConsolidation } = {}) {\n    return this.batchTransferToContracts([{ amount, assetId, contractId }], txParams, {\n      skipAutoConsolidation\n    });\n  }\n  async batchTransferToContracts(contractTransferParams, txParams = {}, { skipAutoConsolidation } = {}) {\n    let request2 = new ScriptTransactionRequest({\n      ...txParams\n    });\n    const quantities = [];\n    const defaultAssetId = await this.provider.getBaseAssetId();\n    const transferParams = contractTransferParams.map((transferParam) => {\n      const amount = bn22(transferParam.amount);\n      const contractAddress = new Address5(transferParam.contractId);\n      const assetId = transferParam.assetId ? hexlify18(transferParam.assetId) : defaultAssetId;\n      if (amount.lte(0)) {\n        throw new FuelError22(\n          ErrorCode20.INVALID_TRANSFER_AMOUNT,\n          \"Transfer amount must be a positive number.\"\n        );\n      }\n      request2.addContractInputAndOutput(contractAddress);\n      quantities.push({ amount, assetId });\n      return {\n        amount,\n        contractId: contractAddress.toB256(),\n        assetId\n      };\n    });\n    const { script, scriptData } = await assembleTransferToContractScript(transferParams);\n    request2.script = script;\n    request2.scriptData = scriptData;\n    const { gasPrice, transactionRequest } = await this.assembleTx({\n      transactionRequest: request2,\n      quantities,\n      skipAutoConsolidation\n    });\n    request2 = await setAndValidateGasAndFeeForAssembledTx({\n      gasPrice,\n      provider: this.provider,\n      transactionRequest,\n      setGasLimit: txParams?.gasLimit,\n      setMaxFee: txParams?.maxFee\n    });\n    return this.sendTransaction(request2);\n  }\n  /**\n   * Withdraws an amount of the base asset to the base chain.\n   *\n   * @param recipient - Address of the recipient on the base chain.\n   * @param amount - Amount of base asset.\n   * @param txParams - The transaction parameters (optional).\n   * @param skipAutoConsolidation - Whether to skip the automatic consolidatation of coins process (optional).\n   * @returns A promise that resolves to the transaction response.\n   */\n  async withdrawToBaseLayer(recipient, amount, txParams = {}, { skipAutoConsolidation } = {}) {\n    const recipientAddress = new Address5(recipient);\n    const recipientDataArray = arrayify17(\n      \"0x\".concat(recipientAddress.toHexString().substring(2).padStart(64, \"0\"))\n    );\n    const amountDataArray = arrayify17(\n      \"0x\".concat(bn22(amount).toHex().substring(2).padStart(16, \"0\"))\n    );\n    const script = new Uint8Array([\n      ...arrayify17(withdrawScript.bytes),\n      ...recipientDataArray,\n      ...amountDataArray\n    ]);\n    const params = { script, ...txParams };\n    const baseAssetId = await this.provider.getBaseAssetId();\n    let request2 = new ScriptTransactionRequest(params);\n    const quantities = [{ amount: bn22(amount), assetId: baseAssetId }];\n    const { gasPrice, transactionRequest } = await this.assembleTx({\n      transactionRequest: request2,\n      quantities,\n      skipAutoConsolidation\n    });\n    request2 = await setAndValidateGasAndFeeForAssembledTx({\n      gasPrice,\n      provider: this.provider,\n      transactionRequest,\n      setGasLimit: txParams?.gasLimit,\n      setMaxFee: txParams?.maxFee\n    });\n    return this.sendTransaction(request2);\n  }\n  /**\n   * Start the consolidation process\n   *\n   * @param owner - The B256 address of the owner.\n   * @param assetId - The asset ID that requires consolidation.\n   */\n  async startConsolidation(opts) {\n    if (this._connector) {\n      await this._connector.startConsolidation(opts);\n      return false;\n    }\n    const { owner, assetId } = opts;\n    if (owner !== this.address.toB256()) {\n      return false;\n    }\n    const { submitAll } = await consolidateCoins({ account: this, assetId });\n    await submitAll();\n    return true;\n  }\n  /**\n   * Consolidates base asset UTXOs into fewer, larger ones.\n   *\n   * Retrieves a limited number of base asset coins (as defined by `Provider.RESOURCES_PAGE_SIZE_LIMIT`),\n   * assembles consolidation transactions, and submits them to the network.\n   *\n   * Note: This method currently supports only the base asset.\n   *\n   * @param params - The parameters for coin consolidation, including the asset ID, mode, and output number.\n   * @returns A promise that resolves to the response of the submitted transactions.\n   * @throws Will throw an error if the asset is not a base asset as non-base asset consolidation is not implemented.\n   */\n  async consolidateCoins(params) {\n    const { assetId } = params;\n    const { coins } = await this.getCoins(assetId);\n    const baseAssetId = await this.provider.getBaseAssetId();\n    const isBaseAsset = baseAssetId === assetId;\n    let submitAll;\n    const consolidationParams = {\n      assetId,\n      coins,\n      mode: params.mode,\n      outputNum: params.outputNum\n    };\n    if (isBaseAsset) {\n      ({ submitAll } = await this.assembleBaseAssetConsolidationTxs(consolidationParams));\n    } else {\n      ({ submitAll } = await this.assembleNonBaseAssetConsolidationTxs(consolidationParams));\n    }\n    return submitAll();\n  }\n  /**\n   * Assembles transactions for consolidating base asset coins into fewer UTXOs.\n   *\n   * This method splits the provided coins into batches and creates transaction requests\n   * to consolidate them. It calculates the necessary fee and sets up the transactions\n   * to be submitted either in parallel (default) or sequentially.\n   *\n   * @param params - The parameters for assembling base asset consolidation transactions.\n   *\n   * @returns An object containing the assembled transactions, the total fee cost, and a callback to submit all transactions.\n   */\n  async assembleBaseAssetConsolidationTxs(params) {\n    const { coins, mode = \"parallel\", outputNum = 1 } = params;\n    const baseAssetId = await this.provider.getBaseAssetId();\n    this.validateConsolidationTxsCoins(coins, baseAssetId);\n    const chainInfo = await this.provider.getChain();\n    const maxInputsNumber = chainInfo.consensusParameters.txParameters.maxInputs.toNumber();\n    let totalFeeCost = bn22(0);\n    const txs = [];\n    const coinsBatches = splitCoinsIntoBatches(coins, maxInputsNumber);\n    const gasPrice = await this.provider.estimateGasPrice(10);\n    const consolidateMoreThanOneCoin = outputNum > 1;\n    coinsBatches.filter((batch) => batch.length > 1).forEach((coinBatch) => {\n      const request2 = new ScriptTransactionRequest({\n        script: \"0x\"\n      });\n      request2.addResources(coinBatch);\n      if (consolidateMoreThanOneCoin) {\n        Array.from({ length: outputNum - 1 }).forEach(() => {\n          request2.addCoinOutput(this.address, 0, baseAssetId);\n        });\n      }\n      const minGas = request2.calculateMinGas(chainInfo);\n      const fee = calculateGasFee({\n        gasPrice,\n        gas: minGas,\n        priceFactor: chainInfo.consensusParameters.feeParameters.gasPriceFactor,\n        tip: request2.tip\n      });\n      request2.maxFee = fee;\n      if (consolidateMoreThanOneCoin) {\n        const total = request2.inputs.filter(isRequestInputCoin).reduce((acc, input) => acc.add(input.amount), bn22(0));\n        const amountPerNewUtxo = total.div(outputNum + 1);\n        request2.outputs.forEach((output) => {\n          if (output.type === OutputType10.Coin) {\n            output.amount = amountPerNewUtxo;\n          }\n        });\n      }\n      totalFeeCost = totalFeeCost.add(fee);\n      txs.push(request2);\n    });\n    const submitAll = this.prepareSubmitAll({ txs, mode });\n    return { txs, totalFeeCost, submitAll };\n  }\n  async assembleNonBaseAssetConsolidationTxs(params) {\n    const { assetId, coins, mode = \"parallel\", outputNum = 1 } = params;\n    this.validateConsolidationTxsCoins(coins, assetId);\n    const chainInfo = await this.provider.getChain();\n    const maxInputsNumber = chainInfo.consensusParameters.txParameters.maxInputs.toNumber();\n    const baseAssetId = chainInfo.consensusParameters.baseAssetId;\n    const { coins: baseAssetCoins } = await this.provider.getCoins(this.address, baseAssetId);\n    let totalFeeCost = bn22(0);\n    const txs = [];\n    const gasPrice = await this.provider.estimateGasPrice(10);\n    const consolidateMoreThanOneCoin = outputNum > 1;\n    const assetCoinBatches = splitCoinsIntoBatches(coins, maxInputsNumber);\n    assetCoinBatches.filter((batch) => batch.length > 1).forEach((coinBatch) => {\n      const request2 = new ScriptTransactionRequest({\n        script: \"0x\"\n      });\n      request2.addResources(coinBatch);\n      if (consolidateMoreThanOneCoin) {\n        Array.from({ length: outputNum - 1 }).forEach(() => {\n          request2.addCoinOutput(this.address, 0, assetId);\n        });\n      }\n      const minGas = request2.calculateMinGas(chainInfo);\n      const fee = calculateGasFee({\n        gasPrice,\n        gas: minGas,\n        priceFactor: chainInfo.consensusParameters.feeParameters.gasPriceFactor,\n        tip: request2.tip\n      });\n      request2.maxFee = fee;\n      if (consolidateMoreThanOneCoin) {\n        const total = request2.inputs.filter(isRequestInputCoin).reduce((acc, input) => acc.add(input.amount), bn22(0));\n        const amountPerNewUtxo = total.div(outputNum + 1);\n        request2.outputs.forEach((output) => {\n          if (output.type === OutputType10.Coin) {\n            output.amount = amountPerNewUtxo;\n          }\n        });\n      }\n      totalFeeCost = totalFeeCost.add(fee);\n      const baseAssetResources = [];\n      let fundingFeeTotal = bn22(0);\n      while (fundingFeeTotal.lt(fee)) {\n        const baseAssetCoin = baseAssetCoins.pop();\n        if (!baseAssetCoin) {\n          break;\n        }\n        baseAssetResources.push(baseAssetCoin);\n        fundingFeeTotal = fundingFeeTotal.add(baseAssetCoin.amount);\n      }\n      const { inputs } = request2;\n      request2.inputs = inputs.slice(0, maxInputsNumber - baseAssetResources.length);\n      const removedCoins = coinBatch.slice(maxInputsNumber - baseAssetResources.length);\n      request2.addResources(baseAssetResources);\n      const lastCoinBatch = assetCoinBatches[assetCoinBatches.length - 1];\n      lastCoinBatch.push(...removedCoins);\n      if (lastCoinBatch.length > maxInputsNumber) {\n        assetCoinBatches.push(lastCoinBatch.slice(maxInputsNumber));\n      }\n      txs.push(request2);\n    });\n    const submitAll = this.prepareSubmitAll({ txs, mode });\n    return { txs, totalFeeCost, submitAll };\n  }\n  /**\n   * Prepares a function to submit all transactions either sequentially or in parallel.\n   *\n   * @param params - The parameters for preparing the submitAll callback.\n   *\n   * @returns A callback that, when called, submits all transactions and returns their results and any errors encountered.\n   */\n  prepareSubmitAll = /* @__PURE__ */ __name((params) => {\n    const { txs, mode = \"sequential\" } = params;\n    return async () => {\n      const txResponses = [];\n      const errors = [];\n      if (mode === \"sequential\") {\n        for (const tx of txs) {\n          try {\n            const submit = await this.sendTransaction(tx);\n            const response = await submit.waitForResult();\n            txResponses.push(response);\n          } catch (error) {\n            errors.push(error);\n          }\n        }\n      } else {\n        const results = await Promise.allSettled(\n          txs.map(async (tx) => {\n            const submit = await this.sendTransaction(tx);\n            return submit.waitForResult();\n          })\n        );\n        results.forEach((result) => {\n          if (result.status === \"fulfilled\") {\n            txResponses.push(result.value);\n          } else {\n            errors.push(result.reason);\n          }\n        });\n      }\n      return { txResponses, errors };\n    };\n  }, \"prepareSubmitAll\");\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the transaction.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param transactionCostParams - The transaction cost parameters (optional).\n   *\n   * @returns A promise that resolves to the transaction cost object.\n   *\n   * @deprecated Use provider.assembleTx instead\n   * Check the migration guide https://docs.fuel.network/docs/fuels-ts/transactions/assemble-tx-migration-guide/ for more information.\n   */\n  async getTransactionCost(transactionRequestLike, { signatureCallback, quantities = [], gasPrice } = {}) {\n    const txRequestClone = clone9(transactionRequestify(transactionRequestLike));\n    const baseAssetId = await this.provider.getBaseAssetId();\n    const coinOutputsQuantities = txRequestClone.getCoinOutputsQuantities();\n    const requiredQuantities = mergeQuantities(coinOutputsQuantities, quantities);\n    const transactionFeeForDryRun = [{ assetId: baseAssetId, amount: bn22(\"100000000000000000\") }];\n    const findAssetInput = /* @__PURE__ */ __name((assetId) => txRequestClone.inputs.find((input) => {\n      if (input.type === InputType8.Coin) {\n        return input.assetId === assetId;\n      }\n      if (isRequestInputMessageWithoutData(input)) {\n        return baseAssetId === assetId;\n      }\n      return false;\n    }), \"findAssetInput\");\n    const updateAssetInput = /* @__PURE__ */ __name((assetId, quantity) => {\n      const assetInput = findAssetInput(assetId);\n      const usedQuantity = quantity;\n      if (assetInput && \"amount\" in assetInput) {\n        assetInput.amount = usedQuantity;\n      } else {\n        txRequestClone.addResources(\n          this.generateFakeResources([\n            {\n              amount: quantity,\n              assetId\n            }\n          ])\n        );\n      }\n    }, \"updateAssetInput\");\n    mergeQuantities(requiredQuantities, transactionFeeForDryRun).forEach(\n      ({ amount, assetId }) => updateAssetInput(assetId, amount)\n    );\n    const txCost = await this.provider.getTransactionCost(txRequestClone, {\n      signatureCallback,\n      gasPrice\n    });\n    return {\n      ...txCost,\n      requiredQuantities\n    };\n  }\n  /**\n   * Sign a message from the account via the connector.\n   *\n   * @param message - the message to sign.\n   * @returns a promise that resolves to the signature.\n   *\n   * @hidden\n   */\n  async signMessage(message) {\n    if (!this._connector) {\n      throw new FuelError22(ErrorCode20.MISSING_CONNECTOR, \"A connector is required to sign messages.\");\n    }\n    return this._connector.signMessage(this.address.toString(), message);\n  }\n  /**\n   * Signs a transaction from the account via the connector..\n   *\n   * @param transactionRequestLike - The transaction request to sign.\n   * @returns A promise that resolves to the signature of the transaction.\n   */\n  async signTransaction(transactionRequestLike, connectorOptions = {}) {\n    if (!this._connector) {\n      throw new FuelError22(\n        ErrorCode20.MISSING_CONNECTOR,\n        \"A connector is required to sign transactions.\"\n      );\n    }\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const { transactionRequest: requestToSign, connectorsSendTxParams } = await this.setTransactionStateForConnectors({\n      transactionRequest,\n      connectorOptions\n    });\n    return this._connector.signTransaction(\n      this.address.toString(),\n      requestToSign,\n      connectorsSendTxParams\n    );\n  }\n  /**\n   * Sends a transaction to the network.\n   *\n   * @param transactionRequestLike - The transaction request to be sent.\n   * @param sendTransactionParams - The provider send transaction parameters (optional).\n   * @returns A promise that resolves to the transaction response.\n   */\n  async sendTransaction(transactionRequestLike, { estimateTxDependencies = true, ...connectorOptions } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (this._connector) {\n      const response = await this.setTransactionStateForConnectors({\n        transactionRequest,\n        connectorOptions\n      });\n      const transaction = await this._connector.sendTransaction(\n        this.address.toString(),\n        response.transactionRequest,\n        response.connectorsSendTxParams\n      );\n      return typeof transaction === \"string\" ? this.provider.getTransactionResponse(transaction) : transaction;\n    }\n    if (estimateTxDependencies) {\n      await this.provider.estimateTxDependencies(transactionRequest);\n    }\n    return this.provider.sendTransaction(transactionRequest, {\n      estimateTxDependencies: false\n    });\n  }\n  /**\n   * Simulates a transaction.\n   *\n   * @param transactionRequestLike - The transaction request to be simulated.\n   * @param estimateTxParams - The estimate transaction params (optional).\n   * @returns A promise that resolves to the call result.\n   */\n  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      await this.provider.estimateTxDependencies(transactionRequest);\n    }\n    return this.provider.simulate(transactionRequest, { estimateTxDependencies: false });\n  }\n  /**\n   * Generates an array of fake resources based on the provided coins.\n   *\n   * @param coins - An array of `FakeResources` objects representing the coins.\n   * @returns An array of `Resource` objects with generated properties.\n   */\n  generateFakeResources(coins) {\n    return coins.map((coin) => ({\n      id: hexlify18(randomBytes2(UTXO_ID_LEN3)),\n      owner: this.address,\n      blockCreated: bn22(1),\n      txCreatedIdx: bn22(1),\n      ...coin\n    }));\n  }\n  /** @hidden */\n  async prepareTransactionForSend(request2) {\n    const { transactionId } = request2.flag;\n    if (!isDefined4(transactionId)) {\n      return request2;\n    }\n    const chainId = await this.provider.getChainId();\n    const currentTransactionId = request2.getTransactionId(chainId);\n    if (transactionId !== currentTransactionId) {\n      request2.updateState(chainId);\n    }\n    return request2;\n  }\n  /** @hidden */\n  async prepareTransactionSummary(request2) {\n    const chainId = await this.provider.getChainId();\n    return isDefined4(request2.flag.summary) ? {\n      ...request2.flag.summary,\n      id: request2.getTransactionId(chainId),\n      transactionBytes: hexlify18(request2.toTransactionBytes())\n    } : void 0;\n  }\n  /** @hidden * */\n  async assembleTx(opts) {\n    const { transactionRequest, quantities = [], skipAutoConsolidation } = opts;\n    const outputQuantities = transactionRequest.outputs.filter((o) => o.type === OutputType10.Coin).map(({ amount, assetId }) => ({ assetId: String(assetId), amount: bn22(amount) }));\n    transactionRequest.gasLimit = bn22(0);\n    transactionRequest.maxFee = bn22(0);\n    const assembleTx = /* @__PURE__ */ __name(async () => {\n      const { assembledRequest, gasPrice } = await this.provider.assembleTx({\n        request: transactionRequest,\n        accountCoinQuantities: mergeQuantities(outputQuantities, quantities),\n        feePayerAccount: this\n      });\n      return { transactionRequest: assembledRequest, gasPrice };\n    }, \"assembleTx\");\n    try {\n      return await assembleTx();\n    } catch (error) {\n      const shouldRetry = await consolidateCoinsIfRequired({\n        error,\n        account: this,\n        skipAutoConsolidation\n      });\n      if (!shouldRetry) {\n        throw error;\n      }\n      return await assembleTx();\n    }\n  }\n  /** @hidden * */\n  validateTransferAmount(amount) {\n    if (bn22(amount).lte(0)) {\n      throw new FuelError22(\n        ErrorCode20.INVALID_TRANSFER_AMOUNT,\n        \"Transfer amount must be a positive number.\"\n      );\n    }\n  }\n  /** @hidden * */\n  validateConsolidationTxsCoins(coins, assetId) {\n    if (coins.length <= 1) {\n      throw new FuelError22(ErrorCode20.NO_COINS_TO_CONSOLIDATE, \"No coins to consolidate.\");\n    }\n    if (!coins.every((c) => c.assetId === assetId)) {\n      throw new FuelError22(\n        ErrorCode20.COINS_ASSET_ID_MISMATCH,\n        \"All coins to consolidate must be from the same asset id.\"\n      );\n    }\n  }\n  /** @hidden * */\n  async setTransactionStateForConnectors(params) {\n    const { transactionRequest: requestToPrepare, connectorOptions } = params;\n    const { onBeforeSend, skipCustomFee = false } = connectorOptions;\n    const transactionRequest = await this.prepareTransactionForSend(requestToPrepare);\n    const connectorsSendTxParams = {\n      onBeforeSend,\n      skipCustomFee,\n      provider: {\n        url: this.provider.url,\n        cache: await serializeProviderCache(this.provider)\n      },\n      transactionState: requestToPrepare.flag.state,\n      transactionSummary: await this.prepareTransactionSummary(requestToPrepare)\n    };\n    return { transactionRequest, connectorsSendTxParams };\n  }\n};\n\n// src/wallet/base-wallet-unlocked.ts\nimport { hashMessage } from \"@fuel-ts/hasher\";\nimport { hexlify as hexlify21 } from \"@fuel-ts/utils\";\n\n// src/signer/signer.ts\nimport { Address as Address6 } from \"@fuel-ts/address\";\nimport { randomBytes as randomBytes3 } from \"@fuel-ts/crypto\";\nimport { hash as hash2 } from \"@fuel-ts/hasher\";\nimport { toBytes as toBytes2 } from \"@fuel-ts/math\";\nimport { hexlify as hexlify19, concat as concat5, arrayify as arrayify18 } from \"@fuel-ts/utils\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nvar Signer = class _Signer {\n  static {\n    __name(this, \"Signer\");\n  }\n  address;\n  publicKey;\n  compressedPublicKey;\n  privateKey;\n  /**\n   * Create a Signer instance from a given private key\n   *\n   * @param privateKey - The private key to use for signing\n   * @returns A new Signer instance\n   */\n  constructor(privateKey) {\n    if (typeof privateKey === \"string\") {\n      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n        privateKey = `0x${privateKey}`;\n      }\n    }\n    const privateKeyBytes = toBytes2(privateKey, 32);\n    this.privateKey = hexlify19(privateKeyBytes);\n    this.publicKey = hexlify19(secp256k1.getPublicKey(privateKeyBytes, false).slice(1));\n    this.compressedPublicKey = hexlify19(secp256k1.getPublicKey(privateKeyBytes, true));\n    this.address = new Address6(this.publicKey);\n  }\n  /**\n   * Sign data using the Signer instance\n   *\n   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte.\n   * @ignore\n   * [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)\n   *\n   * @param data - The data to be sign\n   * @returns hashed signature\n   */\n  sign(data) {\n    const signature = secp256k1.sign(arrayify18(data), arrayify18(this.privateKey));\n    const r = toBytes2(`0x${signature.r.toString(16)}`, 32);\n    const s = toBytes2(`0x${signature.s.toString(16)}`, 32);\n    s[0] |= (signature.recovery || 0) << 7;\n    return hexlify19(concat5([r, s]));\n  }\n  /**\n   * Add point on the current elliptic curve\n   *\n   * @param point - Point to add on the curve\n   * @returns compressed point on the curve\n   */\n  addPoint(point) {\n    const p0 = secp256k1.ProjectivePoint.fromHex(arrayify18(this.compressedPublicKey));\n    const p1 = secp256k1.ProjectivePoint.fromHex(arrayify18(point));\n    const result = p0.add(p1);\n    return `0x${result.toHex(true)}`;\n  }\n  /**\n   * Recover the public key from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - hashed signature\n   * @returns public key from signature from the\n   */\n  static recoverPublicKey(data, signature) {\n    const signedMessageBytes = arrayify18(signature);\n    const r = signedMessageBytes.slice(0, 32);\n    const s = signedMessageBytes.slice(32, 64);\n    const recoveryParam = (s[0] & 128) >> 7;\n    s[0] &= 127;\n    const sig = new secp256k1.Signature(BigInt(hexlify19(r)), BigInt(hexlify19(s))).addRecoveryBit(\n      recoveryParam\n    );\n    const publicKey = sig.recoverPublicKey(arrayify18(data)).toRawBytes(false).slice(1);\n    return hexlify19(publicKey);\n  }\n  /**\n   * Recover the address from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - Signature\n   * @returns Address from signature\n   */\n  static recoverAddress(data, signature) {\n    return new Address6(_Signer.recoverPublicKey(data, signature));\n  }\n  /**\n   * Generate a random privateKey\n   *\n   * @param entropy - Adds extra entropy to generate the privateKey\n   * @returns random 32-byte hashed\n   */\n  static generatePrivateKey(entropy) {\n    return entropy ? hash2(concat5([randomBytes3(32), arrayify18(entropy)])) : randomBytes3(32);\n  }\n  /**\n   * Extended publicKey from a compact publicKey\n   *\n   * @param publicKey - Compact publicKey\n   * @returns extended publicKey\n   */\n  static extendPublicKey(publicKey) {\n    const point = secp256k1.ProjectivePoint.fromHex(arrayify18(publicKey));\n    return hexlify19(point.toRawBytes(false).slice(1));\n  }\n};\n\n// src/wallet/keystore-wallet.ts\nimport { Address as Address7 } from \"@fuel-ts/address\";\nimport {\n  bufferFromString,\n  keccak256,\n  randomBytes as randomBytes4,\n  scrypt,\n  stringFromBuffer,\n  decryptJsonWalletData,\n  encryptJsonWalletData,\n  randomUUID\n} from \"@fuel-ts/crypto\";\nimport { ErrorCode as ErrorCode21, FuelError as FuelError23 } from \"@fuel-ts/errors\";\nimport { hexlify as hexlify20 } from \"@fuel-ts/utils\";\nvar DEFAULT_KDF_PARAMS_LOG_N = 13;\nvar DEFAULT_KDF_PARAMS_R = 8;\nvar DEFAULT_KDF_PARAMS_P = 1;\nvar DEFAULT_KEY_SIZE = 32;\nvar DEFAULT_IV_SIZE = 16;\nvar removeHexPrefix = /* @__PURE__ */ __name((hexString) => {\n  if (/^0x/.test(hexString)) {\n    return hexString.slice(2);\n  }\n  return hexString;\n}, \"removeHexPrefix\");\nasync function encryptKeystoreWallet(privateKey, address, password) {\n  const privateKeyBuffer = bufferFromString(removeHexPrefix(privateKey), \"hex\");\n  const ownerAddress = new Address7(address);\n  const salt = randomBytes4(DEFAULT_KEY_SIZE);\n  const key = scrypt({\n    password: bufferFromString(password),\n    salt,\n    dklen: DEFAULT_KEY_SIZE,\n    n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,\n    r: DEFAULT_KDF_PARAMS_R,\n    p: DEFAULT_KDF_PARAMS_P\n  });\n  const iv = randomBytes4(DEFAULT_IV_SIZE);\n  const ciphertext = await encryptJsonWalletData(privateKeyBuffer, key, iv);\n  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);\n  const macHashUint8Array = keccak256(data);\n  const mac = stringFromBuffer(macHashUint8Array, \"hex\");\n  const keystore = {\n    id: randomUUID(),\n    version: 3,\n    address: removeHexPrefix(ownerAddress.toHexString()),\n    crypto: {\n      cipher: \"aes-128-ctr\",\n      mac,\n      cipherparams: { iv: stringFromBuffer(iv, \"hex\") },\n      ciphertext: stringFromBuffer(ciphertext, \"hex\"),\n      kdf: \"scrypt\",\n      kdfparams: {\n        dklen: DEFAULT_KEY_SIZE,\n        n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,\n        p: DEFAULT_KDF_PARAMS_P,\n        r: DEFAULT_KDF_PARAMS_R,\n        salt: stringFromBuffer(salt, \"hex\")\n      }\n    }\n  };\n  return JSON.stringify(keystore);\n}\n__name(encryptKeystoreWallet, \"encryptKeystoreWallet\");\nasync function decryptKeystoreWallet(jsonWallet, password) {\n  const keystoreWallet = JSON.parse(jsonWallet);\n  const {\n    crypto: {\n      mac,\n      ciphertext,\n      cipherparams: { iv },\n      kdfparams: { dklen, n, r, p, salt }\n    }\n  } = keystoreWallet;\n  const ciphertextBuffer = bufferFromString(ciphertext, \"hex\");\n  const ivBuffer = bufferFromString(iv, \"hex\");\n  const saltBuffer = bufferFromString(salt, \"hex\");\n  const passwordBuffer = bufferFromString(password);\n  const key = scrypt({\n    password: passwordBuffer,\n    salt: saltBuffer,\n    n,\n    p,\n    r,\n    dklen\n  });\n  const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);\n  const macHashUint8Array = keccak256(data);\n  const macHash = stringFromBuffer(macHashUint8Array, \"hex\");\n  if (mac !== macHash) {\n    throw new FuelError23(\n      ErrorCode21.INVALID_PASSWORD,\n      \"Failed to decrypt the keystore wallet, the provided password is incorrect.\"\n    );\n  }\n  const buffer = await decryptJsonWalletData(ciphertextBuffer, key, ivBuffer);\n  const privateKey = hexlify20(buffer);\n  return privateKey;\n}\n__name(decryptKeystoreWallet, \"decryptKeystoreWallet\");\n\n// src/wallet/base-wallet-unlocked.ts\nvar BaseWalletUnlocked = class extends Account {\n  static {\n    __name(this, \"BaseWalletUnlocked\");\n  }\n  /**\n   * Default HDWallet path.\n   */\n  static defaultPath = \"m/44'/1179993420'/0'/0/0\";\n  /**\n   * A function that returns the wallet's signer.\n   */\n  signer;\n  /**\n   * Creates a new BaseWalletUnlocked instance.\n   *\n   * @param privateKey - The private key of the wallet.\n   * @param provider - A Provider instance (optional).\n   */\n  constructor(privateKey, provider) {\n    const signer = new Signer(privateKey);\n    super(signer.address, provider);\n    this.signer = () => signer;\n  }\n  /**\n   * Gets the private key of the wallet.\n   *\n   * @returns The private key of the wallet.\n   */\n  get privateKey() {\n    return this.signer().privateKey;\n  }\n  /**\n   * Gets the public key of the wallet.\n   *\n   * @returns\n   */\n  get publicKey() {\n    return this.signer().publicKey;\n  }\n  /**\n   * Signs a message with the wallet's private key.\n   *\n   * @param message - The message to sign.\n   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.\n   */\n  async signMessage(message) {\n    const signedMessage = await this.signer().sign(hashMessage(message));\n    return hexlify21(signedMessage);\n  }\n  /**\n   * Signs a transaction with the wallet's private key.\n   *\n   * @param transactionRequestLike - The transaction request to sign.\n   * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.\n   */\n  async signTransaction(transactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const chainId = await this.provider.getChainId();\n    const hashedTransaction = transactionRequest.getTransactionId(chainId);\n    const signature = await this.signer().sign(hashedTransaction);\n    return hexlify21(signature);\n  }\n  /**\n   * Populates a transaction with the witnesses signature.\n   *\n   * @param transactionRequestLike - The transaction request to populate.\n   * @returns The populated transaction request.\n   */\n  async populateTransactionWitnessesSignature(transactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    const signedTransaction = await this.signTransaction(transactionRequest);\n    transactionRequest.updateWitnessByOwner(this.address, signedTransaction);\n    return transactionRequest;\n  }\n  /**\n   * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.\n   *\n   * @param transactionRequestLike - The transaction request to send.\n   * @param estimateTxDependencies - Whether to estimate the transaction dependencies.\n   * @returns A promise that resolves to the TransactionResponse object.\n   */\n  async sendTransaction(transactionRequestLike, { estimateTxDependencies = false, enableAssetBurn } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    validateTransactionForAssetBurn(\n      await this.provider.getBaseAssetId(),\n      transactionRequest,\n      enableAssetBurn\n    );\n    if (estimateTxDependencies) {\n      await this.provider.estimateTxDependencies(transactionRequest);\n    }\n    return this.provider.sendTransaction(\n      await this.populateTransactionWitnessesSignature(transactionRequest),\n      { estimateTxDependencies: false, enableAssetBurn }\n    );\n  }\n  /**\n   * Populates the witness signature for a transaction and sends a call to the network using `provider.dryRun`.\n   *\n   * @param transactionRequestLike - The transaction request to simulate.\n   * @returns A promise that resolves to the CallResult object.\n   */\n  async simulateTransaction(transactionRequestLike, { estimateTxDependencies = true } = {}) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      await this.provider.estimateTxDependencies(transactionRequest);\n    }\n    return this.provider.dryRun(\n      await this.populateTransactionWitnessesSignature(transactionRequest),\n      {\n        utxoValidation: true,\n        estimateTxDependencies: false\n      }\n    );\n  }\n  /**\n   * Encrypts an unlocked wallet with a password.\n   *\n   * @param password - the password to encrypt the wallet with.\n   * @returns - the encrypted wallet.\n   */\n  async encrypt(password) {\n    return encryptKeystoreWallet(this.privateKey, this.address, password);\n  }\n};\n\n// src/hdwallet/hdwallet.ts\nimport { computeHmac as computeHmac2, ripemd160 } from \"@fuel-ts/crypto\";\nimport { ErrorCode as ErrorCode24, FuelError as FuelError26 } from \"@fuel-ts/errors\";\nimport { sha256 as sha2564 } from \"@fuel-ts/hasher\";\nimport { bn as bn23, toBytes as toBytes3, toHex } from \"@fuel-ts/math\";\nimport { arrayify as arrayify21, hexlify as hexlify23, concat as concat7, dataSlice as dataSlice2, encodeBase58 as encodeBase582, decodeBase58 } from \"@fuel-ts/utils\";\n\n// src/mnemonic/mnemonic.ts\nimport { randomBytes as randomBytes5, pbkdf2, computeHmac } from \"@fuel-ts/crypto\";\nimport { ErrorCode as ErrorCode23, FuelError as FuelError25 } from \"@fuel-ts/errors\";\nimport { sha256 as sha2563 } from \"@fuel-ts/hasher\";\nimport { arrayify as arrayify20, hexlify as hexlify22, concat as concat6, dataSlice, encodeBase58, toUtf8Bytes } from \"@fuel-ts/utils\";\n\n// src/wordlists/words/english.ts\nvar english = [\n  \"abandon\",\n  \"ability\",\n  \"able\",\n  \"about\",\n  \"above\",\n  \"absent\",\n  \"absorb\",\n  \"abstract\",\n  \"absurd\",\n  \"abuse\",\n  \"access\",\n  \"accident\",\n  \"account\",\n  \"accuse\",\n  \"achieve\",\n  \"acid\",\n  \"acoustic\",\n  \"acquire\",\n  \"across\",\n  \"act\",\n  \"action\",\n  \"actor\",\n  \"actress\",\n  \"actual\",\n  \"adapt\",\n  \"add\",\n  \"addict\",\n  \"address\",\n  \"adjust\",\n  \"admit\",\n  \"adult\",\n  \"advance\",\n  \"advice\",\n  \"aerobic\",\n  \"affair\",\n  \"afford\",\n  \"afraid\",\n  \"again\",\n  \"age\",\n  \"agent\",\n  \"agree\",\n  \"ahead\",\n  \"aim\",\n  \"air\",\n  \"airport\",\n  \"aisle\",\n  \"alarm\",\n  \"album\",\n  \"alcohol\",\n  \"alert\",\n  \"alien\",\n  \"all\",\n  \"alley\",\n  \"allow\",\n  \"almost\",\n  \"alone\",\n  \"alpha\",\n  \"already\",\n  \"also\",\n  \"alter\",\n  \"always\",\n  \"amateur\",\n  \"amazing\",\n  \"among\",\n  \"amount\",\n  \"amused\",\n  \"analyst\",\n  \"anchor\",\n  \"ancient\",\n  \"anger\",\n  \"angle\",\n  \"angry\",\n  \"animal\",\n  \"ankle\",\n  \"announce\",\n  \"annual\",\n  \"another\",\n  \"answer\",\n  \"antenna\",\n  \"antique\",\n  \"anxiety\",\n  \"any\",\n  \"apart\",\n  \"apology\",\n  \"appear\",\n  \"apple\",\n  \"approve\",\n  \"april\",\n  \"arch\",\n  \"arctic\",\n  \"area\",\n  \"arena\",\n  \"argue\",\n  \"arm\",\n  \"armed\",\n  \"armor\",\n  \"army\",\n  \"around\",\n  \"arrange\",\n  \"arrest\",\n  \"arrive\",\n  \"arrow\",\n  \"art\",\n  \"artefact\",\n  \"artist\",\n  \"artwork\",\n  \"ask\",\n  \"aspect\",\n  \"assault\",\n  \"asset\",\n  \"assist\",\n  \"assume\",\n  \"asthma\",\n  \"athlete\",\n  \"atom\",\n  \"attack\",\n  \"attend\",\n  \"attitude\",\n  \"attract\",\n  \"auction\",\n  \"audit\",\n  \"august\",\n  \"aunt\",\n  \"author\",\n  \"auto\",\n  \"autumn\",\n  \"average\",\n  \"avocado\",\n  \"avoid\",\n  \"awake\",\n  \"aware\",\n  \"away\",\n  \"awesome\",\n  \"awful\",\n  \"awkward\",\n  \"axis\",\n  \"baby\",\n  \"bachelor\",\n  \"bacon\",\n  \"badge\",\n  \"bag\",\n  \"balance\",\n  \"balcony\",\n  \"ball\",\n  \"bamboo\",\n  \"banana\",\n  \"banner\",\n  \"bar\",\n  \"barely\",\n  \"bargain\",\n  \"barrel\",\n  \"base\",\n  \"basic\",\n  \"basket\",\n  \"battle\",\n  \"beach\",\n  \"bean\",\n  \"beauty\",\n  \"because\",\n  \"become\",\n  \"beef\",\n  \"before\",\n  \"begin\",\n  \"behave\",\n  \"behind\",\n  \"believe\",\n  \"below\",\n  \"belt\",\n  \"bench\",\n  \"benefit\",\n  \"best\",\n  \"betray\",\n  \"better\",\n  \"between\",\n  \"beyond\",\n  \"bicycle\",\n  \"bid\",\n  \"bike\",\n  \"bind\",\n  \"biology\",\n  \"bird\",\n  \"birth\",\n  \"bitter\",\n  \"black\",\n  \"blade\",\n  \"blame\",\n  \"blanket\",\n  \"blast\",\n  \"bleak\",\n  \"bless\",\n  \"blind\",\n  \"blood\",\n  \"blossom\",\n  \"blouse\",\n  \"blue\",\n  \"blur\",\n  \"blush\",\n  \"board\",\n  \"boat\",\n  \"body\",\n  \"boil\",\n  \"bomb\",\n  \"bone\",\n  \"bonus\",\n  \"book\",\n  \"boost\",\n  \"border\",\n  \"boring\",\n  \"borrow\",\n  \"boss\",\n  \"bottom\",\n  \"bounce\",\n  \"box\",\n  \"boy\",\n  \"bracket\",\n  \"brain\",\n  \"brand\",\n  \"brass\",\n  \"brave\",\n  \"bread\",\n  \"breeze\",\n  \"brick\",\n  \"bridge\",\n  \"brief\",\n  \"bright\",\n  \"bring\",\n  \"brisk\",\n  \"broccoli\",\n  \"broken\",\n  \"bronze\",\n  \"broom\",\n  \"brother\",\n  \"brown\",\n  \"brush\",\n  \"bubble\",\n  \"buddy\",\n  \"budget\",\n  \"buffalo\",\n  \"build\",\n  \"bulb\",\n  \"bulk\",\n  \"bullet\",\n  \"bundle\",\n  \"bunker\",\n  \"burden\",\n  \"burger\",\n  \"burst\",\n  \"bus\",\n  \"business\",\n  \"busy\",\n  \"butter\",\n  \"buyer\",\n  \"buzz\",\n  \"cabbage\",\n  \"cabin\",\n  \"cable\",\n  \"cactus\",\n  \"cage\",\n  \"cake\",\n  \"call\",\n  \"calm\",\n  \"camera\",\n  \"camp\",\n  \"can\",\n  \"canal\",\n  \"cancel\",\n  \"candy\",\n  \"cannon\",\n  \"canoe\",\n  \"canvas\",\n  \"canyon\",\n  \"capable\",\n  \"capital\",\n  \"captain\",\n  \"car\",\n  \"carbon\",\n  \"card\",\n  \"cargo\",\n  \"carpet\",\n  \"carry\",\n  \"cart\",\n  \"case\",\n  \"cash\",\n  \"casino\",\n  \"castle\",\n  \"casual\",\n  \"cat\",\n  \"catalog\",\n  \"catch\",\n  \"category\",\n  \"cattle\",\n  \"caught\",\n  \"cause\",\n  \"caution\",\n  \"cave\",\n  \"ceiling\",\n  \"celery\",\n  \"cement\",\n  \"census\",\n  \"century\",\n  \"cereal\",\n  \"certain\",\n  \"chair\",\n  \"chalk\",\n  \"champion\",\n  \"change\",\n  \"chaos\",\n  \"chapter\",\n  \"charge\",\n  \"chase\",\n  \"chat\",\n  \"cheap\",\n  \"check\",\n  \"cheese\",\n  \"chef\",\n  \"cherry\",\n  \"chest\",\n  \"chicken\",\n  \"chief\",\n  \"child\",\n  \"chimney\",\n  \"choice\",\n  \"choose\",\n  \"chronic\",\n  \"chuckle\",\n  \"chunk\",\n  \"churn\",\n  \"cigar\",\n  \"cinnamon\",\n  \"circle\",\n  \"citizen\",\n  \"city\",\n  \"civil\",\n  \"claim\",\n  \"clap\",\n  \"clarify\",\n  \"claw\",\n  \"clay\",\n  \"clean\",\n  \"clerk\",\n  \"clever\",\n  \"click\",\n  \"client\",\n  \"cliff\",\n  \"climb\",\n  \"clinic\",\n  \"clip\",\n  \"clock\",\n  \"clog\",\n  \"close\",\n  \"cloth\",\n  \"cloud\",\n  \"clown\",\n  \"club\",\n  \"clump\",\n  \"cluster\",\n  \"clutch\",\n  \"coach\",\n  \"coast\",\n  \"coconut\",\n  \"code\",\n  \"coffee\",\n  \"coil\",\n  \"coin\",\n  \"collect\",\n  \"color\",\n  \"column\",\n  \"combine\",\n  \"come\",\n  \"comfort\",\n  \"comic\",\n  \"common\",\n  \"company\",\n  \"concert\",\n  \"conduct\",\n  \"confirm\",\n  \"congress\",\n  \"connect\",\n  \"consider\",\n  \"control\",\n  \"convince\",\n  \"cook\",\n  \"cool\",\n  \"copper\",\n  \"copy\",\n  \"coral\",\n  \"core\",\n  \"corn\",\n  \"correct\",\n  \"cost\",\n  \"cotton\",\n  \"couch\",\n  \"country\",\n  \"couple\",\n  \"course\",\n  \"cousin\",\n  \"cover\",\n  \"coyote\",\n  \"crack\",\n  \"cradle\",\n  \"craft\",\n  \"cram\",\n  \"crane\",\n  \"crash\",\n  \"crater\",\n  \"crawl\",\n  \"crazy\",\n  \"cream\",\n  \"credit\",\n  \"creek\",\n  \"crew\",\n  \"cricket\",\n  \"crime\",\n  \"crisp\",\n  \"critic\",\n  \"crop\",\n  \"cross\",\n  \"crouch\",\n  \"crowd\",\n  \"crucial\",\n  \"cruel\",\n  \"cruise\",\n  \"crumble\",\n  \"crunch\",\n  \"crush\",\n  \"cry\",\n  \"crystal\",\n  \"cube\",\n  \"culture\",\n  \"cup\",\n  \"cupboard\",\n  \"curious\",\n  \"current\",\n  \"curtain\",\n  \"curve\",\n  \"cushion\",\n  \"custom\",\n  \"cute\",\n  \"cycle\",\n  \"dad\",\n  \"damage\",\n  \"damp\",\n  \"dance\",\n  \"danger\",\n  \"daring\",\n  \"dash\",\n  \"daughter\",\n  \"dawn\",\n  \"day\",\n  \"deal\",\n  \"debate\",\n  \"debris\",\n  \"decade\",\n  \"december\",\n  \"decide\",\n  \"decline\",\n  \"decorate\",\n  \"decrease\",\n  \"deer\",\n  \"defense\",\n  \"define\",\n  \"defy\",\n  \"degree\",\n  \"delay\",\n  \"deliver\",\n  \"demand\",\n  \"demise\",\n  \"denial\",\n  \"dentist\",\n  \"deny\",\n  \"depart\",\n  \"depend\",\n  \"deposit\",\n  \"depth\",\n  \"deputy\",\n  \"derive\",\n  \"describe\",\n  \"desert\",\n  \"design\",\n  \"desk\",\n  \"despair\",\n  \"destroy\",\n  \"detail\",\n  \"detect\",\n  \"develop\",\n  \"device\",\n  \"devote\",\n  \"diagram\",\n  \"dial\",\n  \"diamond\",\n  \"diary\",\n  \"dice\",\n  \"diesel\",\n  \"diet\",\n  \"differ\",\n  \"digital\",\n  \"dignity\",\n  \"dilemma\",\n  \"dinner\",\n  \"dinosaur\",\n  \"direct\",\n  \"dirt\",\n  \"disagree\",\n  \"discover\",\n  \"disease\",\n  \"dish\",\n  \"dismiss\",\n  \"disorder\",\n  \"display\",\n  \"distance\",\n  \"divert\",\n  \"divide\",\n  \"divorce\",\n  \"dizzy\",\n  \"doctor\",\n  \"document\",\n  \"dog\",\n  \"doll\",\n  \"dolphin\",\n  \"domain\",\n  \"donate\",\n  \"donkey\",\n  \"donor\",\n  \"door\",\n  \"dose\",\n  \"double\",\n  \"dove\",\n  \"draft\",\n  \"dragon\",\n  \"drama\",\n  \"drastic\",\n  \"draw\",\n  \"dream\",\n  \"dress\",\n  \"drift\",\n  \"drill\",\n  \"drink\",\n  \"drip\",\n  \"drive\",\n  \"drop\",\n  \"drum\",\n  \"dry\",\n  \"duck\",\n  \"dumb\",\n  \"dune\",\n  \"during\",\n  \"dust\",\n  \"dutch\",\n  \"duty\",\n  \"dwarf\",\n  \"dynamic\",\n  \"eager\",\n  \"eagle\",\n  \"early\",\n  \"earn\",\n  \"earth\",\n  \"easily\",\n  \"east\",\n  \"easy\",\n  \"echo\",\n  \"ecology\",\n  \"economy\",\n  \"edge\",\n  \"edit\",\n  \"educate\",\n  \"effort\",\n  \"egg\",\n  \"eight\",\n  \"either\",\n  \"elbow\",\n  \"elder\",\n  \"electric\",\n  \"elegant\",\n  \"element\",\n  \"elephant\",\n  \"elevator\",\n  \"elite\",\n  \"else\",\n  \"embark\",\n  \"embody\",\n  \"embrace\",\n  \"emerge\",\n  \"emotion\",\n  \"employ\",\n  \"empower\",\n  \"empty\",\n  \"enable\",\n  \"enact\",\n  \"end\",\n  \"endless\",\n  \"endorse\",\n  \"enemy\",\n  \"energy\",\n  \"enforce\",\n  \"engage\",\n  \"engine\",\n  \"enhance\",\n  \"enjoy\",\n  \"enlist\",\n  \"enough\",\n  \"enrich\",\n  \"enroll\",\n  \"ensure\",\n  \"enter\",\n  \"entire\",\n  \"entry\",\n  \"envelope\",\n  \"episode\",\n  \"equal\",\n  \"equip\",\n  \"era\",\n  \"erase\",\n  \"erode\",\n  \"erosion\",\n  \"error\",\n  \"erupt\",\n  \"escape\",\n  \"essay\",\n  \"essence\",\n  \"estate\",\n  \"eternal\",\n  \"ethics\",\n  \"evidence\",\n  \"evil\",\n  \"evoke\",\n  \"evolve\",\n  \"exact\",\n  \"example\",\n  \"excess\",\n  \"exchange\",\n  \"excite\",\n  \"exclude\",\n  \"excuse\",\n  \"execute\",\n  \"exercise\",\n  \"exhaust\",\n  \"exhibit\",\n  \"exile\",\n  \"exist\",\n  \"exit\",\n  \"exotic\",\n  \"expand\",\n  \"expect\",\n  \"expire\",\n  \"explain\",\n  \"expose\",\n  \"express\",\n  \"extend\",\n  \"extra\",\n  \"eye\",\n  \"eyebrow\",\n  \"fabric\",\n  \"face\",\n  \"faculty\",\n  \"fade\",\n  \"faint\",\n  \"faith\",\n  \"fall\",\n  \"false\",\n  \"fame\",\n  \"family\",\n  \"famous\",\n  \"fan\",\n  \"fancy\",\n  \"fantasy\",\n  \"farm\",\n  \"fashion\",\n  \"fat\",\n  \"fatal\",\n  \"father\",\n  \"fatigue\",\n  \"fault\",\n  \"favorite\",\n  \"feature\",\n  \"february\",\n  \"federal\",\n  \"fee\",\n  \"feed\",\n  \"feel\",\n  \"female\",\n  \"fence\",\n  \"festival\",\n  \"fetch\",\n  \"fever\",\n  \"few\",\n  \"fiber\",\n  \"fiction\",\n  \"field\",\n  \"figure\",\n  \"file\",\n  \"film\",\n  \"filter\",\n  \"final\",\n  \"find\",\n  \"fine\",\n  \"finger\",\n  \"finish\",\n  \"fire\",\n  \"firm\",\n  \"first\",\n  \"fiscal\",\n  \"fish\",\n  \"fit\",\n  \"fitness\",\n  \"fix\",\n  \"flag\",\n  \"flame\",\n  \"flash\",\n  \"flat\",\n  \"flavor\",\n  \"flee\",\n  \"flight\",\n  \"flip\",\n  \"float\",\n  \"flock\",\n  \"floor\",\n  \"flower\",\n  \"fluid\",\n  \"flush\",\n  \"fly\",\n  \"foam\",\n  \"focus\",\n  \"fog\",\n  \"foil\",\n  \"fold\",\n  \"follow\",\n  \"food\",\n  \"foot\",\n  \"force\",\n  \"forest\",\n  \"forget\",\n  \"fork\",\n  \"fortune\",\n  \"forum\",\n  \"forward\",\n  \"fossil\",\n  \"foster\",\n  \"found\",\n  \"fox\",\n  \"fragile\",\n  \"frame\",\n  \"frequent\",\n  \"fresh\",\n  \"friend\",\n  \"fringe\",\n  \"frog\",\n  \"front\",\n  \"frost\",\n  \"frown\",\n  \"frozen\",\n  \"fruit\",\n  \"fuel\",\n  \"fun\",\n  \"funny\",\n  \"furnace\",\n  \"fury\",\n  \"future\",\n  \"gadget\",\n  \"gain\",\n  \"galaxy\",\n  \"gallery\",\n  \"game\",\n  \"gap\",\n  \"garage\",\n  \"garbage\",\n  \"garden\",\n  \"garlic\",\n  \"garment\",\n  \"gas\",\n  \"gasp\",\n  \"gate\",\n  \"gather\",\n  \"gauge\",\n  \"gaze\",\n  \"general\",\n  \"genius\",\n  \"genre\",\n  \"gentle\",\n  \"genuine\",\n  \"gesture\",\n  \"ghost\",\n  \"giant\",\n  \"gift\",\n  \"giggle\",\n  \"ginger\",\n  \"giraffe\",\n  \"girl\",\n  \"give\",\n  \"glad\",\n  \"glance\",\n  \"glare\",\n  \"glass\",\n  \"glide\",\n  \"glimpse\",\n  \"globe\",\n  \"gloom\",\n  \"glory\",\n  \"glove\",\n  \"glow\",\n  \"glue\",\n  \"goat\",\n  \"goddess\",\n  \"gold\",\n  \"good\",\n  \"goose\",\n  \"gorilla\",\n  \"gospel\",\n  \"gossip\",\n  \"govern\",\n  \"gown\",\n  \"grab\",\n  \"grace\",\n  \"grain\",\n  \"grant\",\n  \"grape\",\n  \"grass\",\n  \"gravity\",\n  \"great\",\n  \"green\",\n  \"grid\",\n  \"grief\",\n  \"grit\",\n  \"grocery\",\n  \"group\",\n  \"grow\",\n  \"grunt\",\n  \"guard\",\n  \"guess\",\n  \"guide\",\n  \"guilt\",\n  \"guitar\",\n  \"gun\",\n  \"gym\",\n  \"habit\",\n  \"hair\",\n  \"half\",\n  \"hammer\",\n  \"hamster\",\n  \"hand\",\n  \"happy\",\n  \"harbor\",\n  \"hard\",\n  \"harsh\",\n  \"harvest\",\n  \"hat\",\n  \"have\",\n  \"hawk\",\n  \"hazard\",\n  \"head\",\n  \"health\",\n  \"heart\",\n  \"heavy\",\n  \"hedgehog\",\n  \"height\",\n  \"hello\",\n  \"helmet\",\n  \"help\",\n  \"hen\",\n  \"hero\",\n  \"hidden\",\n  \"high\",\n  \"hill\",\n  \"hint\",\n  \"hip\",\n  \"hire\",\n  \"history\",\n  \"hobby\",\n  \"hockey\",\n  \"hold\",\n  \"hole\",\n  \"holiday\",\n  \"hollow\",\n  \"home\",\n  \"honey\",\n  \"hood\",\n  \"hope\",\n  \"horn\",\n  \"horror\",\n  \"horse\",\n  \"hospital\",\n  \"host\",\n  \"hotel\",\n  \"hour\",\n  \"hover\",\n  \"hub\",\n  \"huge\",\n  \"human\",\n  \"humble\",\n  \"humor\",\n  \"hundred\",\n  \"hungry\",\n  \"hunt\",\n  \"hurdle\",\n  \"hurry\",\n  \"hurt\",\n  \"husband\",\n  \"hybrid\",\n  \"ice\",\n  \"icon\",\n  \"idea\",\n  \"identify\",\n  \"idle\",\n  \"ignore\",\n  \"ill\",\n  \"illegal\",\n  \"illness\",\n  \"image\",\n  \"imitate\",\n  \"immense\",\n  \"immune\",\n  \"impact\",\n  \"impose\",\n  \"improve\",\n  \"impulse\",\n  \"inch\",\n  \"include\",\n  \"income\",\n  \"increase\",\n  \"index\",\n  \"indicate\",\n  \"indoor\",\n  \"industry\",\n  \"infant\",\n  \"inflict\",\n  \"inform\",\n  \"inhale\",\n  \"inherit\",\n  \"initial\",\n  \"inject\",\n  \"injury\",\n  \"inmate\",\n  \"inner\",\n  \"innocent\",\n  \"input\",\n  \"inquiry\",\n  \"insane\",\n  \"insect\",\n  \"inside\",\n  \"inspire\",\n  \"install\",\n  \"intact\",\n  \"interest\",\n  \"into\",\n  \"invest\",\n  \"invite\",\n  \"involve\",\n  \"iron\",\n  \"island\",\n  \"isolate\",\n  \"issue\",\n  \"item\",\n  \"ivory\",\n  \"jacket\",\n  \"jaguar\",\n  \"jar\",\n  \"jazz\",\n  \"jealous\",\n  \"jeans\",\n  \"jelly\",\n  \"jewel\",\n  \"job\",\n  \"join\",\n  \"joke\",\n  \"journey\",\n  \"joy\",\n  \"judge\",\n  \"juice\",\n  \"jump\",\n  \"jungle\",\n  \"junior\",\n  \"junk\",\n  \"just\",\n  \"kangaroo\",\n  \"keen\",\n  \"keep\",\n  \"ketchup\",\n  \"key\",\n  \"kick\",\n  \"kid\",\n  \"kidney\",\n  \"kind\",\n  \"kingdom\",\n  \"kiss\",\n  \"kit\",\n  \"kitchen\",\n  \"kite\",\n  \"kitten\",\n  \"kiwi\",\n  \"knee\",\n  \"knife\",\n  \"knock\",\n  \"know\",\n  \"lab\",\n  \"label\",\n  \"labor\",\n  \"ladder\",\n  \"lady\",\n  \"lake\",\n  \"lamp\",\n  \"language\",\n  \"laptop\",\n  \"large\",\n  \"later\",\n  \"latin\",\n  \"laugh\",\n  \"laundry\",\n  \"lava\",\n  \"law\",\n  \"lawn\",\n  \"lawsuit\",\n  \"layer\",\n  \"lazy\",\n  \"leader\",\n  \"leaf\",\n  \"learn\",\n  \"leave\",\n  \"lecture\",\n  \"left\",\n  \"leg\",\n  \"legal\",\n  \"legend\",\n  \"leisure\",\n  \"lemon\",\n  \"lend\",\n  \"length\",\n  \"lens\",\n  \"leopard\",\n  \"lesson\",\n  \"letter\",\n  \"level\",\n  \"liar\",\n  \"liberty\",\n  \"library\",\n  \"license\",\n  \"life\",\n  \"lift\",\n  \"light\",\n  \"like\",\n  \"limb\",\n  \"limit\",\n  \"link\",\n  \"lion\",\n  \"liquid\",\n  \"list\",\n  \"little\",\n  \"live\",\n  \"lizard\",\n  \"load\",\n  \"loan\",\n  \"lobster\",\n  \"local\",\n  \"lock\",\n  \"logic\",\n  \"lonely\",\n  \"long\",\n  \"loop\",\n  \"lottery\",\n  \"loud\",\n  \"lounge\",\n  \"love\",\n  \"loyal\",\n  \"lucky\",\n  \"luggage\",\n  \"lumber\",\n  \"lunar\",\n  \"lunch\",\n  \"luxury\",\n  \"lyrics\",\n  \"machine\",\n  \"mad\",\n  \"magic\",\n  \"magnet\",\n  \"maid\",\n  \"mail\",\n  \"main\",\n  \"major\",\n  \"make\",\n  \"mammal\",\n  \"man\",\n  \"manage\",\n  \"mandate\",\n  \"mango\",\n  \"mansion\",\n  \"manual\",\n  \"maple\",\n  \"marble\",\n  \"march\",\n  \"margin\",\n  \"marine\",\n  \"market\",\n  \"marriage\",\n  \"mask\",\n  \"mass\",\n  \"master\",\n  \"match\",\n  \"material\",\n  \"math\",\n  \"matrix\",\n  \"matter\",\n  \"maximum\",\n  \"maze\",\n  \"meadow\",\n  \"mean\",\n  \"measure\",\n  \"meat\",\n  \"mechanic\",\n  \"medal\",\n  \"media\",\n  \"melody\",\n  \"melt\",\n  \"member\",\n  \"memory\",\n  \"mention\",\n  \"menu\",\n  \"mercy\",\n  \"merge\",\n  \"merit\",\n  \"merry\",\n  \"mesh\",\n  \"message\",\n  \"metal\",\n  \"method\",\n  \"middle\",\n  \"midnight\",\n  \"milk\",\n  \"million\",\n  \"mimic\",\n  \"mind\",\n  \"minimum\",\n  \"minor\",\n  \"minute\",\n  \"miracle\",\n  \"mirror\",\n  \"misery\",\n  \"miss\",\n  \"mistake\",\n  \"mix\",\n  \"mixed\",\n  \"mixture\",\n  \"mobile\",\n  \"model\",\n  \"modify\",\n  \"mom\",\n  \"moment\",\n  \"monitor\",\n  \"monkey\",\n  \"monster\",\n  \"month\",\n  \"moon\",\n  \"moral\",\n  \"more\",\n  \"morning\",\n  \"mosquito\",\n  \"mother\",\n  \"motion\",\n  \"motor\",\n  \"mountain\",\n  \"mouse\",\n  \"move\",\n  \"movie\",\n  \"much\",\n  \"muffin\",\n  \"mule\",\n  \"multiply\",\n  \"muscle\",\n  \"museum\",\n  \"mushroom\",\n  \"music\",\n  \"must\",\n  \"mutual\",\n  \"myself\",\n  \"mystery\",\n  \"myth\",\n  \"naive\",\n  \"name\",\n  \"napkin\",\n  \"narrow\",\n  \"nasty\",\n  \"nation\",\n  \"nature\",\n  \"near\",\n  \"neck\",\n  \"need\",\n  \"negative\",\n  \"neglect\",\n  \"neither\",\n  \"nephew\",\n  \"nerve\",\n  \"nest\",\n  \"net\",\n  \"network\",\n  \"neutral\",\n  \"never\",\n  \"news\",\n  \"next\",\n  \"nice\",\n  \"night\",\n  \"noble\",\n  \"noise\",\n  \"nominee\",\n  \"noodle\",\n  \"normal\",\n  \"north\",\n  \"nose\",\n  \"notable\",\n  \"note\",\n  \"nothing\",\n  \"notice\",\n  \"novel\",\n  \"now\",\n  \"nuclear\",\n  \"number\",\n  \"nurse\",\n  \"nut\",\n  \"oak\",\n  \"obey\",\n  \"object\",\n  \"oblige\",\n  \"obscure\",\n  \"observe\",\n  \"obtain\",\n  \"obvious\",\n  \"occur\",\n  \"ocean\",\n  \"october\",\n  \"odor\",\n  \"off\",\n  \"offer\",\n  \"office\",\n  \"often\",\n  \"oil\",\n  \"okay\",\n  \"old\",\n  \"olive\",\n  \"olympic\",\n  \"omit\",\n  \"once\",\n  \"one\",\n  \"onion\",\n  \"online\",\n  \"only\",\n  \"open\",\n  \"opera\",\n  \"opinion\",\n  \"oppose\",\n  \"option\",\n  \"orange\",\n  \"orbit\",\n  \"orchard\",\n  \"order\",\n  \"ordinary\",\n  \"organ\",\n  \"orient\",\n  \"original\",\n  \"orphan\",\n  \"ostrich\",\n  \"other\",\n  \"outdoor\",\n  \"outer\",\n  \"output\",\n  \"outside\",\n  \"oval\",\n  \"oven\",\n  \"over\",\n  \"own\",\n  \"owner\",\n  \"oxygen\",\n  \"oyster\",\n  \"ozone\",\n  \"pact\",\n  \"paddle\",\n  \"page\",\n  \"pair\",\n  \"palace\",\n  \"palm\",\n  \"panda\",\n  \"panel\",\n  \"panic\",\n  \"panther\",\n  \"paper\",\n  \"parade\",\n  \"parent\",\n  \"park\",\n  \"parrot\",\n  \"party\",\n  \"pass\",\n  \"patch\",\n  \"path\",\n  \"patient\",\n  \"patrol\",\n  \"pattern\",\n  \"pause\",\n  \"pave\",\n  \"payment\",\n  \"peace\",\n  \"peanut\",\n  \"pear\",\n  \"peasant\",\n  \"pelican\",\n  \"pen\",\n  \"penalty\",\n  \"pencil\",\n  \"people\",\n  \"pepper\",\n  \"perfect\",\n  \"permit\",\n  \"person\",\n  \"pet\",\n  \"phone\",\n  \"photo\",\n  \"phrase\",\n  \"physical\",\n  \"piano\",\n  \"picnic\",\n  \"picture\",\n  \"piece\",\n  \"pig\",\n  \"pigeon\",\n  \"pill\",\n  \"pilot\",\n  \"pink\",\n  \"pioneer\",\n  \"pipe\",\n  \"pistol\",\n  \"pitch\",\n  \"pizza\",\n  \"place\",\n  \"planet\",\n  \"plastic\",\n  \"plate\",\n  \"play\",\n  \"please\",\n  \"pledge\",\n  \"pluck\",\n  \"plug\",\n  \"plunge\",\n  \"poem\",\n  \"poet\",\n  \"point\",\n  \"polar\",\n  \"pole\",\n  \"police\",\n  \"pond\",\n  \"pony\",\n  \"pool\",\n  \"popular\",\n  \"portion\",\n  \"position\",\n  \"possible\",\n  \"post\",\n  \"potato\",\n  \"pottery\",\n  \"poverty\",\n  \"powder\",\n  \"power\",\n  \"practice\",\n  \"praise\",\n  \"predict\",\n  \"prefer\",\n  \"prepare\",\n  \"present\",\n  \"pretty\",\n  \"prevent\",\n  \"price\",\n  \"pride\",\n  \"primary\",\n  \"print\",\n  \"priority\",\n  \"prison\",\n  \"private\",\n  \"prize\",\n  \"problem\",\n  \"process\",\n  \"produce\",\n  \"profit\",\n  \"program\",\n  \"project\",\n  \"promote\",\n  \"proof\",\n  \"property\",\n  \"prosper\",\n  \"protect\",\n  \"proud\",\n  \"provide\",\n  \"public\",\n  \"pudding\",\n  \"pull\",\n  \"pulp\",\n  \"pulse\",\n  \"pumpkin\",\n  \"punch\",\n  \"pupil\",\n  \"puppy\",\n  \"purchase\",\n  \"purity\",\n  \"purpose\",\n  \"purse\",\n  \"push\",\n  \"put\",\n  \"puzzle\",\n  \"pyramid\",\n  \"quality\",\n  \"quantum\",\n  \"quarter\",\n  \"question\",\n  \"quick\",\n  \"quit\",\n  \"quiz\",\n  \"quote\",\n  \"rabbit\",\n  \"raccoon\",\n  \"race\",\n  \"rack\",\n  \"radar\",\n  \"radio\",\n  \"rail\",\n  \"rain\",\n  \"raise\",\n  \"rally\",\n  \"ramp\",\n  \"ranch\",\n  \"random\",\n  \"range\",\n  \"rapid\",\n  \"rare\",\n  \"rate\",\n  \"rather\",\n  \"raven\",\n  \"raw\",\n  \"razor\",\n  \"ready\",\n  \"real\",\n  \"reason\",\n  \"rebel\",\n  \"rebuild\",\n  \"recall\",\n  \"receive\",\n  \"recipe\",\n  \"record\",\n  \"recycle\",\n  \"reduce\",\n  \"reflect\",\n  \"reform\",\n  \"refuse\",\n  \"region\",\n  \"regret\",\n  \"regular\",\n  \"reject\",\n  \"relax\",\n  \"release\",\n  \"relief\",\n  \"rely\",\n  \"remain\",\n  \"remember\",\n  \"remind\",\n  \"remove\",\n  \"render\",\n  \"renew\",\n  \"rent\",\n  \"reopen\",\n  \"repair\",\n  \"repeat\",\n  \"replace\",\n  \"report\",\n  \"require\",\n  \"rescue\",\n  \"resemble\",\n  \"resist\",\n  \"resource\",\n  \"response\",\n  \"result\",\n  \"retire\",\n  \"retreat\",\n  \"return\",\n  \"reunion\",\n  \"reveal\",\n  \"review\",\n  \"reward\",\n  \"rhythm\",\n  \"rib\",\n  \"ribbon\",\n  \"rice\",\n  \"rich\",\n  \"ride\",\n  \"ridge\",\n  \"rifle\",\n  \"right\",\n  \"rigid\",\n  \"ring\",\n  \"riot\",\n  \"ripple\",\n  \"risk\",\n  \"ritual\",\n  \"rival\",\n  \"river\",\n  \"road\",\n  \"roast\",\n  \"robot\",\n  \"robust\",\n  \"rocket\",\n  \"romance\",\n  \"roof\",\n  \"rookie\",\n  \"room\",\n  \"rose\",\n  \"rotate\",\n  \"rough\",\n  \"round\",\n  \"route\",\n  \"royal\",\n  \"rubber\",\n  \"rude\",\n  \"rug\",\n  \"rule\",\n  \"run\",\n  \"runway\",\n  \"rural\",\n  \"sad\",\n  \"saddle\",\n  \"sadness\",\n  \"safe\",\n  \"sail\",\n  \"salad\",\n  \"salmon\",\n  \"salon\",\n  \"salt\",\n  \"salute\",\n  \"same\",\n  \"sample\",\n  \"sand\",\n  \"satisfy\",\n  \"satoshi\",\n  \"sauce\",\n  \"sausage\",\n  \"save\",\n  \"say\",\n  \"scale\",\n  \"scan\",\n  \"scare\",\n  \"scatter\",\n  \"scene\",\n  \"scheme\",\n  \"school\",\n  \"science\",\n  \"scissors\",\n  \"scorpion\",\n  \"scout\",\n  \"scrap\",\n  \"screen\",\n  \"script\",\n  \"scrub\",\n  \"sea\",\n  \"search\",\n  \"season\",\n  \"seat\",\n  \"second\",\n  \"secret\",\n  \"section\",\n  \"security\",\n  \"seed\",\n  \"seek\",\n  \"segment\",\n  \"select\",\n  \"sell\",\n  \"seminar\",\n  \"senior\",\n  \"sense\",\n  \"sentence\",\n  \"series\",\n  \"service\",\n  \"session\",\n  \"settle\",\n  \"setup\",\n  \"seven\",\n  \"shadow\",\n  \"shaft\",\n  \"shallow\",\n  \"share\",\n  \"shed\",\n  \"shell\",\n  \"sheriff\",\n  \"shield\",\n  \"shift\",\n  \"shine\",\n  \"ship\",\n  \"shiver\",\n  \"shock\",\n  \"shoe\",\n  \"shoot\",\n  \"shop\",\n  \"short\",\n  \"shoulder\",\n  \"shove\",\n  \"shrimp\",\n  \"shrug\",\n  \"shuffle\",\n  \"shy\",\n  \"sibling\",\n  \"sick\",\n  \"side\",\n  \"siege\",\n  \"sight\",\n  \"sign\",\n  \"silent\",\n  \"silk\",\n  \"silly\",\n  \"silver\",\n  \"similar\",\n  \"simple\",\n  \"since\",\n  \"sing\",\n  \"siren\",\n  \"sister\",\n  \"situate\",\n  \"six\",\n  \"size\",\n  \"skate\",\n  \"sketch\",\n  \"ski\",\n  \"skill\",\n  \"skin\",\n  \"skirt\",\n  \"skull\",\n  \"slab\",\n  \"slam\",\n  \"sleep\",\n  \"slender\",\n  \"slice\",\n  \"slide\",\n  \"slight\",\n  \"slim\",\n  \"slogan\",\n  \"slot\",\n  \"slow\",\n  \"slush\",\n  \"small\",\n  \"smart\",\n  \"smile\",\n  \"smoke\",\n  \"smooth\",\n  \"snack\",\n  \"snake\",\n  \"snap\",\n  \"sniff\",\n  \"snow\",\n  \"soap\",\n  \"soccer\",\n  \"social\",\n  \"sock\",\n  \"soda\",\n  \"soft\",\n  \"solar\",\n  \"soldier\",\n  \"solid\",\n  \"solution\",\n  \"solve\",\n  \"someone\",\n  \"song\",\n  \"soon\",\n  \"sorry\",\n  \"sort\",\n  \"soul\",\n  \"sound\",\n  \"soup\",\n  \"source\",\n  \"south\",\n  \"space\",\n  \"spare\",\n  \"spatial\",\n  \"spawn\",\n  \"speak\",\n  \"special\",\n  \"speed\",\n  \"spell\",\n  \"spend\",\n  \"sphere\",\n  \"spice\",\n  \"spider\",\n  \"spike\",\n  \"spin\",\n  \"spirit\",\n  \"split\",\n  \"spoil\",\n  \"sponsor\",\n  \"spoon\",\n  \"sport\",\n  \"spot\",\n  \"spray\",\n  \"spread\",\n  \"spring\",\n  \"spy\",\n  \"square\",\n  \"squeeze\",\n  \"squirrel\",\n  \"stable\",\n  \"stadium\",\n  \"staff\",\n  \"stage\",\n  \"stairs\",\n  \"stamp\",\n  \"stand\",\n  \"start\",\n  \"state\",\n  \"stay\",\n  \"steak\",\n  \"steel\",\n  \"stem\",\n  \"step\",\n  \"stereo\",\n  \"stick\",\n  \"still\",\n  \"sting\",\n  \"stock\",\n  \"stomach\",\n  \"stone\",\n  \"stool\",\n  \"story\",\n  \"stove\",\n  \"strategy\",\n  \"street\",\n  \"strike\",\n  \"strong\",\n  \"struggle\",\n  \"student\",\n  \"stuff\",\n  \"stumble\",\n  \"style\",\n  \"subject\",\n  \"submit\",\n  \"subway\",\n  \"success\",\n  \"such\",\n  \"sudden\",\n  \"suffer\",\n  \"sugar\",\n  \"suggest\",\n  \"suit\",\n  \"summer\",\n  \"sun\",\n  \"sunny\",\n  \"sunset\",\n  \"super\",\n  \"supply\",\n  \"supreme\",\n  \"sure\",\n  \"surface\",\n  \"surge\",\n  \"surprise\",\n  \"surround\",\n  \"survey\",\n  \"suspect\",\n  \"sustain\",\n  \"swallow\",\n  \"swamp\",\n  \"swap\",\n  \"swarm\",\n  \"swear\",\n  \"sweet\",\n  \"swift\",\n  \"swim\",\n  \"swing\",\n  \"switch\",\n  \"sword\",\n  \"symbol\",\n  \"symptom\",\n  \"syrup\",\n  \"system\",\n  \"table\",\n  \"tackle\",\n  \"tag\",\n  \"tail\",\n  \"talent\",\n  \"talk\",\n  \"tank\",\n  \"tape\",\n  \"target\",\n  \"task\",\n  \"taste\",\n  \"tattoo\",\n  \"taxi\",\n  \"teach\",\n  \"team\",\n  \"tell\",\n  \"ten\",\n  \"tenant\",\n  \"tennis\",\n  \"tent\",\n  \"term\",\n  \"test\",\n  \"text\",\n  \"thank\",\n  \"that\",\n  \"theme\",\n  \"then\",\n  \"theory\",\n  \"there\",\n  \"they\",\n  \"thing\",\n  \"this\",\n  \"thought\",\n  \"three\",\n  \"thrive\",\n  \"throw\",\n  \"thumb\",\n  \"thunder\",\n  \"ticket\",\n  \"tide\",\n  \"tiger\",\n  \"tilt\",\n  \"timber\",\n  \"time\",\n  \"tiny\",\n  \"tip\",\n  \"tired\",\n  \"tissue\",\n  \"title\",\n  \"toast\",\n  \"tobacco\",\n  \"today\",\n  \"toddler\",\n  \"toe\",\n  \"together\",\n  \"toilet\",\n  \"token\",\n  \"tomato\",\n  \"tomorrow\",\n  \"tone\",\n  \"tongue\",\n  \"tonight\",\n  \"tool\",\n  \"tooth\",\n  \"top\",\n  \"topic\",\n  \"topple\",\n  \"torch\",\n  \"tornado\",\n  \"tortoise\",\n  \"toss\",\n  \"total\",\n  \"tourist\",\n  \"toward\",\n  \"tower\",\n  \"town\",\n  \"toy\",\n  \"track\",\n  \"trade\",\n  \"traffic\",\n  \"tragic\",\n  \"train\",\n  \"transfer\",\n  \"trap\",\n  \"trash\",\n  \"travel\",\n  \"tray\",\n  \"treat\",\n  \"tree\",\n  \"trend\",\n  \"trial\",\n  \"tribe\",\n  \"trick\",\n  \"trigger\",\n  \"trim\",\n  \"trip\",\n  \"trophy\",\n  \"trouble\",\n  \"truck\",\n  \"true\",\n  \"truly\",\n  \"trumpet\",\n  \"trust\",\n  \"truth\",\n  \"try\",\n  \"tube\",\n  \"tuition\",\n  \"tumble\",\n  \"tuna\",\n  \"tunnel\",\n  \"turkey\",\n  \"turn\",\n  \"turtle\",\n  \"twelve\",\n  \"twenty\",\n  \"twice\",\n  \"twin\",\n  \"twist\",\n  \"two\",\n  \"type\",\n  \"typical\",\n  \"ugly\",\n  \"umbrella\",\n  \"unable\",\n  \"unaware\",\n  \"uncle\",\n  \"uncover\",\n  \"under\",\n  \"undo\",\n  \"unfair\",\n  \"unfold\",\n  \"unhappy\",\n  \"uniform\",\n  \"unique\",\n  \"unit\",\n  \"universe\",\n  \"unknown\",\n  \"unlock\",\n  \"until\",\n  \"unusual\",\n  \"unveil\",\n  \"update\",\n  \"upgrade\",\n  \"uphold\",\n  \"upon\",\n  \"upper\",\n  \"upset\",\n  \"urban\",\n  \"urge\",\n  \"usage\",\n  \"use\",\n  \"used\",\n  \"useful\",\n  \"useless\",\n  \"usual\",\n  \"utility\",\n  \"vacant\",\n  \"vacuum\",\n  \"vague\",\n  \"valid\",\n  \"valley\",\n  \"valve\",\n  \"van\",\n  \"vanish\",\n  \"vapor\",\n  \"various\",\n  \"vast\",\n  \"vault\",\n  \"vehicle\",\n  \"velvet\",\n  \"vendor\",\n  \"venture\",\n  \"venue\",\n  \"verb\",\n  \"verify\",\n  \"version\",\n  \"very\",\n  \"vessel\",\n  \"veteran\",\n  \"viable\",\n  \"vibrant\",\n  \"vicious\",\n  \"victory\",\n  \"video\",\n  \"view\",\n  \"village\",\n  \"vintage\",\n  \"violin\",\n  \"virtual\",\n  \"virus\",\n  \"visa\",\n  \"visit\",\n  \"visual\",\n  \"vital\",\n  \"vivid\",\n  \"vocal\",\n  \"voice\",\n  \"void\",\n  \"volcano\",\n  \"volume\",\n  \"vote\",\n  \"voyage\",\n  \"wage\",\n  \"wagon\",\n  \"wait\",\n  \"walk\",\n  \"wall\",\n  \"walnut\",\n  \"want\",\n  \"warfare\",\n  \"warm\",\n  \"warrior\",\n  \"wash\",\n  \"wasp\",\n  \"waste\",\n  \"water\",\n  \"wave\",\n  \"way\",\n  \"wealth\",\n  \"weapon\",\n  \"wear\",\n  \"weasel\",\n  \"weather\",\n  \"web\",\n  \"wedding\",\n  \"weekend\",\n  \"weird\",\n  \"welcome\",\n  \"west\",\n  \"wet\",\n  \"whale\",\n  \"what\",\n  \"wheat\",\n  \"wheel\",\n  \"when\",\n  \"where\",\n  \"whip\",\n  \"whisper\",\n  \"wide\",\n  \"width\",\n  \"wife\",\n  \"wild\",\n  \"will\",\n  \"win\",\n  \"window\",\n  \"wine\",\n  \"wing\",\n  \"wink\",\n  \"winner\",\n  \"winter\",\n  \"wire\",\n  \"wisdom\",\n  \"wise\",\n  \"wish\",\n  \"witness\",\n  \"wolf\",\n  \"woman\",\n  \"wonder\",\n  \"wood\",\n  \"wool\",\n  \"word\",\n  \"work\",\n  \"world\",\n  \"worry\",\n  \"worth\",\n  \"wrap\",\n  \"wreck\",\n  \"wrestle\",\n  \"wrist\",\n  \"write\",\n  \"wrong\",\n  \"yard\",\n  \"year\",\n  \"yellow\",\n  \"you\",\n  \"young\",\n  \"youth\",\n  \"zebra\",\n  \"zero\",\n  \"zone\",\n  \"zoo\"\n];\n\n// src/wordlists/index.ts\nvar Language = /* @__PURE__ */ ((Language2) => {\n  Language2[\"english\"] = \"english\";\n  return Language2;\n})(Language || {});\n\n// src/mnemonic/utils.ts\nimport { ErrorCode as ErrorCode22, FuelError as FuelError24 } from \"@fuel-ts/errors\";\nimport { sha256 as sha2562 } from \"@fuel-ts/hasher\";\nimport { arrayify as arrayify19 } from \"@fuel-ts/utils\";\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\n__name(getLowerMask, \"getLowerMask\");\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n}\n__name(getUpperMask, \"getUpperMask\");\nfunction getWords(mnemonic) {\n  if (!Array.isArray(mnemonic)) {\n    return mnemonic.split(/\\s+/);\n  }\n  return mnemonic;\n}\n__name(getWords, \"getWords\");\nfunction getPhrase(mnemonic) {\n  if (Array.isArray(mnemonic)) {\n    return mnemonic.join(\" \");\n  }\n  return mnemonic;\n}\n__name(getPhrase, \"getPhrase\");\nfunction entropyToMnemonicIndices(entropy) {\n  const indices = [0];\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i += 1) {\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify19(sha2562(entropy))[0] & getUpperMask(checksumBits);\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return indices;\n}\n__name(entropyToMnemonicIndices, \"entropyToMnemonicIndices\");\nfunction mnemonicWordsToEntropy(words, wordlist) {\n  const size = Math.ceil(11 * words.length / 8);\n  const entropy = arrayify19(new Uint8Array(size));\n  let offset = 0;\n  for (let i = 0; i < words.length; i += 1) {\n    const index = wordlist.indexOf(words[i].normalize(\"NFKD\"));\n    if (index === -1) {\n      throw new FuelError24(\n        ErrorCode22.INVALID_MNEMONIC,\n        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`\n      );\n    }\n    for (let bit = 0; bit < 11; bit += 1) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset += 1;\n    }\n  }\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify19(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new FuelError24(\n      ErrorCode22.INVALID_CHECKSUM,\n      \"Checksum validation failed for the provided mnemonic.\"\n    );\n  }\n  return entropy.slice(0, entropyBits / 8);\n}\n__name(mnemonicWordsToEntropy, \"mnemonicWordsToEntropy\");\n\n// src/mnemonic/mnemonic.ts\nvar MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\nvar MainnetPRV = \"0x0488ade4\";\nvar TestnetPRV = \"0x04358394\";\nvar MNEMONIC_SIZES = [12, 15, 18, 21, 24];\nfunction assertWordList(wordlist) {\n  if (wordlist.length !== 2048) {\n    throw new FuelError25(\n      ErrorCode23.INVALID_WORD_LIST,\n      `Expected word list length of 2048, but got ${wordlist.length}.`\n    );\n  }\n}\n__name(assertWordList, \"assertWordList\");\nfunction assertEntropy(entropy) {\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new FuelError25(\n      ErrorCode23.INVALID_ENTROPY,\n      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`\n    );\n  }\n}\n__name(assertEntropy, \"assertEntropy\");\nfunction assertMnemonic(words) {\n  if (!MNEMONIC_SIZES.includes(words.length)) {\n    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(\n      \", \"\n    )}] words, but got ${words.length}.`;\n    throw new FuelError25(ErrorCode23.INVALID_MNEMONIC, errorMsg);\n  }\n}\n__name(assertMnemonic, \"assertMnemonic\");\nvar Mnemonic = class _Mnemonic {\n  static {\n    __name(this, \"Mnemonic\");\n  }\n  wordlist;\n  /**\n   *\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic instance\n   */\n  constructor(wordlist = english) {\n    this.wordlist = wordlist;\n    assertWordList(this.wordlist);\n  }\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns Entropy hash\n   */\n  mnemonicToEntropy(phrase) {\n    return _Mnemonic.mnemonicToEntropy(phrase, this.wordlist);\n  }\n  /**\n   *\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @returns Mnemonic phrase\n   */\n  entropyToMnemonic(entropy) {\n    return _Mnemonic.entropyToMnemonic(entropy, this.wordlist);\n  }\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic phrase\n   */\n  static mnemonicToEntropy(phrase, wordlist = english) {\n    const words = getWords(phrase);\n    assertMnemonic(words);\n    return hexlify22(mnemonicWordsToEntropy(words, wordlist));\n  }\n  /**\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static entropyToMnemonic(entropy, wordlist = english) {\n    const entropyBytes = arrayify20(entropy);\n    assertWordList(wordlist);\n    assertEntropy(entropyBytes);\n    return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(\" \");\n  }\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToSeed(phrase, passphrase = \"\") {\n    assertMnemonic(getWords(phrase));\n    const phraseBytes = toUtf8Bytes(getPhrase(phrase));\n    const salt = toUtf8Bytes(`mnemonic${passphrase}`);\n    return pbkdf2(phraseBytes, salt, 2048, 64, \"sha512\");\n  }\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToMasterKeys(phrase, passphrase = \"\") {\n    const seed = _Mnemonic.mnemonicToSeed(phrase, passphrase);\n    return _Mnemonic.masterKeysFromSeed(seed);\n  }\n  /**\n   * Validates if given mnemonic is  valid\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns true if phrase is a valid mnemonic\n   */\n  static isMnemonicValid(phrase) {\n    const words = getWords(phrase);\n    let i = 0;\n    try {\n      assertMnemonic(words);\n    } catch {\n      return false;\n    }\n    while (i < words.length) {\n      if (_Mnemonic.binarySearch(words[i]) === false) {\n        return false;\n      }\n      i += 1;\n    }\n    return true;\n  }\n  static binarySearch(target) {\n    const words = english;\n    let left = 0;\n    let right = words.length - 1;\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (words[mid] === target) {\n        return true;\n      }\n      if (target < words[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n    return false;\n  }\n  /**\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static masterKeysFromSeed(seed) {\n    const seedArray = arrayify20(seed);\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new FuelError25(\n        ErrorCode23.INVALID_SEED,\n        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`\n      );\n    }\n    return arrayify20(computeHmac(\"sha512\", MasterSecret, seedArray));\n  }\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  static seedToExtendedKey(seed, testnet = false) {\n    const masterKey = _Mnemonic.masterKeysFromSeed(seed);\n    const prefix = arrayify20(testnet ? TestnetPRV : MainnetPRV);\n    const depth = \"0x00\";\n    const fingerprint = \"0x00000000\";\n    const index = \"0x00000000\";\n    const chainCode = masterKey.slice(32);\n    const privateKey = masterKey.slice(0, 32);\n    const extendedKey = concat6([\n      prefix,\n      depth,\n      fingerprint,\n      index,\n      chainCode,\n      concat6([\"0x00\", privateKey])\n    ]);\n    const checksum = dataSlice(sha2563(sha2563(extendedKey)), 0, 4);\n    return encodeBase58(concat6([extendedKey, checksum]));\n  }\n  /**\n   *  Create a new mnemonic using a randomly generated number as entropy.\n   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.\n   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.\n   *  If not provided, the default entropy length will be set to 256 bits.\n   *  The return is a list of words that encodes the generated entropy.\n   *\n   *\n   * @param size - Number of bytes used as an entropy\n   * @param extraEntropy - Optional extra entropy to increase randomness\n   * @returns A randomly generated mnemonic\n   */\n  static generate(size = 32, extraEntropy = \"\") {\n    const entropy = extraEntropy ? sha2563(concat6([randomBytes5(size), arrayify20(extraEntropy)])) : randomBytes5(size);\n    return _Mnemonic.entropyToMnemonic(entropy);\n  }\n};\nvar mnemonic_default = Mnemonic;\n\n// src/hdwallet/hdwallet.ts\nvar HARDENED_INDEX = 2147483648;\nvar MainnetPRV2 = hexlify23(\"0x0488ade4\");\nvar MainnetPUB = hexlify23(\"0x0488b21e\");\nvar TestnetPRV2 = hexlify23(\"0x04358394\");\nvar TestnetPUB = hexlify23(\"0x043587cf\");\nfunction base58check(data) {\n  return encodeBase582(concat7([data, dataSlice2(sha2564(sha2564(data)), 0, 4)]));\n}\n__name(base58check, \"base58check\");\nfunction getExtendedKeyPrefix(isPublic = false, testnet = false) {\n  if (isPublic) {\n    return testnet ? TestnetPUB : MainnetPUB;\n  }\n  return testnet ? TestnetPRV2 : MainnetPRV2;\n}\n__name(getExtendedKeyPrefix, \"getExtendedKeyPrefix\");\nfunction isPublicExtendedKey(extendedKey) {\n  return [MainnetPUB, TestnetPUB].includes(hexlify23(extendedKey.slice(0, 4)));\n}\n__name(isPublicExtendedKey, \"isPublicExtendedKey\");\nfunction isValidExtendedKey(extendedKey) {\n  return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(\n    hexlify23(extendedKey.slice(0, 4))\n  );\n}\n__name(isValidExtendedKey, \"isValidExtendedKey\");\nfunction parsePath(path, depth = 0) {\n  const components = path.split(\"/\");\n  if (components.length === 0 || components[0] === \"m\" && depth !== 0) {\n    throw new FuelError26(ErrorCode24.HD_WALLET_ERROR, `invalid path - ${path}`);\n  }\n  if (components[0] === \"m\") {\n    components.shift();\n  }\n  return components.map(\n    (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)\n  );\n}\n__name(parsePath, \"parsePath\");\nvar HDWallet = class _HDWallet {\n  static {\n    __name(this, \"HDWallet\");\n  }\n  depth = 0;\n  index = 0;\n  fingerprint = hexlify23(\"0x00000000\");\n  parentFingerprint = hexlify23(\"0x00000000\");\n  privateKey;\n  publicKey;\n  chainCode;\n  /**\n   * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets\n   *\n   * @param config - Wallet configurations\n   */\n  constructor(config) {\n    if (config.privateKey) {\n      const signer = new Signer(config.privateKey);\n      this.publicKey = hexlify23(signer.compressedPublicKey);\n      this.privateKey = hexlify23(config.privateKey);\n    } else {\n      if (!config.publicKey) {\n        throw new FuelError26(\n          ErrorCode24.HD_WALLET_ERROR,\n          \"Both public and private Key cannot be missing. At least one should be provided.\"\n        );\n      }\n      this.publicKey = hexlify23(config.publicKey);\n    }\n    this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;\n    this.fingerprint = dataSlice2(ripemd160(sha2564(this.publicKey)), 0, 4);\n    this.depth = config.depth || this.depth;\n    this.index = config.index || this.index;\n    this.chainCode = config.chainCode;\n  }\n  get extendedKey() {\n    return this.toExtendedKey();\n  }\n  /**\n   * Derive the current HDWallet instance navigating only on the index.\n   * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n   *\n   * @param index - Index of the child HDWallet.\n   * @returns A new instance of HDWallet on the derived index\n   */\n  deriveIndex(index) {\n    const privateKey = this.privateKey && arrayify21(this.privateKey);\n    const publicKey = arrayify21(this.publicKey);\n    const chainCode = arrayify21(this.chainCode);\n    const data = new Uint8Array(37);\n    if (index & HARDENED_INDEX) {\n      if (!privateKey) {\n        throw new FuelError26(\n          ErrorCode24.HD_WALLET_ERROR,\n          \"Cannot derive a hardened index without a private Key.\"\n        );\n      }\n      data.set(privateKey, 1);\n    } else {\n      data.set(arrayify21(this.publicKey));\n    }\n    data.set(toBytes3(index, 4), 33);\n    const bytes = arrayify21(computeHmac2(\"sha512\", chainCode, data));\n    const IL = bytes.slice(0, 32);\n    const IR = bytes.slice(32);\n    if (privateKey) {\n      const N = \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\";\n      const ki = bn23(IL).add(privateKey).mod(N).toBytes(32);\n      return new _HDWallet({\n        privateKey: ki,\n        chainCode: IR,\n        index,\n        depth: this.depth + 1,\n        parentFingerprint: this.fingerprint\n      });\n    }\n    const signer = new Signer(hexlify23(IL));\n    const Ki = signer.addPoint(publicKey);\n    return new _HDWallet({\n      publicKey: Ki,\n      chainCode: IR,\n      index,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint\n    });\n  }\n  /**\n   * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n   *\n   * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`\n   * @returns A new instance of HDWallet on the derived path\n   */\n  derivePath(path) {\n    const paths = parsePath(path, this.depth);\n    return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);\n  }\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  toExtendedKey(isPublic = false, testnet = false) {\n    if (this.depth >= 256) {\n      throw new FuelError26(\n        ErrorCode24.HD_WALLET_ERROR,\n        `Exceeded max depth of 255. Current depth: ${this.depth}.`\n      );\n    }\n    const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);\n    const depth = hexlify23(Uint8Array.from([this.depth]));\n    const parentFingerprint = this.parentFingerprint;\n    const index = toHex(this.index, 4);\n    const chainCode = this.chainCode;\n    const key = this.privateKey != null && !isPublic ? concat7([\"0x00\", this.privateKey]) : this.publicKey;\n    const extendedKey = arrayify21(concat7([prefix, depth, parentFingerprint, index, chainCode, key]));\n    return base58check(extendedKey);\n  }\n  /**\n   * Create HDWallet instance from seed\n   *\n   * @param seed - Seed\n   * @returns A new instance of HDWallet\n   */\n  static fromSeed(seed) {\n    const masterKey = mnemonic_default.masterKeysFromSeed(seed);\n    return new _HDWallet({\n      chainCode: arrayify21(masterKey.slice(32)),\n      privateKey: arrayify21(masterKey.slice(0, 32))\n    });\n  }\n  static fromExtendedKey(extendedKey) {\n    const decoded = hexlify23(toBytes3(decodeBase58(extendedKey)));\n    const bytes = arrayify21(decoded);\n    const validChecksum = base58check(bytes.slice(0, 78)) === extendedKey;\n    if (bytes.length !== 82 || !isValidExtendedKey(bytes)) {\n      throw new FuelError26(ErrorCode24.HD_WALLET_ERROR, \"Provided key is not a valid extended key.\");\n    }\n    if (!validChecksum) {\n      throw new FuelError26(ErrorCode24.HD_WALLET_ERROR, \"Provided key has an invalid checksum.\");\n    }\n    const depth = bytes[4];\n    const parentFingerprint = hexlify23(bytes.slice(5, 9));\n    const index = parseInt(hexlify23(bytes.slice(9, 13)).substring(2), 16);\n    const chainCode = hexlify23(bytes.slice(13, 45));\n    const key = bytes.slice(45, 78);\n    if (depth === 0 && parentFingerprint !== \"0x00000000\" || depth === 0 && index !== 0) {\n      throw new FuelError26(\n        ErrorCode24.HD_WALLET_ERROR,\n        \"Inconsistency detected: Depth is zero but fingerprint/index is non-zero.\"\n      );\n    }\n    if (isPublicExtendedKey(bytes)) {\n      if (key[0] !== 3) {\n        throw new FuelError26(ErrorCode24.HD_WALLET_ERROR, \"Invalid public extended key.\");\n      }\n      return new _HDWallet({\n        publicKey: key,\n        chainCode,\n        index,\n        depth,\n        parentFingerprint\n      });\n    }\n    if (key[0] !== 0) {\n      throw new FuelError26(ErrorCode24.HD_WALLET_ERROR, \"Invalid private extended key.\");\n    }\n    return new _HDWallet({\n      privateKey: key.slice(1),\n      chainCode,\n      index,\n      depth,\n      parentFingerprint\n    });\n  }\n};\nvar hdwallet_default = HDWallet;\n\n// src/wallet/wallets.ts\nvar WalletLocked = class extends Account {\n  static {\n    __name(this, \"WalletLocked\");\n  }\n  /**\n   * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.\n   *\n   * @param privateKey - The private key used to unlock the wallet.\n   * @returns An instance of WalletUnlocked.\n   */\n  unlock(privateKey) {\n    return new WalletUnlocked(privateKey, this._provider);\n  }\n};\nvar WalletUnlocked = class _WalletUnlocked extends BaseWalletUnlocked {\n  static {\n    __name(this, \"WalletUnlocked\");\n  }\n  /**\n   * Locks the wallet and returns an instance of WalletLocked.\n   *\n   * @returns An instance of WalletLocked.\n   */\n  lock() {\n    this.signer = () => new Signer(\"0x00\");\n    return new WalletLocked(this.address, this._provider);\n  }\n  /**\n   * Generate a new Wallet Unlocked with a random key pair.\n   *\n   * @param generateOptions - Options to customize the generation process (optional).\n   * @returns An instance of WalletUnlocked.\n   */\n  static generate(generateOptions) {\n    const privateKey = Signer.generatePrivateKey(generateOptions?.entropy);\n    return new _WalletUnlocked(privateKey, generateOptions?.provider);\n  }\n  /**\n   * Create a Wallet Unlocked from a seed.\n   *\n   * @param seed - The seed phrase.\n   * @param provider - A Provider instance (optional).\n   * @param path - The derivation path (optional).\n   * @returns An instance of WalletUnlocked.\n   */\n  static fromSeed(seed, path, provider) {\n    const hdWallet = hdwallet_default.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || _WalletUnlocked.defaultPath);\n    return new _WalletUnlocked(childWallet.privateKey, provider);\n  }\n  /**\n   * Create a Wallet Unlocked from a mnemonic phrase.\n   *\n   * @param mnemonic - The mnemonic phrase.\n   * @param provider - A Provider instance (optional).\n   * @param path - The derivation path (optional).\n   * @param passphrase - The passphrase for the mnemonic (optional).\n   * @returns An instance of WalletUnlocked.\n   */\n  static fromMnemonic(mnemonic, path, passphrase, provider) {\n    const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);\n    const hdWallet = hdwallet_default.fromSeed(seed);\n    const childWallet = hdWallet.derivePath(path || _WalletUnlocked.defaultPath);\n    return new _WalletUnlocked(childWallet.privateKey, provider);\n  }\n  /**\n   * Create a Wallet Unlocked from an extended key.\n   *\n   * @param extendedKey - The extended key.\n   * @param provider - A Provider instance (optional).\n   * @returns An instance of WalletUnlocked.\n   */\n  static fromExtendedKey(extendedKey, provider) {\n    const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);\n    return new _WalletUnlocked(hdWallet.privateKey, provider);\n  }\n  /**\n   * Create a Wallet Unlocked from an encrypted JSON.\n   *\n   * @param jsonWallet - The encrypted JSON keystore.\n   * @param password - The password to decrypt the JSON.\n   * @param provider - A Provider instance (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static async fromEncryptedJson(jsonWallet, password, provider) {\n    const privateKey = await decryptKeystoreWallet(jsonWallet, password);\n    return new _WalletUnlocked(privateKey, provider);\n  }\n};\n\n// src/wallet/wallet.ts\nvar Wallet = class {\n  static {\n    __name(this, \"Wallet\");\n  }\n  /**\n   * Creates a locked wallet instance from an address and a provider.\n   *\n   * @param address - The address of the wallet.\n   * @param provider - A Provider instance (optional).\n   * @returns A locked wallet instance.\n   */\n  static fromAddress(address, provider) {\n    return new WalletLocked(address, provider);\n  }\n  /**\n   * Creates an unlocked wallet instance from a private key and a provider.\n   *\n   * @param privateKey - The private key of the wallet.\n   * @param provider - A Provider instance (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static fromPrivateKey(privateKey, provider) {\n    return new WalletUnlocked(privateKey, provider);\n  }\n  /**\n   * Generate a new Wallet Unlocked with a random key pair.\n   *\n   * @param generateOptions - Options to customize the generation process (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static generate = WalletUnlocked.generate;\n  /**\n   * Create a Wallet Unlocked from a seed.\n   *\n   * @param seed - The seed phrase.\n   * @param provider - A Provider instance (optional).\n   * @param path - The derivation path (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static fromSeed = WalletUnlocked.fromSeed;\n  /**\n   * Create a Wallet Unlocked from a mnemonic phrase.\n   *\n   * @param mnemonic - The mnemonic phrase.\n   * @param provider - A Provider instance (optional).\n   * @param path - The derivation path (optional).\n   * @param passphrase - The passphrase for the mnemonic (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static fromMnemonic = WalletUnlocked.fromMnemonic;\n  /**\n   * Create a Wallet Unlocked from an extended key.\n   *\n   * @param extendedKey - The extended key.\n   * @param provider - A Provider instance (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static fromExtendedKey = WalletUnlocked.fromExtendedKey;\n  /**\n   * Create a Wallet Unlocked from an encrypted JSON.\n   *\n   * @param jsonWallet - The encrypted JSON keystore.\n   * @param password - The password to decrypt the JSON.\n   * @param provider - A Provider instance (optional).\n   * @returns An unlocked wallet instance.\n   */\n  static fromEncryptedJson = WalletUnlocked.fromEncryptedJson;\n};\n\n// src/wallet-manager/wallet-manager.ts\nimport { Address as Address10 } from \"@fuel-ts/address\";\nimport { encrypt, decrypt } from \"@fuel-ts/crypto\";\nimport { ErrorCode as ErrorCode27, FuelError as FuelError29 } from \"@fuel-ts/errors\";\nimport { EventEmitter } from \"events\";\n\n// src/wallet-manager/storages/memory-storage.ts\nvar MemoryStorage = class {\n  static {\n    __name(this, \"MemoryStorage\");\n  }\n  storage = /* @__PURE__ */ new Map();\n  async getItem(key) {\n    const item = await this.storage.get(key);\n    return item;\n  }\n  async setItem(key, value) {\n    await this.storage.set(key, value);\n  }\n  async removeItem(key) {\n    await this.storage.delete(key);\n  }\n  async clear() {\n    await this.storage.clear();\n  }\n};\n\n// src/wallet-manager/vaults/mnemonic-vault.ts\nimport { Address as Address8 } from \"@fuel-ts/address\";\nimport { ErrorCode as ErrorCode25, FuelError as FuelError27 } from \"@fuel-ts/errors\";\nvar MnemonicVault = class {\n  static {\n    __name(this, \"MnemonicVault\");\n  }\n  static type = \"mnemonic\";\n  #secret;\n  pathKey = \"{}\";\n  rootPath = `m/44'/1179993420'/${this.pathKey}'/0/0`;\n  numberOfAccounts = 0;\n  constructor(options) {\n    this.#secret = options.secret || mnemonic_default.generate();\n    this.rootPath = options.rootPath || this.rootPath;\n    this.numberOfAccounts = options.numberOfAccounts || 1;\n  }\n  getDerivePath(index) {\n    if (this.rootPath.includes(this.pathKey)) {\n      return this.rootPath.replace(this.pathKey, String(index));\n    }\n    return `${this.rootPath}/${index}`;\n  }\n  serialize() {\n    return {\n      secret: this.#secret,\n      rootPath: this.rootPath,\n      numberOfAccounts: this.numberOfAccounts\n    };\n  }\n  getAccounts() {\n    const accounts = [];\n    let numberOfAccounts = 0;\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      accounts.push({\n        publicKey: wallet.publicKey,\n        address: wallet.address\n      });\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n    return accounts;\n  }\n  addAccount() {\n    this.numberOfAccounts += 1;\n    const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(this.numberOfAccounts - 1));\n    return {\n      publicKey: wallet.publicKey,\n      address: wallet.address\n    };\n  }\n  exportAccount(address) {\n    let numberOfAccounts = 0;\n    const ownerAddress = new Address8(address);\n    do {\n      const wallet = Wallet.fromMnemonic(this.#secret, this.getDerivePath(numberOfAccounts));\n      if (wallet.address.equals(ownerAddress)) {\n        return wallet.privateKey;\n      }\n      numberOfAccounts += 1;\n    } while (numberOfAccounts < this.numberOfAccounts);\n    throw new FuelError27(\n      ErrorCode25.WALLET_MANAGER_ERROR,\n      `Account with address '${address}' not found in derived wallets.`\n    );\n  }\n  getWallet(address) {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n};\n\n// src/wallet-manager/vaults/privatekey-vault.ts\nimport { Address as Address9 } from \"@fuel-ts/address\";\nimport { ErrorCode as ErrorCode26, FuelError as FuelError28 } from \"@fuel-ts/errors\";\nvar PrivateKeyVault = class {\n  static {\n    __name(this, \"PrivateKeyVault\");\n  }\n  static type = \"privateKey\";\n  #privateKeys = [];\n  /**\n   * If privateKey vault is initialized with a secretKey, it creates\n   * one account with the fallowing secret\n   */\n  constructor(options = {}) {\n    if (options.secret) {\n      this.#privateKeys = [options.secret];\n    } else {\n      this.#privateKeys = options.accounts || [Wallet.generate().privateKey];\n    }\n  }\n  serialize() {\n    return {\n      accounts: this.#privateKeys\n    };\n  }\n  getPublicAccount(privateKey) {\n    const wallet = Wallet.fromPrivateKey(privateKey);\n    return {\n      address: wallet.address,\n      publicKey: wallet.publicKey\n    };\n  }\n  getAccounts() {\n    return this.#privateKeys.map((pk) => this.getPublicAccount(pk));\n  }\n  addAccount() {\n    const wallet = Wallet.generate();\n    this.#privateKeys.push(wallet.privateKey);\n    return this.getPublicAccount(wallet.privateKey);\n  }\n  exportAccount(address) {\n    const ownerAddress = new Address9(address);\n    const privateKey = this.#privateKeys.find(\n      (pk) => Wallet.fromPrivateKey(pk).address.equals(ownerAddress)\n    );\n    if (!privateKey) {\n      throw new FuelError28(\n        ErrorCode26.WALLET_MANAGER_ERROR,\n        `No private key found for address '${address}'.`\n      );\n    }\n    return privateKey;\n  }\n  getWallet(address) {\n    const privateKey = this.exportAccount(address);\n    return Wallet.fromPrivateKey(privateKey);\n  }\n};\n\n// src/wallet-manager/wallet-manager.ts\nvar ERROR_MESSAGES = {\n  invalid_vault_type: \"The provided Vault type is invalid.\",\n  address_not_found: \"No private key found for address the specified wallet address.\",\n  vault_not_found: \"The specified vault was not found.\",\n  wallet_not_unlocked: \"The wallet is currently locked.\",\n  passphrase_not_match: \"The provided passphrase did not match the expected value.\"\n};\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new FuelError29(ErrorCode27.WALLET_MANAGER_ERROR, message);\n  }\n}\n__name(assert, \"assert\");\nvar WalletManager = class _WalletManager extends EventEmitter {\n  static {\n    __name(this, \"WalletManager\");\n  }\n  /**\n   * Vaults\n   *\n   * Vaults are responsible to store secret keys and return an `Wallet` instance,\n   * to interact with the network.\n   *\n   * Each vault has access to its own state\n   *\n   */\n  static Vaults = [MnemonicVault, PrivateKeyVault];\n  /**\n   * Storage\n   *\n   * Persistent encrypted data. `The default storage works only on memory`.\n   */\n  storage = new MemoryStorage();\n  /* Key name passed to the storage */\n  STORAGE_KEY = \"WalletManager\";\n  // `This variables are only accessible from inside the class`\n  #vaults = [];\n  #passphrase = \"\";\n  #isLocked = true;\n  constructor(options) {\n    super();\n    this.storage = options?.storage || this.storage;\n  }\n  get isLocked() {\n    return this.#isLocked;\n  }\n  /**\n   * Return the vault serialized object containing all the privateKeys,\n   * the format of the return depends on the Vault type.\n   */\n  exportVault(vaultId) {\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find((_, idx) => idx === vaultId);\n    assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    return vaultState.vault.serialize();\n  }\n  /**\n   * List all vaults on the Wallet Manager, this function not return secret's\n   */\n  getVaults() {\n    return this.#vaults.map((v, idx) => ({\n      title: v.title,\n      type: v.type,\n      vaultId: idx\n    }));\n  }\n  /**\n   * List all accounts on the Wallet Manager not vault information is revealed\n   */\n  getAccounts() {\n    return this.#vaults.flatMap(\n      (vaultState, vaultId) => vaultState.vault.getAccounts().map((account) => ({ ...account, vaultId }))\n    );\n  }\n  /**\n   * Create a Wallet instance for the specific account\n   */\n  getWallet(address) {\n    const ownerAddress = new Address10(address);\n    const vaultState = this.#vaults.find(\n      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n    return vaultState.vault.getWallet(ownerAddress);\n  }\n  /**\n   * Export specific account privateKey\n   */\n  exportPrivateKey(address) {\n    const ownerAddress = new Address10(address);\n    assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const vaultState = this.#vaults.find(\n      (vs) => vs.vault.getAccounts().find((a) => a.address.equals(ownerAddress))\n    );\n    assert(vaultState, ERROR_MESSAGES.address_not_found);\n    return vaultState.vault.exportAccount(ownerAddress);\n  }\n  /**\n   * Add account to a selected vault or on the first vault as default.\n   * If not vaults are adds it will return error\n   */\n  async addAccount(options) {\n    await this.loadState();\n    const vaultState = this.#vaults[options?.vaultId || 0];\n    await assert(vaultState, ERROR_MESSAGES.vault_not_found);\n    const account = vaultState.vault.addAccount();\n    await this.saveState();\n    return account;\n  }\n  /**\n   * Remove vault by index, by remove the vault you also remove all accounts\n   * created by the vault.\n   */\n  async removeVault(index) {\n    this.#vaults.splice(index, 1);\n    await this.saveState();\n  }\n  /**\n   * Add Vault, the `vaultConfig.type` will look for the Vaults supported if\n   * didn't found it will throw.\n   */\n  async addVault(vaultConfig) {\n    await this.loadState();\n    const Vault2 = this.getVaultClass(vaultConfig.type);\n    const vault = new Vault2(vaultConfig);\n    this.#vaults = this.#vaults.concat({\n      title: vaultConfig.title,\n      type: vaultConfig.type,\n      vault\n    });\n    await this.saveState();\n  }\n  /**\n   * Lock wallet. It removes passphrase from class instance, encrypt and hide all address and\n   * secrets.\n   */\n  lock() {\n    this.#isLocked = true;\n    this.#vaults = [];\n    this.#passphrase = \"\";\n    this.emit(\"lock\");\n  }\n  /**\n   * Unlock wallet. It sets passphrase on WalletManger instance load all address from configured vaults.\n   * Vaults with secrets are not unlocked or instantiated on this moment.\n   */\n  async unlock(passphrase) {\n    this.#passphrase = passphrase;\n    this.#isLocked = false;\n    try {\n      await this.loadState();\n      this.emit(\"unlock\");\n    } catch (err) {\n      await this.lock();\n      throw err;\n    }\n  }\n  /**\n   * Update WalletManager encryption passphrase\n   */\n  async updatePassphrase(oldpass, newpass) {\n    const isLocked = this.#isLocked;\n    await this.unlock(oldpass);\n    this.#passphrase = newpass;\n    await this.saveState();\n    await this.loadState();\n    if (isLocked) {\n      await this.lock();\n    }\n  }\n  /**\n   * Retrieve and decrypt WalletManager state from storage\n   */\n  async loadState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const data = await this.storage.getItem(this.STORAGE_KEY);\n    if (data) {\n      const state = await decrypt(this.#passphrase, JSON.parse(data));\n      this.#vaults = this.#deserializeVaults(state.vaults);\n    }\n  }\n  /**\n   * Store encrypted WalletManager state on storage\n   */\n  async saveState() {\n    await assert(!this.#isLocked, ERROR_MESSAGES.wallet_not_unlocked);\n    const encryptedData = await encrypt(this.#passphrase, {\n      vaults: this.#serializeVaults(this.#vaults)\n    });\n    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(encryptedData));\n    this.emit(\"update\");\n  }\n  /**\n   * Serialize all vaults to store\n   *\n   * `This is only accessible from inside the class`\n   */\n  #serializeVaults(vaults) {\n    return vaults.map(({ title, type, vault }) => ({\n      title,\n      type,\n      data: vault.serialize()\n    }));\n  }\n  /**\n   * Deserialize all vaults to state\n   *\n   * `This is only accessible from inside the class`\n   */\n  #deserializeVaults(vaults) {\n    return vaults.map(({ title, type, data: vaultConfig }) => {\n      const VaultClass = this.getVaultClass(type);\n      return {\n        title,\n        type,\n        vault: new VaultClass(vaultConfig)\n      };\n    });\n  }\n  /**\n   * Return a instantiable Class reference from `WalletManager.Vaults` supported list.\n   */\n  getVaultClass(type) {\n    const VaultClass = _WalletManager.Vaults.find((v) => v.type === type);\n    assert(VaultClass, ERROR_MESSAGES.invalid_vault_type);\n    return VaultClass;\n  }\n};\n\n// src/wallet-manager/types.ts\nimport { ErrorCode as ErrorCode28, FuelError as FuelError30 } from \"@fuel-ts/errors\";\nvar Vault = class {\n  static {\n    __name(this, \"Vault\");\n  }\n  static type;\n  constructor(_options) {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n  serialize() {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n  getAccounts() {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n  addAccount() {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n  exportAccount(_address) {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n  getWallet(_address) {\n    throw new FuelError30(ErrorCode28.NOT_IMPLEMENTED, \"Not implemented.\");\n  }\n};\nvar StorageAbstract = class {\n  static {\n    __name(this, \"StorageAbstract\");\n  }\n};\n\n// src/predicate/predicate.ts\nimport { Interface as Interface5 } from \"@fuel-ts/abi-coder\";\nimport { Address as Address11 } from \"@fuel-ts/address\";\nimport { ErrorCode as ErrorCode30, FuelError as FuelError32 } from \"@fuel-ts/errors\";\nimport { arrayify as arrayify24, hexlify as hexlify25 } from \"@fuel-ts/utils\";\n\n// src/utils/deployScriptOrPredicate.ts\nimport { FuelError as FuelError31, ErrorCode as ErrorCode29 } from \"@fuel-ts/errors\";\nimport { arrayify as arrayify22 } from \"@fuel-ts/utils\";\n\n// src/utils/predicate-script-loader-instructions.ts\nimport { BigNumberCoder as BigNumberCoder4 } from \"@fuel-ts/abi-coder\";\nimport { sha256 as sha2565 } from \"@fuel-ts/hasher\";\nimport { concat as concat8 } from \"@fuel-ts/utils\";\nimport * as asm2 from \"@fuels/vm-asm\";\nvar BLOB_ID_SIZE = 32;\nvar REG_ADDRESS_OF_DATA_AFTER_CODE = 16;\nvar REG_START_OF_LOADED_CODE = 17;\nvar REG_GENERAL_USE = 18;\nvar WORD_SIZE2 = 8;\nvar DATA_OFFSET_INDEX = 8;\nvar CONFIGURABLE_OFFSET_INDEX = 16;\nfunction getBytecodeDataOffset(bytecode) {\n  const [offset] = new BigNumberCoder4(\"u64\").decode(bytecode, DATA_OFFSET_INDEX);\n  return offset.toNumber();\n}\n__name(getBytecodeDataOffset, \"getBytecodeDataOffset\");\nfunction getBytecodeConfigurableOffset(bytecode) {\n  const [offset] = new BigNumberCoder4(\"u64\").decode(bytecode, CONFIGURABLE_OFFSET_INDEX);\n  return offset.toNumber();\n}\n__name(getBytecodeConfigurableOffset, \"getBytecodeConfigurableOffset\");\nfunction getBytecodeId(bytecode) {\n  const configurableOffset = getBytecodeConfigurableOffset(bytecode);\n  const byteCodeWithoutConfigurableSection = bytecode.slice(0, configurableOffset);\n  return sha2565(byteCodeWithoutConfigurableSection);\n}\n__name(getBytecodeId, \"getBytecodeId\");\nfunction getLegacyBlobId(bytecode) {\n  const dataOffset = getBytecodeDataOffset(bytecode);\n  const byteCodeWithoutDataSection = bytecode.slice(0, dataOffset);\n  return sha2565(byteCodeWithoutDataSection);\n}\n__name(getLegacyBlobId, \"getLegacyBlobId\");\nfunction getPredicateScriptLoaderInstructions(originalBinary, blobId) {\n  const { RegId, Instruction } = asm2;\n  const REG_PC = RegId.pc().to_u8();\n  const REG_SP = RegId.sp().to_u8();\n  const REG_IS = RegId.is().to_u8();\n  const getInstructions = /* @__PURE__ */ __name((numOfInstructions2) => [\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),\n    // hold the address of the blob ID.\n    asm2.addi(\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      numOfInstructions2 * Instruction.size()\n    ),\n    // The code is going to be loaded from the current value of SP onwards, save\n    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.\n    asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),\n    // REG_GENERAL_USE to hold the size of the blob.\n    asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),\n    // Push the blob contents onto the stack.\n    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),\n    // Move on to the data section length\n    asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, BLOB_ID_SIZE),\n    // load the size of the data section into REG_GENERAL_USE\n    asm2.lw(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE, 0),\n    // after we have read the length of the data section, we move the pointer to the actual\n    // data by skipping WORD_SIZE bytes.\n    asm2.addi(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_ADDRESS_OF_DATA_AFTER_CODE, WORD_SIZE2),\n    // load the data section of the executable\n    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 2),\n    // Jump into the memory where the contract is loaded.\n    // What follows is called _jmp_mem by the sway compiler.\n    // Subtract the address contained in IS because jmp will add it back.\n    asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),\n    // jmp will multiply by 4, so we need to divide to cancel that out.\n    asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),\n    // Jump to the start of the contract we loaded.\n    asm2.jmp(REG_START_OF_LOADED_CODE)\n  ], \"getInstructions\");\n  const getInstructionsNoDataSection = /* @__PURE__ */ __name((numOfInstructions2) => [\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    // 1. Load the blob content into memory\n    // Find the start of the hardcoded blob ID, which is located after the loader code ends.\n    asm2.move_(REG_ADDRESS_OF_DATA_AFTER_CODE, REG_PC),\n    // hold the address of the blob ID.\n    asm2.addi(\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      REG_ADDRESS_OF_DATA_AFTER_CODE,\n      numOfInstructions2 * Instruction.size()\n    ),\n    // The code is going to be loaded from the current value of SP onwards, save\n    // the location into REG_START_OF_LOADED_CODE so we can jump into it at the end.\n    asm2.move_(REG_START_OF_LOADED_CODE, REG_SP),\n    // REG_GENERAL_USE to hold the size of the blob.\n    asm2.bsiz(REG_GENERAL_USE, REG_ADDRESS_OF_DATA_AFTER_CODE),\n    // Push the blob contents onto the stack.\n    asm2.ldc(REG_ADDRESS_OF_DATA_AFTER_CODE, 0, REG_GENERAL_USE, 1),\n    // Jump into the memory where the contract is loaded.\n    // What follows is called _jmp_mem by the sway compiler.\n    // Subtract the address contained in IS because jmp will add it back.\n    asm2.sub(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, REG_IS),\n    // jmp will multiply by 4, so we need to divide to cancel that out.\n    asm2.divi(REG_START_OF_LOADED_CODE, REG_START_OF_LOADED_CODE, 4),\n    // Jump to the start of the contract we loaded.\n    asm2.jmp(REG_START_OF_LOADED_CODE)\n  ], \"getInstructionsNoDataSection\");\n  const offset = getBytecodeConfigurableOffset(originalBinary);\n  if (originalBinary.length < offset) {\n    throw new Error(\n      `Data section offset is out of bounds, offset: ${offset}, binary length: ${originalBinary.length}`\n    );\n  }\n  const configurableSection = originalBinary.slice(offset);\n  if (configurableSection.length > 0) {\n    const numOfInstructions2 = getInstructions(0).length;\n    if (numOfInstructions2 > 65535) {\n      throw new Error(\"Too many instructions, exceeding u16::MAX.\");\n    }\n    const instructionBytes2 = new Uint8Array(\n      getInstructions(numOfInstructions2).flatMap(\n        (instruction) => Array.from(instruction.to_bytes())\n      )\n    );\n    const blobBytes2 = new Uint8Array(blobId);\n    const dataSectionLenBytes = new Uint8Array(8);\n    const dataView = new DataView(dataSectionLenBytes.buffer);\n    dataView.setBigUint64(0, BigInt(configurableSection.length), false);\n    const loaderBytecode2 = new Uint8Array([\n      ...instructionBytes2,\n      ...blobBytes2,\n      ...dataSectionLenBytes\n    ]);\n    return {\n      loaderBytecode: concat8([loaderBytecode2, configurableSection]),\n      blobOffset: loaderBytecode2.length\n    };\n  }\n  const numOfInstructions = getInstructionsNoDataSection(0).length;\n  if (numOfInstructions > 65535) {\n    throw new Error(\"Too many instructions, exceeding u16::MAX.\");\n  }\n  const instructionBytes = new Uint8Array(\n    getInstructionsNoDataSection(numOfInstructions).flatMap(\n      (instruction) => Array.from(instruction.to_bytes())\n    )\n  );\n  const blobBytes = new Uint8Array(blobId);\n  const loaderBytecode = new Uint8Array([...instructionBytes, ...blobBytes]);\n  return { loaderBytecode };\n}\n__name(getPredicateScriptLoaderInstructions, \"getPredicateScriptLoaderInstructions\");\n\n// src/utils/deployScriptOrPredicate.ts\nasync function fundBlobTx(deployer, blobTxRequest) {\n  const { assembledRequest } = await deployer.provider.assembleTx({\n    request: blobTxRequest,\n    feePayerAccount: deployer,\n    accountCoinQuantities: []\n  });\n  return assembledRequest;\n}\n__name(fundBlobTx, \"fundBlobTx\");\nfunction adjustConfigurableOffsets(jsonAbi, configurableOffsetDiff) {\n  const { configurables: readOnlyConfigurables } = jsonAbi;\n  const configurables = [];\n  readOnlyConfigurables.forEach((config) => {\n    configurables.push({ ...config, offset: config.offset - configurableOffsetDiff });\n  });\n  return { ...jsonAbi, configurables };\n}\n__name(adjustConfigurableOffsets, \"adjustConfigurableOffsets\");\nasync function deployScriptOrPredicate({\n  deployer,\n  bytecode,\n  abi,\n  loaderInstanceCallback\n}) {\n  const blobId = getBytecodeId(arrayify22(bytecode));\n  const configurableOffset = getBytecodeConfigurableOffset(arrayify22(bytecode));\n  const byteCodeWithoutConfigurableSection = bytecode.slice(0, configurableOffset);\n  const blobTxRequest = new BlobTransactionRequest({\n    blobId,\n    witnessIndex: 0,\n    witnesses: [byteCodeWithoutConfigurableSection]\n  });\n  const { loaderBytecode, blobOffset } = getPredicateScriptLoaderInstructions(\n    arrayify22(bytecode),\n    arrayify22(blobId)\n  );\n  const newConfigurableOffsetDiff = byteCodeWithoutConfigurableSection.length - (blobOffset || 0);\n  const newAbi = adjustConfigurableOffsets(abi, newConfigurableOffsetDiff);\n  const blobExists = (await deployer.provider.getBlobs([blobId])).length > 0;\n  const loaderInstance = loaderInstanceCallback(loaderBytecode, newAbi);\n  if (blobExists) {\n    return {\n      waitForResult: /* @__PURE__ */ __name(() => Promise.resolve(loaderInstance), \"waitForResult\"),\n      blobId\n    };\n  }\n  const fundedBlobRequest = await fundBlobTx(deployer, blobTxRequest);\n  const waitForResult = /* @__PURE__ */ __name(async () => {\n    try {\n      const blobTx = await deployer.sendTransaction(fundedBlobRequest);\n      const result = await blobTx.waitForResult();\n      if (result.status !== \"success\" /* success */) {\n        throw new Error();\n      }\n    } catch (err) {\n      throw new FuelError31(ErrorCode29.TRANSACTION_FAILED, \"Failed to deploy predicate chunk\");\n    }\n    return loaderInstance;\n  }, \"waitForResult\");\n  return {\n    waitForResult,\n    blobId\n  };\n}\n__name(deployScriptOrPredicate, \"deployScriptOrPredicate\");\n\n// src/predicate/utils/getPredicateRoot.ts\nimport { hash as hash3 } from \"@fuel-ts/hasher\";\nimport { calcRoot } from \"@fuel-ts/merkle\";\nimport { chunkAndPadBytes, hexlify as hexlify24, concat as concat9, arrayify as arrayify23 } from \"@fuel-ts/utils\";\nvar getPredicateRoot = /* @__PURE__ */ __name((bytecode) => {\n  const chunkSize = 16 * 1024;\n  const bytes = arrayify23(bytecode);\n  const chunks = chunkAndPadBytes(bytes, chunkSize);\n  const codeRoot = calcRoot(chunks.map((c) => hexlify24(c)));\n  const predicateRoot = hash3(concat9([\"0x4655454C\", codeRoot]));\n  return predicateRoot;\n}, \"getPredicateRoot\");\n\n// src/predicate/predicate.ts\nvar Predicate = class _Predicate extends Account {\n  static {\n    __name(this, \"Predicate\");\n  }\n  bytes;\n  predicateData = [];\n  interface;\n  initialBytecode;\n  configurableConstants;\n  /**\n   * Creates an instance of the Predicate class.\n   *\n   * @param bytecode - The bytecode of the predicate.\n   * @param abi - The JSON ABI of the predicate.\n   * @param provider - The provider used to interact with the blockchain.\n   * @param data - The predicate input data (optional).\n   * @param configurableConstants - Optional configurable constants for the predicate.\n   */\n  constructor({\n    bytecode,\n    abi,\n    provider,\n    data,\n    configurableConstants\n  }) {\n    const { predicateBytes, predicateInterface } = _Predicate.processPredicateData(\n      bytecode,\n      abi,\n      configurableConstants\n    );\n    const address = new Address11(getPredicateRoot(predicateBytes));\n    super(address, provider);\n    this.initialBytecode = arrayify24(bytecode);\n    this.bytes = predicateBytes;\n    this.interface = predicateInterface;\n    this.configurableConstants = configurableConstants;\n    if (data !== void 0 && data.length > 0) {\n      this.predicateData = data;\n    }\n  }\n  /**\n   * Populates the transaction data with predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns The transaction request with predicate data.\n   */\n  populateTransactionPredicateData(transactionRequestLike) {\n    const request2 = transactionRequestify(transactionRequestLike);\n    const placeholderIndex = this.getIndexFromPlaceholderWitness(request2);\n    if (placeholderIndex !== -1) {\n      request2.removeWitness(placeholderIndex);\n    }\n    request2.inputs.filter(isRequestInputCoinOrMessage).forEach((input) => {\n      if (isRequestInputResourceFromOwner(input, this.address)) {\n        input.predicate = hexlify25(this.bytes);\n        input.predicateData = hexlify25(this.getPredicateData());\n        input.witnessIndex = 0;\n      }\n    });\n    return request2;\n  }\n  /**\n   * Sends a transaction with the populated predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns A promise that resolves to the transaction response.\n   */\n  sendTransaction(transactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    return super.sendTransaction(transactionRequest, { estimateTxDependencies: false });\n  }\n  /**\n   * Simulates a transaction with the populated predicate data.\n   *\n   * @param transactionRequestLike - The transaction request-like object.\n   * @returns A promise that resolves to the call result.\n   */\n  simulateTransaction(transactionRequestLike) {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    return super.simulateTransaction(transactionRequest, { estimateTxDependencies: false });\n  }\n  /**\n   * Retrieves the properly encoded predicate data.\n   *\n   * @returns A Uint8Array containing the encoded predicate data. If no predicate data is available, returns an empty Uint8Array.\n   */\n  getPredicateData() {\n    if (!this.predicateData.length) {\n      return new Uint8Array();\n    }\n    const mainFn = this.interface?.functions.main;\n    return mainFn?.encodeArguments(this.predicateData) || new Uint8Array();\n  }\n  /**\n   * Creates a new Predicate instance from an existing Predicate instance.\n   * @param overrides - The data and configurable constants to override.\n   * @returns A new Predicate instance with the same bytecode, ABI and provider but with the ability to set the data and configurable constants.\n   */\n  toNewInstance(overrides = {}) {\n    return new _Predicate({\n      bytecode: this.initialBytecode,\n      abi: this.interface.jsonAbi,\n      provider: this.provider,\n      data: overrides.data ?? this.predicateData,\n      configurableConstants: overrides.configurableConstants ?? this.configurableConstants\n    });\n  }\n  /**\n   * Sets the predicate data.\n   *\n   * @param data - The data to be set for the predicate.\n   */\n  setData(data) {\n    this.predicateData = data;\n  }\n  /**\n   * Processes the predicate data and returns the altered bytecode and interface.\n   *\n   * @param bytes - The bytes of the predicate.\n   * @param jsonAbi - The JSON ABI of the predicate.\n   * @param configurableConstants - Optional configurable constants for the predicate.\n   * @returns An object containing the new predicate bytes and interface.\n   */\n  static processPredicateData(bytes, jsonAbi, configurableConstants) {\n    let predicateBytes = arrayify24(bytes);\n    const abiInterface = new Interface5(jsonAbi);\n    if (abiInterface.functions.main === void 0) {\n      throw new FuelError32(\n        ErrorCode30.ABI_MAIN_METHOD_MISSING,\n        'Cannot use ABI without \"main\" function.'\n      );\n    }\n    if (configurableConstants && Object.keys(configurableConstants).length) {\n      predicateBytes = _Predicate.setConfigurableConstants(\n        predicateBytes,\n        configurableConstants,\n        abiInterface\n      );\n    }\n    return {\n      predicateBytes,\n      predicateInterface: abiInterface\n    };\n  }\n  /**\n   * Retrieves resources satisfying the spend query for the account.\n   *\n   * @param quantities - IDs of coins to exclude.\n   * @param resourcesIdsToIgnore - IDs of resources to be excluded from the query.\n   * @returns A promise that resolves to an array of Resources.\n   */\n  async getResourcesToSpend(quantities, resourcesIdsToIgnore) {\n    const resources = await this.provider.getResourcesToSpend(\n      this.address,\n      quantities,\n      resourcesIdsToIgnore\n    );\n    return resources.map((resource) => ({\n      ...resource,\n      predicate: hexlify25(this.bytes),\n      predicateData: hexlify25(this.getPredicateData())\n    }));\n  }\n  /**\n   * Generates an array of fake resources based on the provided coins.\n   *\n   * @param coins - An array of `FakeResources` objects representing the coins.\n   * @returns An array of `Resource` objects with generated properties.\n   */\n  generateFakeResources(coins) {\n    return super.generateFakeResources(coins).map((coin) => ({\n      ...coin,\n      predicate: hexlify25(this.bytes),\n      predicateData: hexlify25(this.getPredicateData())\n    }));\n  }\n  /**\n   * Sets the configurable constants for the predicate.\n   *\n   * @param bytes - The bytes of the predicate.\n   * @param configurableConstants - Configurable constants to be set.\n   * @param abiInterface - The ABI interface of the predicate.\n   * @returns The mutated bytes with the configurable constants set.\n   */\n  static setConfigurableConstants(bytes, configurableConstants, abiInterface) {\n    const mutatedBytes = bytes;\n    try {\n      if (Object.keys(abiInterface.configurables).length === 0) {\n        throw new FuelError32(\n          ErrorCode30.INVALID_CONFIGURABLE_CONSTANTS,\n          \"Predicate has no configurable constants to be set\"\n        );\n      }\n      Object.entries(configurableConstants).forEach(([key, value]) => {\n        if (!abiInterface?.configurables[key]) {\n          throw new FuelError32(\n            ErrorCode30.CONFIGURABLE_NOT_FOUND,\n            `No configurable constant named '${key}' found in the Predicate`\n          );\n        }\n        const { offset } = abiInterface.configurables[key];\n        const encoded = abiInterface.encodeConfigurable(key, value);\n        mutatedBytes.set(encoded, offset);\n      });\n    } catch (err) {\n      throw new FuelError32(\n        ErrorCode30.INVALID_CONFIGURABLE_CONSTANTS,\n        `Error setting configurable constants: ${err.message}.`\n      );\n    }\n    return mutatedBytes;\n  }\n  /**\n   * Returns the index of the witness placeholder that was added to this predicate.\n   * If no witness placeholder was added, it returns -1.\n   * @param request - The transaction request.\n   * @returns The index of the witness placeholder, or -1 if there is no witness placeholder.\n   */\n  getIndexFromPlaceholderWitness(request2) {\n    const predicateInputs = request2.inputs.filter(isRequestInputResource).filter((input) => isRequestInputResourceFromOwner(input, this.address));\n    let index = -1;\n    const hasEmptyPredicateInputs = predicateInputs.find((input) => !input.predicate);\n    if (hasEmptyPredicateInputs) {\n      index = hasEmptyPredicateInputs.witnessIndex;\n      const allInputsAreEmpty = predicateInputs.every((input) => !input.predicate);\n      if (!allInputsAreEmpty) {\n        const wasFilledInputAddedFirst = !!predicateInputs[0]?.predicate;\n        if (wasFilledInputAddedFirst) {\n          index = -1;\n        }\n      }\n    }\n    return index;\n  }\n  /**\n   *\n   * @param account - The account used to pay the deployment costs.\n   * @returns The _blobId_ and a _waitForResult_ callback that returns the deployed predicate\n   * once the blob deployment transaction finishes.\n   *\n   * The returned loader predicate will have the same configurable constants\n   * as the original predicate which was used to generate the loader predicate.\n   */\n  async deploy(account) {\n    return deployScriptOrPredicate({\n      deployer: account,\n      abi: this.interface.jsonAbi,\n      bytecode: this.bytes,\n      loaderInstanceCallback: /* @__PURE__ */ __name((loaderBytecode, newAbi) => new _Predicate({\n        bytecode: loaderBytecode,\n        abi: newAbi,\n        provider: this.provider,\n        data: this.predicateData\n      }), \"loaderInstanceCallback\")\n    });\n  }\n};\n\n// src/connectors/fuel.ts\nimport { ErrorCode as ErrorCode31, FuelError as FuelError35 } from \"@fuel-ts/errors\";\n\n// src/connectors/fuel-connector.ts\nimport { FuelError as FuelError33 } from \"@fuel-ts/errors\";\nimport { EventEmitter as EventEmitter2 } from \"events\";\n\n// src/connectors/types/connector-types.ts\nvar FuelConnectorMethods = /* @__PURE__ */ ((FuelConnectorMethods2) => {\n  FuelConnectorMethods2[\"ping\"] = \"ping\";\n  FuelConnectorMethods2[\"version\"] = \"version\";\n  FuelConnectorMethods2[\"connect\"] = \"connect\";\n  FuelConnectorMethods2[\"disconnect\"] = \"disconnect\";\n  FuelConnectorMethods2[\"isConnected\"] = \"isConnected\";\n  FuelConnectorMethods2[\"accounts\"] = \"accounts\";\n  FuelConnectorMethods2[\"currentAccount\"] = \"currentAccount\";\n  FuelConnectorMethods2[\"signTransaction\"] = \"signTransaction\";\n  FuelConnectorMethods2[\"signMessage\"] = \"signMessage\";\n  FuelConnectorMethods2[\"sendTransaction\"] = \"sendTransaction\";\n  FuelConnectorMethods2[\"assets\"] = \"assets\";\n  FuelConnectorMethods2[\"addAsset\"] = \"addAsset\";\n  FuelConnectorMethods2[\"addAssets\"] = \"addAssets\";\n  FuelConnectorMethods2[\"networks\"] = \"networks\";\n  FuelConnectorMethods2[\"currentNetwork\"] = \"currentNetwork\";\n  FuelConnectorMethods2[\"addNetwork\"] = \"addNetwork\";\n  FuelConnectorMethods2[\"selectNetwork\"] = \"selectNetwork\";\n  FuelConnectorMethods2[\"addABI\"] = \"addABI\";\n  FuelConnectorMethods2[\"getABI\"] = \"getABI\";\n  FuelConnectorMethods2[\"hasABI\"] = \"hasABI\";\n  FuelConnectorMethods2[\"startConsolidation\"] = \"startConsolidation\";\n  return FuelConnectorMethods2;\n})(FuelConnectorMethods || {});\nvar FuelConnectorEventTypes = /* @__PURE__ */ ((FuelConnectorEventTypes2) => {\n  FuelConnectorEventTypes2[\"connectors\"] = \"connectors\";\n  FuelConnectorEventTypes2[\"currentConnector\"] = \"currentConnector\";\n  FuelConnectorEventTypes2[\"connection\"] = \"connection\";\n  FuelConnectorEventTypes2[\"accounts\"] = \"accounts\";\n  FuelConnectorEventTypes2[\"currentAccount\"] = \"currentAccount\";\n  FuelConnectorEventTypes2[\"networks\"] = \"networks\";\n  FuelConnectorEventTypes2[\"currentNetwork\"] = \"currentNetwork\";\n  FuelConnectorEventTypes2[\"assets\"] = \"assets\";\n  FuelConnectorEventTypes2[\"abis\"] = \"abis\";\n  FuelConnectorEventTypes2[\"consolidateCoins\"] = \"consolidateCoins\";\n  return FuelConnectorEventTypes2;\n})(FuelConnectorEventTypes || {});\nvar FuelConnectorEventType = \"FuelConnector\";\n\n// src/connectors/types/local-storage.ts\nvar LocalStorage = class {\n  static {\n    __name(this, \"LocalStorage\");\n  }\n  storage;\n  constructor(localStorage) {\n    this.storage = localStorage;\n  }\n  async setItem(key, value) {\n    this.storage.setItem(key, value);\n  }\n  async getItem(key) {\n    return this.storage.getItem(key);\n  }\n  async removeItem(key) {\n    this.storage.removeItem(key);\n  }\n  async clear() {\n    this.storage.clear();\n  }\n};\n\n// src/connectors/fuel-connector.ts\nvar FuelConnector = class extends EventEmitter2 {\n  static {\n    __name(this, \"FuelConnector\");\n  }\n  name = \"\";\n  metadata = {};\n  connected = false;\n  installed = false;\n  external = true;\n  events = FuelConnectorEventTypes;\n  /**\n   * Should return true if the connector is loaded\n   * in less then one second.\n   *\n   * @returns Always true.\n   */\n  async ping() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return the current version of the connector\n   * and the network version that is compatible.\n   *\n   * @returns boolean - connection status.\n   */\n  async version() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return true if the connector is connected\n   * to any of the accounts available.\n   *\n   * @returns The connection status.\n   */\n  async isConnected() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return all the accounts authorized for the\n   * current connection.\n   *\n   * @returns The accounts addresses strings\n   */\n  async accounts() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the connection process and return\n   * true if the account authorize the connection.\n   *\n   * and return false if the user reject the connection.\n   *\n   * @emits accounts\n   * @returns boolean - connection status.\n   */\n  async connect() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should disconnect the current connection and\n   * return false if the disconnection was successful.\n   *\n   * @emits assets connection\n   * @returns The connection status.\n   */\n  async disconnect() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the sign message process and return\n   * the signed message.\n   *\n   * @param address - The address to sign the message\n   * @param message - The message to sign all text will be treated as text utf-8\n   *\n   * @returns Message signature\n   */\n  async signMessage(_address, _message) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the sign transaction process and return\n   * the signed transaction.\n   *\n   * @param address - The address to sign the transaction\n   * @param transaction - The transaction to sign\n   *\n   * @returns Transaction signature\n   */\n  async signTransaction(_address, _transaction, _params) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the send transaction process and return\n   * the transaction id submitted to the network.\n   *\n   * If the network is not available for the connection\n   * it should throw an error to avoid the transaction\n   * to be sent to the wrong network and lost.\n   *\n   * @param address - The address to sign the transaction\n   * @param transaction - The transaction to send\n   * @param params - Optional parameters to send the transaction\n   * @returns The transaction id or transaction response\n   */\n  async sendTransaction(_address, _transaction, _params) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return the current account selected inside the connector, if the account\n   * is authorized for the connection.\n   *\n   * If the account is not authorized it should return null.\n   *\n   * @returns The current account selected otherwise null.\n   */\n  async currentAccount() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should add the assets metadata to the connector and return true if the asset\n   * was added successfully.\n   *\n   * If the asset already exists it should throw an error.\n   *\n   * @emits assets\n   * @param assets - The assets to add the metadata to the connection.\n   * @throws Error if the asset already exists\n   * @returns True if the asset was added successfully\n   */\n  async addAssets(_assets) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should add the asset metadata to the connector and return true if the asset\n   * was added successfully.\n   *\n   * If the asset already exists it should throw an error.\n   *\n   * @emits assets\n   * @param asset - The asset to add the metadata to the connection.\n   * @throws Error if the asset already exists\n   * @returns True if the asset was added successfully\n   */\n  async addAsset(_asset) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return all the assets added to the connector. If a connection is already established.\n   *\n   * @returns Array of assets metadata from the connector vinculated to the all accounts from a specific Wallet.\n   */\n  async assets() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the add network process and return true if the network was added successfully.\n   *\n   * @emits networks\n   * @throws Error if the network already exists\n   * @param networkUrl - The URL of the network to be added.\n   * @returns Return true if the network was added successfully\n   */\n  async addNetwork(_networkUrl) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should start the select network process and return true if the network has change successfully.\n   *\n   * @emits networks\n   * @throws Error if the network already exists\n   * @param network - The network to be selected.\n   * @returns Return true if the network was added successfully\n   */\n  async selectNetwork(_network) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return all the networks available from the connector. If the connection is already established.\n   *\n   * @returns Return all the networks added to the connector.\n   */\n  async networks() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return the current network selected inside the connector. Even if the connection is not established.\n   *\n   * @returns Return the current network selected inside the connector.\n   */\n  async currentNetwork() {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should add the ABI to the connector and return true if the ABI was added successfully.\n   *\n   * @param contractId - The contract id to add the ABI.\n   * @param abi - The JSON ABI that represents a contract.\n   * @returns Return true if the ABI was added successfully.\n   */\n  async addABI(_contractId, _abi) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return the ABI from the connector vinculated to the all accounts from a specific Wallet.\n   *\n   * @param id - The contract id to get the ABI.\n   * @returns The ABI if it exists, otherwise return null.\n   */\n  async getABI(_id) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Should return true if the abi exists in the connector vinculated to the all accounts from a specific Wallet.\n   *\n   * @param id - The contract id to get the abi\n   * @returns Returns true if the abi exists or false if not.\n   */\n  async hasABI(_id) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Start the consolidation of coins process\n   *\n   * @param owner - The B256 address of the owner.\n   * @param assetId - The asset ID that requires consolidation.\n   */\n  async startConsolidation(_opts) {\n    throw new FuelError33(FuelError33.CODES.NOT_IMPLEMENTED, \"Method not implemented.\");\n  }\n  /**\n   * Event listener for the connector.\n   *\n   * @param eventName - The event name to listen\n   * @param listener - The listener function\n   */\n  on(eventName, listener) {\n    super.on(eventName, listener);\n    return this;\n  }\n};\n\n// src/connectors/utils/cache.ts\nfunction cacheFor(fn, { cache: cache2, cacheTime, key }) {\n  return async (...args) => {\n    if (cache2[key] && cache2[key]?.value) {\n      return cache2[key]?.value;\n    }\n    clearTimeout(cache2[key]?.timeout);\n    const result = await fn(...args);\n    cache2[key] = {\n      timeout: Number(\n        setTimeout(() => {\n          cache2[key] = null;\n        }, cacheTime)\n      ),\n      value: result\n    };\n    return result;\n  };\n}\n__name(cacheFor, \"cacheFor\");\n\n// src/connectors/utils/dispatch-fuel-connector-event.ts\nfunction dispatchFuelConnectorEvent(connector) {\n  window.dispatchEvent(\n    new CustomEvent(FuelConnectorEventType, {\n      detail: connector\n    })\n  );\n}\n__name(dispatchFuelConnectorEvent, \"dispatchFuelConnectorEvent\");\n\n// src/connectors/utils/promises.ts\nimport { FuelError as FuelError34 } from \"@fuel-ts/errors\";\nfunction deferPromise() {\n  const defer = {};\n  defer.promise = new Promise((resolve, reject) => {\n    defer.reject = reject;\n    defer.resolve = resolve;\n  });\n  return defer;\n}\n__name(deferPromise, \"deferPromise\");\nasync function withTimeout(promise, timeout = 1050) {\n  const timeoutPromise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new FuelError34(FuelError34.CODES.TIMEOUT_EXCEEDED, \"Promise timed out\"));\n    }, timeout);\n  });\n  return Promise.race([timeoutPromise, promise]);\n}\n__name(withTimeout, \"withTimeout\");\n\n// src/connectors/fuel.ts\nvar HAS_CONNECTOR_TIMEOUT = 2e3;\nvar PING_CACHE_TIME = 5e3;\nvar { warn } = console;\nvar Fuel = class _Fuel extends FuelConnector {\n  static {\n    __name(this, \"Fuel\");\n  }\n  static STORAGE_KEY = \"fuel-current-connector\";\n  static defaultConfig = {};\n  _storage = null;\n  _connectors = [];\n  _targetObject = null;\n  _unsubscribes = [];\n  _targetUnsubscribe = /* @__PURE__ */ __name(() => {\n  }, \"_targetUnsubscribe\");\n  _pingCache = {};\n  _currentConnector;\n  _initializationPromise = null;\n  constructor(config = _Fuel.defaultConfig) {\n    super();\n    this.setMaxListeners(1e3);\n    this._connectors = config.connectors ?? [];\n    this._targetObject = this.getTargetObject(config.targetObject);\n    this._storage = config.storage === void 0 ? this.getStorage() : config.storage;\n    this.setupMethods();\n    this._initializationPromise = this.initialize();\n  }\n  async initialize() {\n    try {\n      const connectResponse = this.setDefaultConnector();\n      this._targetUnsubscribe = this.setupConnectorListener();\n      await connectResponse;\n    } catch (error) {\n      throw new FuelError35(ErrorCode31.INVALID_PROVIDER, \"Error initializing Fuel Connector\");\n    }\n  }\n  async init() {\n    await this._initializationPromise;\n    return this;\n  }\n  /**\n   * Return the target object to listen for global events.\n   */\n  getTargetObject(targetObject) {\n    if (targetObject) {\n      return targetObject;\n    }\n    if (typeof window !== \"undefined\") {\n      return window;\n    }\n    if (typeof document !== \"undefined\") {\n      return document;\n    }\n    return null;\n  }\n  /**\n   * Return the storage used.\n   */\n  getStorage() {\n    if (typeof window !== \"undefined\") {\n      return new LocalStorage(window.localStorage);\n    }\n    return void 0;\n  }\n  /**\n   * Setup the default connector from the storage.\n   */\n  async setDefaultConnector() {\n    const connectorName = await this._storage?.getItem(_Fuel.STORAGE_KEY) || this._connectors[0]?.name;\n    if (connectorName) {\n      return this.selectConnector(connectorName, {\n        emitEvents: false\n      });\n    }\n    return void 0;\n  }\n  /**\n   * Start listener for all the events of the current\n   * connector and emit them to the Fuel instance\n   */\n  setupConnectorEvents(events) {\n    if (!this._currentConnector) {\n      return;\n    }\n    const currentConnector = this._currentConnector;\n    this._unsubscribes.map((unSub) => unSub());\n    this._unsubscribes = events.map((event) => {\n      const handler = /* @__PURE__ */ __name((...args) => this.emit(event, ...args), \"handler\");\n      currentConnector.on(event, handler);\n      return () => currentConnector.off(event, handler);\n    });\n  }\n  /**\n   * Call method from the current connector.\n   */\n  async callMethod(method, ...args) {\n    const hasConnector = await this.hasConnector();\n    await this.pingConnector();\n    if (!this._currentConnector || !hasConnector) {\n      throw new FuelError35(\n        ErrorCode31.MISSING_CONNECTOR,\n        `No connector selected for calling ${method}. Use hasConnector before executing other methods.`\n      );\n    }\n    if (typeof this._currentConnector[method] === \"function\") {\n      return this._currentConnector[method](...args);\n    }\n    return void 0;\n  }\n  /**\n   * Create a method for each method proxy that is available on the Common interface\n   * and call the method from the current connector.\n   */\n  setupMethods() {\n    Object.values(FuelConnectorMethods).forEach((method) => {\n      this[method] = async (...args) => this.callMethod(method, ...args);\n    });\n  }\n  /**\n   * Fetch the status of a connector and set the installed and connected\n   * status.\n   */\n  async fetchConnectorStatus(connector) {\n    const requestTimestamp = Date.now();\n    const [isConnected, ping] = await Promise.allSettled([\n      withTimeout(connector.isConnected()),\n      withTimeout(this.pingConnector(connector))\n    ]);\n    const isStale = requestTimestamp < (connector._latestUpdate || 0);\n    if (!isStale) {\n      connector._latestUpdate = Date.now();\n      connector.installed = ping.status === \"fulfilled\" && ping.value;\n      connector.connected = isConnected.status === \"fulfilled\" && isConnected.value;\n    }\n    return {\n      installed: connector.installed,\n      connected: connector.connected\n    };\n  }\n  /**\n   * Fetch the status of all connectors and set the installed and connected\n   * status.\n   */\n  async fetchConnectorsStatus() {\n    return Promise.all(\n      this._connectors.map(async (connector) => this.fetchConnectorStatus(connector))\n    );\n  }\n  /**\n   * Fetch the status of a connector and set the installed and connected\n   * status. If no connector is provided it will ping the current connector.\n   */\n  async pingConnector(connector) {\n    const curConnector = connector || this._currentConnector;\n    if (!curConnector) {\n      return false;\n    }\n    try {\n      return await cacheFor(async () => withTimeout(curConnector.ping()), {\n        key: curConnector.name,\n        cache: this._pingCache,\n        cacheTime: PING_CACHE_TIME\n      })();\n    } catch {\n      throw new FuelError35(ErrorCode31.INVALID_PROVIDER, \"Current connector is not available.\");\n    }\n  }\n  /**\n   * Setup a listener for the FuelConnector event and add the connector\n   * to the list of new connectors.\n   */\n  setupConnectorListener = /* @__PURE__ */ __name(() => {\n    const { _targetObject: targetObject } = this;\n    const eventName = FuelConnectorEventType;\n    if (targetObject?.on) {\n      targetObject.on(eventName, this.addConnector);\n      return () => {\n        targetObject.off?.(eventName, this.addConnector);\n      };\n    }\n    if (targetObject?.addEventListener) {\n      const handler = /* @__PURE__ */ __name((e) => {\n        this.addConnector(e.detail);\n      }, \"handler\");\n      targetObject.addEventListener(eventName, handler);\n      return () => {\n        targetObject.removeEventListener?.(eventName, handler);\n      };\n    }\n    return () => {\n    };\n  }, \"setupConnectorListener\");\n  /**\n   * Add a new connector to the list of connectors.\n   */\n  addConnector = /* @__PURE__ */ __name(async (connector) => {\n    if (!this.getConnector(connector)) {\n      this._connectors.push(connector);\n    }\n    await this.fetchConnectorStatus(connector);\n    this.emit(this.events.connectors, this._connectors);\n    if (!this._currentConnector) {\n      await this.selectConnector(connector.name, {\n        emitEvents: false\n      });\n    }\n  }, \"addConnector\");\n  triggerConnectorEvents = /* @__PURE__ */ __name(async () => {\n    const [isConnected, networks2, currentNetwork] = await Promise.all([\n      this.isConnected(),\n      this.networks(),\n      this.currentNetwork()\n    ]);\n    this.emit(this.events.connection, isConnected);\n    this.emit(this.events.networks, networks2);\n    this.emit(this.events.currentNetwork, currentNetwork);\n    if (isConnected) {\n      const [accounts, currentAccount] = await Promise.all([\n        this.accounts(),\n        this.currentAccount()\n      ]);\n      this.emit(this.events.accounts, accounts);\n      this.emit(this.events.currentAccount, currentAccount);\n    }\n  }, \"triggerConnectorEvents\");\n  /**\n   * Get a connector from the list of connectors.\n   */\n  getConnector = /* @__PURE__ */ __name((connector) => this._connectors.find((c) => {\n    const connectorName = typeof connector === \"string\" ? connector : connector.name;\n    return c.name === connectorName || c === connector;\n  }) || null, \"getConnector\");\n  /**\n   * Return the list of connectors with the status of installed and connected.\n   */\n  async connectors() {\n    await this.fetchConnectorsStatus();\n    return this._connectors;\n  }\n  /**\n   * Set the current connector to be used.\n   */\n  async selectConnector(connectorName, options = {\n    emitEvents: true\n  }) {\n    const connector = this.getConnector(connectorName);\n    if (!connector) {\n      return false;\n    }\n    if (this._currentConnector?.name === connectorName) {\n      return true;\n    }\n    const { installed } = await this.fetchConnectorStatus(connector);\n    if (installed) {\n      this._currentConnector = connector;\n      this.emit(this.events.currentConnector, connector);\n      this.setupConnectorEvents(Object.values(FuelConnectorEventTypes));\n      await this._storage?.setItem(_Fuel.STORAGE_KEY, connector.name);\n      if (options.emitEvents) {\n        this.triggerConnectorEvents();\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Return the current selected connector.\n   */\n  currentConnector() {\n    return this._currentConnector;\n  }\n  /**\n   * Return true if any connector is available.\n   */\n  async hasConnector() {\n    if (this._currentConnector) {\n      return true;\n    }\n    const defer = deferPromise();\n    this.once(this.events.currentConnector, () => {\n      defer.resolve(true);\n    });\n    return withTimeout(defer.promise, HAS_CONNECTOR_TIMEOUT).then(() => true).catch(() => false);\n  }\n  async hasWallet() {\n    return this.hasConnector();\n  }\n  /**\n   * Return a Fuel Provider instance with extends features to work with\n   * connectors.\n   *\n   * @deprecated getProvider is deprecated and is going to be removed in the future, use getWallet instead.\n   */\n  async getProvider(providerOrNetwork) {\n    warn(\n      \"getProvider is deprecated and is going to be removed in the future, use getWallet instead.\"\n    );\n    return this._getProvider(providerOrNetwork);\n  }\n  /**\n   * Return a Fuel Provider instance with extends features to work with\n   * connectors.\n   */\n  async _getProvider(providerOrNetwork) {\n    let provider;\n    if (providerOrNetwork && \"getTransactionResponse\" in providerOrNetwork) {\n      provider = providerOrNetwork;\n    } else if (providerOrNetwork && \"chainId\" in providerOrNetwork && \"url\" in providerOrNetwork) {\n      provider = new Provider(providerOrNetwork.url);\n    } else if (!providerOrNetwork) {\n      const currentNetwork = await this.currentNetwork();\n      provider = new Provider(currentNetwork.url);\n    } else {\n      throw new FuelError35(ErrorCode31.INVALID_PROVIDER, \"Provider is not valid.\");\n    }\n    return provider;\n  }\n  /**\n   * Return a Fuel Wallet Locked instance with extends features to work with\n   * connectors.\n   */\n  async getWallet(address, providerOrNetwork) {\n    const provider = await this._getProvider(providerOrNetwork);\n    return new Account(address, provider, this);\n  }\n  /**\n   * Remove all open listeners this is useful when you want to\n   * remove the Fuel instance and avoid memory leaks.\n   */\n  unsubscribe() {\n    this._unsubscribes.map((unSub) => unSub());\n    this._targetUnsubscribe();\n    this.removeAllListeners();\n  }\n  /**\n   * Clean all the data from the storage.\n   */\n  async clean() {\n    await this._storage?.removeItem(_Fuel.STORAGE_KEY);\n  }\n  /**\n   * Removes all listeners and cleans the storage.\n   */\n  async destroy() {\n    this.unsubscribe();\n    await this.clean();\n  }\n};\nexport {\n  AbstractAccount,\n  AbstractScriptRequest,\n  Account,\n  AddressType,\n  BALANCES_PAGE_SIZE_LIMIT,\n  BLOCKS_PAGE_SIZE_LIMIT,\n  BaseTransactionRequest,\n  BaseWalletUnlocked,\n  BlobTransactionRequest,\n  CHAIN_IDS,\n  ChainName,\n  ChangeOutputCollisionError,\n  CreateTransactionRequest,\n  DEFAULT_RESOURCE_CACHE_TTL,\n  Fuel,\n  FuelConnector,\n  FuelConnectorEventType,\n  FuelConnectorEventTypes,\n  FuelConnectorMethods,\n  GAS_USED_MODIFIER,\n  hdwallet_default as HDWallet,\n  Language,\n  LocalStorage,\n  MNEMONIC_SIZES,\n  MemoryStorage,\n  mnemonic_default as Mnemonic,\n  MnemonicVault,\n  NON_PAGINATED_BALANCES_SIZE,\n  NoWitnessAtIndexError,\n  NoWitnessByOwnerError,\n  OperationName,\n  Predicate,\n  PrivateKeyVault,\n  Provider,\n  RESOURCES_PAGE_SIZE_LIMIT,\n  ScriptTransactionRequest,\n  Signer,\n  StorageAbstract,\n  TRANSACTIONS_PAGE_SIZE_LIMIT,\n  TransactionResponse,\n  TransactionStatus,\n  TransactionType2 as TransactionType,\n  TransactionTypeName,\n  UpgradeTransactionRequest,\n  UploadTransactionRequest,\n  Vault,\n  Wallet,\n  WalletLocked,\n  WalletManager,\n  WalletUnlocked,\n  addAmountToCoinQuantities,\n  addOperation,\n  aggregateInputsAmountsByAssetAndOwner,\n  assemblePanicError,\n  assemblePreConfirmationTransactionSummary,\n  assembleReceiptByType,\n  assembleRevertError,\n  assembleSignalErrorMessage,\n  assembleTransactionSummary,\n  assembleTransactionSummaryFromJson,\n  assets,\n  buildBlockExplorerUrl,\n  cacheFor,\n  cacheRequestInputsResources,\n  cacheRequestInputsResourcesFromOwner,\n  calculateGasFee,\n  calculateMetadataGasForTxBlob,\n  calculateMetadataGasForTxCreate,\n  calculateMetadataGasForTxScript,\n  calculateMetadataGasForTxUpgrade,\n  calculateMetadataGasForTxUpload,\n  calculateMinGasForTxUpload,\n  calculateTXFeeForSummary,\n  coinQuantityfy,\n  consolidateCoins,\n  consolidateCoinsIfRequired,\n  deferPromise,\n  deployScriptOrPredicate,\n  deserializeChain,\n  deserializeInput,\n  deserializeNodeInfo,\n  deserializeOutput,\n  deserializeProcessedTxOutput,\n  deserializeProviderCache,\n  deserializeReceipt,\n  deserializeTransactionResponseJson,\n  dispatchFuelConnectorEvent,\n  english,\n  extractBurnedAssetsFromReceipts,\n  extractMintedAssetsFromReceipts,\n  extractResolvedOutputs,\n  extractTxError,\n  fuelAssetsBaseUrl,\n  gasUsedByInputs,\n  getAllCoins,\n  getAllDecodedLogs,\n  getAssetAmountInRequestInputs,\n  getAssetById,\n  getAssetEth,\n  getAssetFuel,\n  getAssetNetwork,\n  getAssetWithNetwork,\n  getAssetsByOwner,\n  getBurnableAssetCount,\n  getBytecodeConfigurableOffset,\n  getBytecodeDataOffset,\n  getBytecodeId,\n  getContractCallOperations,\n  getContractCreatedOperations,\n  getDecodedLogs,\n  getDefaultChainId,\n  getGasUsedFromReceipts,\n  getInputAccountAddress,\n  getInputContractFromIndex,\n  getInputFromAssetId,\n  getInputsByType,\n  getInputsByTypes,\n  getInputsCoin,\n  getInputsCoinAndMessage,\n  getInputsContract,\n  getInputsMessage,\n  getLegacyBlobId,\n  getMaxGas,\n  getMinGas,\n  getOperations,\n  getOutputsByType,\n  getOutputsChange,\n  getOutputsCoin,\n  getOutputsContract,\n  getOutputsContractCreated,\n  getOutputsVariable,\n  getPayProducerOperations,\n  getPredicateRoot,\n  getReceiptsByType,\n  getReceiptsCall,\n  getReceiptsMessageOut,\n  getReceiptsTransferOut,\n  getReceiptsWithMissingData,\n  getRequestInputResourceOwner,\n  getTotalFeeFromStatus,\n  getTransactionStatusName,\n  getTransactionSummary,\n  getTransactionSummaryFromRequest,\n  getTransactionTypeName,\n  getTransactionsSummaries,\n  getTransferOperations,\n  getWithdrawFromFuelOperations,\n  hasSameAssetId,\n  inputify,\n  isCoin,\n  isInputCoin,\n  isMessage,\n  isMessageCoin,\n  isPredicate,\n  isRawCoin,\n  isRawMessage,\n  isRequestInputCoin,\n  isRequestInputCoinOrMessage,\n  isRequestInputMessage,\n  isRequestInputMessageWithoutData,\n  isRequestInputResource,\n  isRequestInputResourceFromOwner,\n  isTransactionTypeBlob,\n  isTransactionTypeCreate,\n  isTransactionTypeScript,\n  isTransactionTypeUpgrade,\n  isTransactionTypeUpload,\n  isType,\n  isTypeBlob,\n  isTypeCreate,\n  isTypeMint,\n  isTypeScript,\n  isTypeUpgrade,\n  isTypeUpload,\n  mergeQuantities,\n  normalizeJSON,\n  outputify,\n  processGqlReceipt,\n  processGraphqlStatus,\n  rawAssets,\n  resolveAccountForAssembleTxParams,\n  resolveGasDependentCosts,\n  resolveIconPaths,\n  returnZeroScript,\n  serializeChain,\n  serializeNodeInfo,\n  serializeProviderCache,\n  serializeTransactionResponseJson,\n  setAndValidateGasAndFeeForAssembledTx,\n  transactionRequestify,\n  urlJoin,\n  validateTransactionForAssetBurn,\n  withTimeout,\n  withdrawScript\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a2, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a2, prop, b[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nvar _a, _b, _c, _d, _e, _f, _g, _h;\nimport { TonConnectError, isWalletInfoCurrentlyInjected, toUserFriendlyAddress, CHAIN, TonConnect, isTelegramUrl, encodeTelegramUrlParameters, WalletMissingRequiredFeaturesError, isWalletInfoRemote, checkRequiredWalletFeatures, isWalletInfoCurrentlyEmbedded, BrowserEventDispatcher, createVersionInfo, createResponseVersionEvent, createRequestVersionEvent, createConnectionStartedEvent, createConnectionCompletedEvent, createConnectionErrorEvent, createConnectionRestoringStartedEvent, createConnectionRestoringCompletedEvent, createConnectionRestoringErrorEvent, createDisconnectionEvent, createTransactionSentForSignatureEvent, createTransactionSignedEvent, createTransactionSigningFailedEvent, createDataSentForSignatureEvent, createDataSignedEvent, createDataSigningFailedEvent, WalletNotSupportFeatureError, SessionCrypto } from \"@tonconnect/sdk\";\nexport * from \"@tonconnect/sdk\";\nimport UAParser from \"ua-parser-js\";\nimport deepmerge from \"deepmerge\";\nimport cn from \"classnames\";\nconst IS_DEV = false;\nconst equalFn = (a2, b) => a2 === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst SUPPORTS_PROXY = typeof Proxy === \"function\";\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition$1 = null;\nlet ExternalSourceConfig = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: current ? current.context : null,\n    owner: current\n  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s2 = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || void 0\n  };\n  const setter = (value2) => {\n    if (typeof value2 === \"function\") {\n      value2 = value2(s2.value);\n    }\n    return writeSignal(s2, value2);\n  };\n  return [readSignal.bind(s2), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c2 = createComputation(fn, value, true, STALE);\n  updateComputation(c2);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c2 = createComputation(fn, value, false, STALE);\n  updateComputation(c2);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c2 = createComputation(fn, value, false, STALE);\n  if (!options || !options.render) c2.user = true;\n  Effects ? Effects.push(c2) : updateComputation(c2);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c2 = createComputation(fn, value, true, 0);\n  c2.observers = null;\n  c2.observerSlots = null;\n  c2.comparator = options.equals || void 0;\n  updateComputation(c2);\n  return readSignal.bind(c2);\n}\nfunction isPromise(v) {\n  return v && typeof v === \"object\" && \"then\" in v;\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  {\n    source = true;\n    fetcher = pSource;\n    options = {};\n  }\n  let pr = null, initP = NO_INIT, scheduled = false, resolved = \"initialValue\" in options, dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {\n    equals: false\n  }), [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  function loadEnd(p2, v, error2, key) {\n    if (pr === p2) {\n      pr = null;\n      key !== void 0 && (resolved = true);\n      if ((p2 === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = NO_INIT;\n      completeLoad(v, error2);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === void 0) setValue(() => v);\n      setState(err !== void 0 ? \"errored\" : resolved ? \"ready\" : \"unresolved\");\n      setError(err);\n      for (const c2 of contexts.keys()) c2.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c2 = SuspenseContext, v = value(), err = error();\n    if (err !== void 0 && !pr) throw err;\n    if (Listener && !Listener.user && c2) ;\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled) return;\n    scheduled = false;\n    const lookup = dynamic ? dynamic() : source;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    let error2;\n    const p2 = initP !== NO_INIT ? initP : untrack(() => {\n      try {\n        return fetcher(lookup, {\n          value: value(),\n          refetching\n        });\n      } catch (fetcherError) {\n        error2 = fetcherError;\n      }\n    });\n    if (error2 !== void 0) {\n      loadEnd(pr, void 0, castError(error2), lookup);\n      return;\n    } else if (!isPromise(p2)) {\n      loadEnd(pr, p2, void 0, lookup);\n      return p2;\n    }\n    pr = p2;\n    if (\"v\" in p2) {\n      if (p2.s === 1) loadEnd(pr, p2.v, void 0, lookup);\n      else loadEnd(pr, void 0, castError(p2.v), lookup);\n      return p2;\n    }\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p2.then((v) => loadEnd(p2, v, void 0, lookup), (e2) => loadEnd(p2, void 0, castError(e2), lookup));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s2 = state();\n        return s2 === \"pending\" || s2 === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        const err = error();\n        if (err && !pr) throw err;\n        return value();\n      }\n    }\n  });\n  let owner = Owner;\n  if (dynamic) createComputed(() => (owner = Owner, load(false)));\n  else load(false);\n  return [read, {\n    refetch: (info) => runWithOwner(owner, () => load(info)),\n    mutate: setValue\n  }];\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null) return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    if (ExternalSourceConfig) ;\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i2 = 0; i2 < deps.length; i2++) input[i2] = deps[i2]();\n    } else input = deps();\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;\n  else if (Owner.cleanups === null) Owner.cleanups = [fn];\n  else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o2, fn) {\n  const prev = Owner;\n  const prevListener = Listener;\n  Owner = o2;\n  Listener = null;\n  try {\n    return runUpdates(fn, true);\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Owner = prev;\n    Listener = prevListener;\n  }\n}\nfunction startTransition(fn) {\n  const l2 = Listener;\n  const o2 = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l2;\n    Owner = o2;\n    runUpdates(fn, false);\n    Listener = Owner = null;\n    return void 0;\n  });\n}\nconst [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let value;\n  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;\n}\nfunction children(fn) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => resolveChildren(children2()));\n  memo2.toArray = () => {\n    const c2 = memo2();\n    return Array.isArray(c2) ? c2 : c2 != null ? [c2] : [];\n  };\n  return memo2;\n}\nlet SuspenseContext;\nfunction readSignal() {\n  if (this.sources && this.state) {\n    if (this.state === STALE) updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n          const o2 = node.observers[i2];\n          const TransitionRunning = Transition$1 && Transition$1.running;\n          if (TransitionRunning && Transition$1.disposed.has(o2)) ;\n          if (TransitionRunning ? !o2.tState : !o2.state) {\n            if (o2.pure) Updates.push(o2);\n            else Effects.push(o2);\n            if (o2.observers) markDownstream(o2);\n          }\n          if (!TransitionRunning) o2.state = STALE;\n        }\n        if (Updates.length > 1e6) {\n          Updates = [];\n          if (IS_DEV) ;\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const time = ExecCount;\n  runComputation(node, node.value, time);\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  const owner = Owner, listener = Listener;\n  Listener = Owner = node;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    node.updatedAt = time + 1;\n    return handleError(err);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c2 = {\n    fn,\n    state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: Owner ? Owner.context : null,\n    pure\n  };\n  if (Owner === null) ;\n  else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned) Owner.owned = [c2];\n      else Owner.owned.push(c2);\n    }\n  }\n  return c2;\n}\nfunction runTop(node) {\n  if (node.state === 0) return;\n  if (node.state === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state) ancestors.push(node);\n  }\n  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {\n    node = ancestors[i2];\n    if (node.state === STALE) {\n      updateComputation(node);\n    } else if (node.state === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;\n  else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait) Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  const e2 = Effects;\n  Effects = null;\n  if (e2.length) runUpdates(() => runEffects(e2), false);\n}\nfunction runQueue(queue) {\n  for (let i2 = 0; i2 < queue.length; i2++) runTop(queue[i2]);\n}\nfunction runUserEffects(queue) {\n  let i2, userLength = 0;\n  for (i2 = 0; i2 < queue.length; i2++) {\n    const e2 = queue[i2];\n    if (!e2.user) runTop(e2);\n    else queue[userLength++] = e2;\n  }\n  for (i2 = 0; i2 < userLength; i2++) runTop(queue[i2]);\n}\nfunction lookUpstream(node, ignore) {\n  node.state = 0;\n  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {\n    const source = node.sources[i2];\n    if (source.sources) {\n      const state = source.state;\n      if (state === STALE) {\n        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);\n      } else if (state === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n    const o2 = node.observers[i2];\n    if (!o2.state) {\n      o2.state = PENDING;\n      if (o2.pure) Updates.push(o2);\n      else Effects.push(o2);\n      o2.observers && markDownstream(o2);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i2;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;\n      if (obs && obs.length) {\n        const n2 = obs.pop(), s2 = source.observerSlots.pop();\n        if (index < obs.length) {\n          n2.sourceSlots[s2] = index;\n          obs[index] = n2;\n          source.observerSlots[index] = s2;\n        }\n      }\n    }\n  }\n  if (node.tOwned) {\n    for (i2 = node.tOwned.length - 1; i2 >= 0; i2--) cleanNode(node.tOwned[i2]);\n    delete node.tOwned;\n  }\n  if (node.owned) {\n    for (i2 = node.owned.length - 1; i2 >= 0; i2--) cleanNode(node.owned[i2]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i2 = node.cleanups.length - 1; i2 >= 0; i2--) node.cleanups[i2]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n}\nfunction castError(err) {\n  if (err instanceof Error) return err;\n  return new Error(typeof err === \"string\" ? err : \"Unknown error\", {\n    cause: err\n  });\n}\nfunction handleError(err, owner = Owner) {\n  const error = castError(err);\n  throw error;\n}\nfunction resolveChildren(children2) {\n  if (typeof children2 === \"function\" && !children2.length) return resolveChildren(children2());\n  if (Array.isArray(children2)) {\n    const results = [];\n    for (let i2 = 0; i2 < children2.length; i2++) {\n      const result = resolveChildren(children2[i2]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children2;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = __spreadProps(__spreadValues({}, Owner.context), {\n        [id]: props.value\n      });\n      return children(() => props.children);\n    }), void 0);\n    return res;\n  };\n}\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i2 = 0; i2 < d.length; i2++) d[i2]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [], newLen = newItems.length, i2, j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot((disposer) => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = /* @__PURE__ */ new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i2 = newIndices.get(item);\n          newIndicesNext[j] = i2 === void 0 ? -1 : i2;\n          newIndices.set(item, j);\n        }\n        for (i2 = start; i2 <= end; i2++) {\n          item = items[i2];\n          j = newIndices.get(item);\n          if (j !== void 0 && j !== -1) {\n            temp[j] = mapped[i2];\n            tempdisposers[j] = disposers[i2];\n            indexes && (tempIndexes[j] = indexes[i2]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i2]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s2, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s2);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY) return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s2) {\n  return !(s2 = typeof s2 === \"function\" ? s2() : s2) ? {} : s2;\n}\nfunction resolveSources() {\n  for (let i2 = 0, length = this.length; i2 < length; ++i2) {\n    const v = this[i2]();\n    if (v !== void 0) return v;\n  }\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i2 = 0; i2 < sources.length; i2++) {\n    const s2 = sources[i2];\n    proxy = proxy || !!s2 && $PROXY in s2;\n    sources[i2] = typeof s2 === \"function\" ? (proxy = true, createMemo(s2)) : s2;\n  }\n  if (SUPPORTS_PROXY && proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          const v = resolveSource(sources[i2])[property];\n          if (v !== void 0) return v;\n        }\n      },\n      has(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          if (property in resolveSource(sources[i2])) return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i2 = 0; i2 < sources.length; i2++) keys.push(...Object.keys(resolveSource(sources[i2])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const sourcesMap = {};\n  const defined = /* @__PURE__ */ Object.create(null);\n  for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n    const source = sources[i2];\n    if (!source) continue;\n    const sourceKeys = Object.getOwnPropertyNames(source);\n    for (let i3 = sourceKeys.length - 1; i3 >= 0; i3--) {\n      const key = sourceKeys[i3];\n      if (key === \"__proto__\" || key === \"constructor\") continue;\n      const desc = Object.getOwnPropertyDescriptor(source, key);\n      if (!defined[key]) {\n        defined[key] = desc.get ? {\n          enumerable: true,\n          configurable: true,\n          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])\n        } : desc.value !== void 0 ? desc : void 0;\n      } else {\n        const sources2 = sourcesMap[key];\n        if (sources2) {\n          if (desc.get) sources2.push(desc.get.bind(source));\n          else if (desc.value !== void 0) sources2.push(() => desc.value);\n        }\n      }\n    }\n  }\n  const target = {};\n  const definedKeys = Object.keys(defined);\n  for (let i2 = definedKeys.length - 1; i2 >= 0; i2--) {\n    const key = definedKeys[i2], desc = defined[key];\n    if (desc && desc.get) Object.defineProperty(target, key, desc);\n    else target[key] = desc ? desc.value : void 0;\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  if (SUPPORTS_PROXY && $PROXY in props) {\n    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);\n    const res = keys.map((k) => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : void 0;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter((property) => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? void 0 : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter((k) => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const otherObject = {};\n  const objects = keys.map(() => ({}));\n  for (const propName of Object.getOwnPropertyNames(props)) {\n    const desc = Object.getOwnPropertyDescriptor(props, propName);\n    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;\n    let blocked = false;\n    let objectIndex = 0;\n    for (const k of keys) {\n      if (k.includes(propName)) {\n        blocked = true;\n        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);\n      }\n      ++objectIndex;\n    }\n    if (!blocked) {\n      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);\n    }\n  }\n  return [...objects, otherObject];\n}\nconst narrowedError = (name) => `Stale read from <${name}>.`;\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));\n}\nfunction Show(props) {\n  const keyed = props.keyed;\n  const conditionValue = createMemo(() => props.when, void 0, void 0);\n  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {\n    equals: (a2, b) => !a2 === !b\n  });\n  return createMemo(() => {\n    const c2 = condition();\n    if (c2) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      return fn ? untrack(() => child(keyed ? c2 : () => {\n        if (!untrack(condition)) throw narrowedError(\"Show\");\n        return conditionValue();\n      })) : child;\n    }\n    return props.fallback;\n  }, void 0, void 0);\n}\nfunction Switch(props) {\n  const chs = children(() => props.children);\n  const switchFunc = createMemo(() => {\n    const ch = chs();\n    const mps = Array.isArray(ch) ? ch : [ch];\n    let func = () => void 0;\n    for (let i2 = 0; i2 < mps.length; i2++) {\n      const index = i2;\n      const mp = mps[i2];\n      const prevFunc = func;\n      const conditionValue = createMemo(() => prevFunc() ? void 0 : mp.when, void 0, void 0);\n      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {\n        equals: (a2, b) => !a2 === !b\n      });\n      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);\n    }\n    return func;\n  });\n  return createMemo(() => {\n    const sel = switchFunc()();\n    if (!sel) return props.fallback;\n    const [index, conditionValue, mp] = sel;\n    const child = mp.children;\n    const fn = typeof child === \"function\" && child.length > 0;\n    return fn ? untrack(() => child(mp.keyed ? conditionValue() : () => {\n      var _a2;\n      if (((_a2 = untrack(switchFunc)()) == null ? void 0 : _a2[0]) !== index) throw narrowedError(\"Match\");\n      return conditionValue();\n    })) : child;\n  }, void 0, void 0);\n}\nfunction Match(props) {\n  return props;\n}\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"inert\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /* @__PURE__ */ new Set([\"className\", \"value\", \"readOnly\", \"noValidate\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /* @__PURE__ */ new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  class: \"className\",\n  novalidate: {\n    $: \"noValidate\",\n    FORM: 1\n  },\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction getPropAlias(prop, tagName) {\n  const a2 = PropAliases[prop];\n  return typeof a2 === \"object\" ? a2[tagName] ? a2[\"$\"] : void 0 : a2;\n}\nconst DelegatedEvents = /* @__PURE__ */ new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /* @__PURE__ */ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst memo = (fn) => createMemo(() => fn());\nfunction reconcileArrays(parentNode, a2, b) {\n  let bLength = b.length, aEnd = a2.length, bEnd = bLength, aStart = 0, bStart = 0, after = a2[aEnd - 1].nextSibling, map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a2[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a2[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a2[aStart])) a2[aStart].remove();\n        aStart++;\n      }\n    } else if (a2[aStart] === b[bEnd - 1] && b[bStart] === a2[aEnd - 1]) {\n      const node = a2[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a2[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a2[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        let i2 = bStart;\n        while (i2 < bEnd) map.set(b[i2], i2++);\n      }\n      const index = map.get(a2[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i2 = aStart, sequence = 1, t2;\n          while (++i2 < aEnd && i2 < bEnd) {\n            if ((t2 = map.get(a2[i2])) == null || t2 !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a2[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a2[aStart++]);\n        } else aStart++;\n      } else a2[aStart++].remove();\n    }\n  }\n}\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot((dispose2) => {\n    disposer = dispose2;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template$1(html, isImportNode, isSVG, isMathML) {\n  let node;\n  const create = () => {\n    const t2 = isMathML ? document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"template\") : document.createElement(\"template\");\n    t2.innerHTML = html;\n    return isSVG ? t2.content.firstChild.firstChild : isMathML ? t2.firstChild : t2.content.firstChild;\n  };\n  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create()), true)) : () => (node || (node = create())).cloneNode(true);\n  fn.cloneNode = fn;\n  return fn;\n}\nfunction delegateEvents(eventNames, document2 = window.document) {\n  const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());\n  for (let i2 = 0, l2 = eventNames.length; i2 < l2; i2++) {\n    const name = eventNames[i2];\n    if (!e2.has(name)) {\n      e2.add(name);\n      document2.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);\n  else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);\n  else node.setAttributeNS(namespace, name, value);\n}\nfunction setBoolAttribute(node, name, value) {\n  value ? node.setAttribute(name, \"\") : node.removeAttribute(name);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");\n  else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = (e2) => handlerFn.call(node, handler[1], e2));\n  } else node.addEventListener(name, handler, typeof handler !== \"function\" && handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);\n  let i2, len;\n  for (i2 = 0, len = prevKeys.length; i2 < len; i2++) {\n    const key = prevKeys[i2];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i2 = 0, len = classKeys.length; i2 < len; i2++) {\n    const key = classKeys[i2], classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value) return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\") return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = void 0);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s2;\n  for (s2 in prev) {\n    value[s2] == null && nodeStyle.removeProperty(s2);\n    delete prev[s2];\n  }\n  for (s2 in value) {\n    v = value[s2];\n    if (v !== prev[s2]) {\n      nodeStyle.setProperty(s2, v);\n      prev[s2] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => typeof props.ref === \"function\" && use(props.ref, node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== void 0 && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i2 = 0, nameLen = classNames.length; i2 < nameLen; i2++) node.classList.toggle(classNames[i2], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef, props) {\n  let isCE, isProp, isChildProp, propAlias, forceProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e2 = prop.slice(3);\n    prev && node.removeEventListener(e2, prev, typeof prev !== \"function\" && prev);\n    value && node.addEventListener(e2, value, typeof value !== \"function\" && value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e2 = prop.slice(10);\n    prev && node.removeEventListener(e2, prev, true);\n    value && node.addEventListener(e2, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h2 = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h2);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if (prop.slice(0, 5) === \"attr:\") {\n    setAttribute(node, prop.slice(5), value);\n  } else if (prop.slice(0, 5) === \"bool:\") {\n    setBoolAttribute(node, prop.slice(5), value);\n  } else if ((forceProp = prop.slice(0, 5) === \"prop:\") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\") || \"is\" in props)) {\n    if (forceProp) {\n      prop = prop.slice(5);\n      isProp = true;\n    }\n    if (prop === \"class\" || prop === \"className\") className(node, value);\n    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;\n    else node[propAlias || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);\n    else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e2) {\n  let node = e2.target;\n  const key = `$$${e2.type}`;\n  const oriTarget = e2.target;\n  const oriCurrentTarget = e2.currentTarget;\n  const retarget = (value) => Object.defineProperty(e2, \"target\", {\n    configurable: true,\n    value\n  });\n  const handleNode = () => {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== void 0 ? handler.call(node, data, e2) : handler.call(node, e2);\n      if (e2.cancelBubble) return;\n    }\n    node.host && typeof node.host !== \"string\" && !node.host._$host && node.contains(e2.target) && retarget(node.host);\n    return true;\n  };\n  const walkUpTree = () => {\n    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;\n  };\n  Object.defineProperty(e2, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (e2.composedPath) {\n    const path = e2.composedPath();\n    retarget(path[0]);\n    for (let i2 = 0; i2 < path.length - 2; i2++) {\n      node = path[i2];\n      if (!handleNode()) break;\n      if (node._$host) {\n        node = node._$host;\n        walkUpTree();\n        break;\n      }\n      if (node.parentNode === oriCurrentTarget) {\n        break;\n      }\n    }\n  } else walkUpTree();\n  retarget(oriTarget);\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t2 = typeof value, multi = marker !== void 0;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t2 === \"string\" || t2 === \"number\") {\n    if (t2 === \"number\") {\n      value = value.toString();\n      if (value === current) return current;\n    }\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data !== value && (node.data = value);\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t2 === \"boolean\") {\n    current = cleanChildren(parent, current, marker);\n  } else if (t2 === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value.nodeType) {\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap2) {\n  let dynamic = false;\n  for (let i2 = 0, len = array.length; i2 < len; i2++) {\n    let item = array[i2], prev = current && current[normalized.length], t2;\n    if (item == null || item === true || item === false) ;\n    else if ((t2 = typeof item) === \"object\" && item.nodeType) {\n      normalized.push(item);\n    } else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (t2 === \"function\") {\n      if (unwrap2) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);\n      else normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i2 = 0, len = array.length; i2 < len; i2++) parent.insertBefore(array[i2], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === void 0) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i2 = current.length - 1; i2 >= 0; i2--) {\n      const el = current[i2];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i2) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props, marker = document.createTextNode(\"\"), mount = () => props.mount || document.body, owner = getOwner();\n  let content;\n  createEffect(() => {\n    content || (content = runWithOwner(owner, () => createMemo(() => props.children)));\n    const el = mount();\n    if (el instanceof HTMLHeadElement) {\n      const [clean, setClean] = createSignal(false);\n      const cleanup = () => setClean(true);\n      createRoot((dispose2) => insert(el, () => !clean() ? content() : dispose2(), null));\n      onCleanup(cleanup);\n    } else {\n      const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n        mode: \"open\"\n      }) : container;\n      Object.defineProperty(container, \"_$host\", {\n        get() {\n          return marker.parentNode;\n        },\n        configurable: true\n      });\n      insert(renderRoot, content);\n      el.appendChild(container);\n      props.ref && props.ref(container);\n      onCleanup(() => el.removeChild(container));\n    }\n  }, void 0, {\n    render: true\n  });\n  return marker;\n}\nfunction createDynamic(component, props) {\n  const cached = createMemo(component);\n  return createMemo(() => {\n    const component2 = cached();\n    switch (typeof component2) {\n      case \"function\":\n        return untrack(() => component2(props));\n      case \"string\":\n        const isSvg = SVGElements.has(component2);\n        const el = createElement(component2, isSvg);\n        spread(el, props, isSvg);\n        return el;\n    }\n  });\n}\nfunction Dynamic(props) {\n  const [, others] = splitProps(props, [\"component\"]);\n  return createDynamic(() => props.component, others);\n}\nvar THEME = /* @__PURE__ */ ((THEME2) => {\n  THEME2[\"DARK\"] = \"DARK\";\n  THEME2[\"LIGHT\"] = \"LIGHT\";\n  return THEME2;\n})(THEME || {});\nlet e = { data: \"\" }, t = (t2) => \"object\" == typeof window ? ((t2 ? t2.querySelector(\"#_goober\") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement(\"style\")), { innerHTML: \" \", id: \"_goober\" })).firstChild : t2 || e, l = /(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g, a = /\\/\\*[^]*?\\*\\/|  +/g, n = /\\n+/g, o = (e2, t2) => {\n  let r = \"\", l2 = \"\", a2 = \"\";\n  for (let n2 in e2) {\n    let c2 = e2[n2];\n    \"@\" == n2[0] ? \"i\" == n2[1] ? r = n2 + \" \" + c2 + \";\" : l2 += \"f\" == n2[1] ? o(c2, n2) : n2 + \"{\" + o(c2, \"k\" == n2[1] ? \"\" : t2) + \"}\" : \"object\" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + \" \" + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, \"-$&\").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + \":\" + c2 + \";\");\n  }\n  return r + (t2 && a2 ? t2 + \"{\" + a2 + \"}\" : a2) + l2;\n}, c = {}, s = (e2) => {\n  if (\"object\" == typeof e2) {\n    let t2 = \"\";\n    for (let r in e2) t2 += r + s(e2[r]);\n    return t2;\n  }\n  return e2;\n}, i = (e2, t2, r, i2, p2) => {\n  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {\n    let t3 = 0, r2 = 11;\n    for (; t3 < e3.length; ) r2 = 101 * r2 + e3.charCodeAt(t3++) >>> 0;\n    return \"go\" + r2;\n  })(u2));\n  if (!c[d]) {\n    let t3 = u2 !== e2 ? e2 : ((e3) => {\n      let t4, r2, o2 = [{}];\n      for (; t4 = l.exec(e3.replace(a, \"\")); ) t4[4] ? o2.shift() : t4[3] ? (r2 = t4[3].replace(n, \" \").trim(), o2.unshift(o2[0][r2] = o2[0][r2] || {})) : o2[0][t4[1]] = t4[2].replace(n, \" \").trim();\n      return o2[0];\n    })(e2);\n    c[d] = o(p2 ? { [\"@keyframes \" + d]: t3 } : t3, r ? \"\" : \".\" + d);\n  }\n  let f = r && c.g ? c.g : null;\n  return r && (c.g = c[d]), ((e3, t3, r2, l2) => {\n    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r2 ? e3 + t3.data : t3.data + e3);\n  })(c[d], t2, i2, f), d;\n}, p = (e2, t2, r) => e2.reduce((e3, l2, a2) => {\n  let n2 = t2[a2];\n  if (n2 && n2.call) {\n    let e4 = n2(r), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;\n    n2 = t3 ? \".\" + t3 : e4 && \"object\" == typeof e4 ? e4.props ? \"\" : o(e4, \"\") : false === e4 ? \"\" : e4;\n  }\n  return e3 + l2 + (null == n2 ? \"\" : n2);\n}, \"\");\nfunction u(e2) {\n  let r = this || {}, l2 = e2.call ? e2(r.p) : e2;\n  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r.p) : t2), {}) : l2, t(r.target), r.g, r.o, r.k);\n}\nu.bind({ g: 1 });\nlet h = u.bind({ k: 1 });\nconst ThemeContext = createContext();\nfunction ThemeProvider(props) {\n  return createComponent(ThemeContext.Provider, {\n    value: props.theme,\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction useTheme() {\n  return useContext(ThemeContext);\n}\nfunction makeStyled(tag) {\n  let _ctx = this || {};\n  return (...args) => {\n    const Styled = (props) => {\n      const theme = useContext(ThemeContext);\n      const withTheme = mergeProps(props, { theme });\n      const clone = mergeProps(withTheme, {\n        get class() {\n          const pClass = withTheme.class, append = \"class\" in withTheme && /^go[0-9]+/.test(pClass);\n          let className2 = u.apply(\n            { target: _ctx.target, o: append, p: withTheme, g: _ctx.g },\n            args\n          );\n          return [pClass, className2].filter(Boolean).join(\" \");\n        }\n      });\n      const [local, newProps] = splitProps(clone, [\"as\", \"theme\"]);\n      const htmlProps = newProps;\n      const createTag = local.as || tag;\n      let el;\n      if (typeof createTag === \"function\") {\n        el = createTag(htmlProps);\n      } else {\n        {\n          if (_ctx.g == 1) {\n            el = document.createElement(createTag);\n            spread(el, htmlProps);\n          } else {\n            el = Dynamic(mergeProps({ component: createTag }, htmlProps));\n          }\n        }\n      }\n      return el;\n    };\n    Styled.class = (props) => {\n      return untrack(() => {\n        return u.apply({ target: _ctx.target, p: props, g: _ctx.g }, args);\n      });\n    };\n    return Styled;\n  };\n}\nconst styled = new Proxy(makeStyled, {\n  get(target, tag) {\n    return target(tag);\n  }\n});\nfunction createGlobalStyles() {\n  const fn = makeStyled.call({ g: 1 }, \"div\").apply(null, arguments);\n  return function GlobalStyles2(props) {\n    fn(props);\n    return null;\n  };\n}\nconst globalStylesTag = \"tc-root\";\nconst disableScrollClass = \"tc-disable-scroll\";\nconst usingMouseClass = \"tc-using-mouse\";\nconst GlobalStyles = () => {\n  document.body.addEventListener(\"mousedown\", () => document.body.classList.add(usingMouseClass));\n  document.body.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      document.body.classList.remove(usingMouseClass);\n    }\n  });\n  const Styles = createGlobalStyles`\n    ${globalStylesTag} * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        \n        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;        \n        -webkit-tap-highlight-color: transparent;\n    }\n    \n    ${globalStylesTag} img {\n      -webkit-user-select: none;\n      -webkit-touch-callout: none;\n    }   \n \n    ${globalStylesTag} *:focus {\n        outline: #08f auto 2px;\n    }\n    \n    ${globalStylesTag} li {\n        list-style: none;\n    }\n    \n    ${globalStylesTag} button {\n        outline: none;\n    }\n    \n    body.${disableScrollClass} {\n        position: fixed; \n        overflow-y: scroll;\n        right: 0;\n        left: 0;\n    }\n    \n    body.${usingMouseClass} ${globalStylesTag} *:focus {\n        outline: none;\n    }\n`;\n  return createComponent(Styles, {});\n};\nfunction hexToRgb(hex) {\n  if (hex[0] === \"#\") {\n    hex = hex.slice(1);\n  }\n  const bigint = parseInt(hex, 16);\n  const r = bigint >> 16 & 255;\n  const g = bigint >> 8 & 255;\n  const b = bigint & 255;\n  return [r, g, b].join(\",\");\n}\nfunction rgba(color, opacity) {\n  if (color[0] === \"#\") {\n    color = hexToRgb(color);\n  }\n  return `rgba(${color}, ${opacity})`;\n}\nfunction toPx(value) {\n  return value.toString() + \"px\";\n}\nclass InMemoryStorage {\n  constructor() {\n    this.storage = {};\n  }\n  static getInstance() {\n    if (!InMemoryStorage.instance) {\n      InMemoryStorage.instance = new InMemoryStorage();\n    }\n    return InMemoryStorage.instance;\n  }\n  get length() {\n    return Object.keys(this.storage).length;\n  }\n  clear() {\n    this.storage = {};\n  }\n  getItem(key) {\n    var _a2;\n    return (_a2 = this.storage[key]) != null ? _a2 : null;\n  }\n  key(index) {\n    var _a2;\n    const keys = Object.keys(this.storage);\n    if (index < 0 || index >= keys.length) {\n      return null;\n    }\n    return (_a2 = keys[index]) != null ? _a2 : null;\n  }\n  removeItem(key) {\n    delete this.storage[key];\n  }\n  setItem(key, value) {\n    this.storage[key] = value;\n  }\n}\nclass TonConnectUIError extends TonConnectError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIError.prototype);\n  }\n}\nfunction logDebug(...args) {\n  {\n    try {\n      console.debug(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logError(...args) {\n  {\n    try {\n      console.error(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction logWarning(...args) {\n  {\n    try {\n      console.warn(\"[TON_CONNECT_UI]\", ...args);\n    } catch (e2) {\n    }\n  }\n}\nfunction openLink(href, target = \"_self\") {\n  logDebug(\"openLink\", href, target);\n  window.open(href, target, \"noopener noreferrer\");\n}\nfunction openLinkBlank(href) {\n  openLink(href, \"_blank\");\n}\nfunction openDeeplinkWithFallback(href, fallback) {\n  const doFallback = () => {\n    if (isBrowser(\"safari\") || isOS(\"android\") && isBrowser(\"firefox\")) {\n      return;\n    }\n    fallback();\n  };\n  const fallbackTimeout = setTimeout(() => doFallback(), 200);\n  window.addEventListener(\"blur\", () => clearTimeout(fallbackTimeout), { once: true });\n  openLink(href, \"_self\");\n}\nfunction getSystemTheme() {\n  if (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: light)\").matches) {\n    return THEME.LIGHT;\n  }\n  return THEME.DARK;\n}\nfunction subscribeToThemeChange(callback) {\n  const handler = (event) => callback(event.matches ? THEME.DARK : THEME.LIGHT);\n  window.matchMedia(\"(prefers-color-scheme: dark)\").addEventListener(\"change\", handler);\n  return () => window.matchMedia(\"(prefers-color-scheme: dark)\").removeEventListener(\"change\", handler);\n}\nfunction disableScroll() {\n  if (document.documentElement.scrollHeight === document.documentElement.clientHeight) {\n    return;\n  }\n  document.body.style.top = toPx(-document.documentElement.scrollTop);\n  document.body.classList.add(disableScrollClass);\n}\nfunction enableScroll() {\n  if (!document.body.classList.contains(disableScrollClass)) {\n    return;\n  }\n  document.body.classList.remove(disableScrollClass);\n  document.documentElement.scrollTo({ top: -parseFloat(getComputedStyle(document.body).top) });\n  document.body.style.top = \"auto\";\n}\nfunction fixMobileSafariActiveTransition() {\n  if (!document.body.hasAttribute(\"ontouchstart\")) {\n    document.body.setAttribute(\"ontouchstart\", \"\");\n  }\n}\nfunction defineStylesRoot() {\n  if (!customElements.get(\"tc-root\")) {\n    customElements.define(globalStylesTag, class TcRootElement extends HTMLElement {\n    });\n  }\n}\nfunction createMacrotask(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    callback();\n  });\n}\nfunction createMacrotaskAsync(callback) {\n  return __async(this, null, function* () {\n    yield new Promise((resolve) => requestAnimationFrame(resolve));\n    return callback();\n  });\n}\nfunction preloadImages(images) {\n  if (document.readyState !== \"complete\") {\n    window.addEventListener(\"load\", () => createMacrotask(() => preloadImages(images)), {\n      once: true\n    });\n  } else {\n    images.forEach((img) => {\n      const node = new window.Image();\n      node.src = img;\n    });\n  }\n}\nfunction getWindow$1() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return void 0;\n}\nfunction tryGetLocalStorage() {\n  if (isLocalStorageAvailable()) {\n    return localStorage;\n  }\n  if (isNodeJs()) {\n    throw new TonConnectUIError(\n      \"`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector\"\n    );\n  }\n  return InMemoryStorage.getInstance();\n}\nfunction isLocalStorageAvailable() {\n  try {\n    return typeof localStorage !== \"undefined\";\n  } catch (e2) {\n    return false;\n  }\n}\nfunction isNodeJs() {\n  return typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n}\nfunction getUserAgent() {\n  var _a2, _b2, _c2;\n  const results = new UAParser().getResult();\n  const osName = (_a2 = results.os.name) == null ? void 0 : _a2.toLowerCase();\n  const deviceModel = (_b2 = results.device.model) == null ? void 0 : _b2.toLowerCase();\n  let os;\n  switch (true) {\n    case deviceModel === \"ipad\":\n      os = \"ipad\";\n      break;\n    case osName === \"ios\":\n      os = \"ios\";\n      break;\n    case osName === \"android\":\n      os = \"android\";\n      break;\n    case osName === \"mac os\":\n      os = \"macos\";\n      break;\n    case osName === \"linux\":\n      os = \"linux\";\n      break;\n    case (osName == null ? void 0 : osName.includes(\"windows\")):\n      os = \"windows\";\n      break;\n  }\n  const browserName = (_c2 = results.browser.name) == null ? void 0 : _c2.toLowerCase();\n  let browser;\n  switch (true) {\n    case browserName === \"chrome\":\n      browser = \"chrome\";\n      break;\n    case browserName === \"firefox\":\n      browser = \"firefox\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"safari\")):\n      browser = \"safari\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"opera\")):\n      browser = \"opera\";\n      break;\n  }\n  return {\n    os,\n    browser\n  };\n}\nfunction isOS(...os) {\n  return os.includes(getUserAgent().os);\n}\nfunction isBrowser(...browser) {\n  return browser.includes(getUserAgent().browser);\n}\nfunction toDeeplink(universalLink, deeplink) {\n  const url = new URL(universalLink);\n  return deeplink + url.search;\n}\nclass WalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nclass PreferredWalletStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_preferred-wallet\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setPreferredWalletAppName(name) {\n    this.localStorage.setItem(this.storageKey, name);\n  }\n  getPreferredWalletAppName() {\n    return this.localStorage.getItem(this.storageKey) || void 0;\n  }\n}\nclass LastSelectedWalletInfoStorage {\n  constructor() {\n    this.storageKey = \"ton-connect-ui_last-selected-wallet-info\";\n    this.localStorage = tryGetLocalStorage();\n  }\n  setLastSelectedWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getLastSelectedWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeLastSelectedWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nconst [walletsModalState, setWalletsModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getWalletsModalIsOpened = createMemo(() => walletsModalState().status === \"opened\");\nconst [singleWalletModalState, setSingleWalletModalState] = createSignal({\n  status: \"closed\",\n  closeReason: null\n});\nconst getSingleWalletModalIsOpened = createMemo(\n  () => singleWalletModalState().status === \"opened\"\n);\nconst getSingleWalletModalWalletInfo = createMemo(() => {\n  const state = singleWalletModalState();\n  if (state.status === \"opened\") {\n    return state.walletInfo;\n  }\n  return null;\n});\nlet lastSelectedWalletInfoStorage = typeof window !== \"undefined\" ? new LastSelectedWalletInfoStorage() : void 0;\nconst [lastSelectedWalletInfo, _setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null);\nconst setLastSelectedWalletInfo = (walletInfo) => {\n  if (!lastSelectedWalletInfoStorage) {\n    lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage();\n  }\n  if (walletInfo) {\n    lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(walletInfo);\n  } else {\n    lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo();\n  }\n  _setLastSelectedWalletInfo(walletInfo);\n};\nconst [action, setAction] = createSignal(null);\nconst common$1 = { \"close\": \"Close\", \"openWallet\": \"Open wallet\", \"copyLink\": \"Copy Link\", \"linkCopied\": \"Link Copied\", \"copied\": \"Copied\", \"yourWallet\": \"Your Wallet\", \"retry\": \"Retry\", \"get\": \"GET\", \"mobile\": \"Mobile\", \"browserExtension\": \"Browser Extension\", \"desktop\": \"Desktop\" };\nconst button$1 = { \"connectWallet\": \"Connect Wallet\", \"dropdown\": { \"copy\": \"Copy address\", \"copied\": \"Address copied!\", \"disconnect\": \"Disconnect\" } };\nconst notifications$1 = { \"confirm\": { \"header\": \"Open {{ name }} toconfirm thetransaction.\" }, \"transactionSent\": { \"header\": \"Transaction sent\", \"text\": \"Your transactionwill beprocessed inafew seconds.\" }, \"transactionCanceled\": { \"header\": \"Transaction canceled\", \"text\": \"There will be no changes toyour account.\" }, \"dataSigned\": { \"header\": \"Data signed\" }, \"signDataCanceled\": { \"header\": \"Sign data canceled\" } };\nconst walletItem$1 = { \"walletOn\": \"Wallet in\", \"recent\": \"Recent\", \"installed\": \"Installed\", \"popular\": \"Popular\" };\nconst walletModal$1 = { \"loading\": \"Loading wallets\", \"wallets\": \"Wallets\", \"mobileUniversalModal\": { \"connectYourWallet\": \"Connect your TONwallet\", \"openWalletOnTelegramOrSelect\": \"Use Wallet in Telegram or choose other application\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram\", \"chooseOtherApplication\": \"Choose other application\", \"openLink\": \"Open Link\", \"scan\": \"Scan with your mobilewallet\" }, \"desktopUniversalModal\": { \"connectYourWallet\": \"Connect your TON wallet\", \"scan\": \"Scan with your mobile wallet\", \"availableWallets\": \"Available wallets\" }, \"mobileConnectionModal\": { \"showQR\": \"Show QR Code\", \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"continueIn\": \"Continue in {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"connectionDeclined\": \"Connection declined\" }, \"desktopConnectionModal\": { \"scanQR\": \"Scan theQR code below with your phonesor{{ name }}s camera\", \"continueInExtension\": \"Continue in{{ name }} browser extension\", \"dontHaveExtension\": \"Seems you don't have installed {{ name }}browserextension\", \"missingFeatures\": \"Please update {{ name }}, your version does not support required features for this dApp\", \"notSupportedWallet\": \"{{ name }} doesnt support the requested action. Please connect another wallet that supports it\", \"getWallet\": \"Get {{ name }}\", \"updateWallet\": \"Update {{ name }}\", \"chooseAnotherWallet\": \"Choose Another Wallet\", \"continueOnDesktop\": \"Continue in{{ name }} on desktop\", \"openWalletOnTelegram\": \"Connect Wallet in Telegram on desktop\", \"connectionDeclined\": \"Connection declined\" }, \"infoModal\": { \"whatIsAWallet\": \"What is a wallet\", \"secureDigitalAssets\": \"Secure digital assets storage\", \"walletProtects\": \"A wallet protects and manages your digital assetsincluding TON, tokens and collectables.\", \"controlIdentity\": \"Control your Web3 identity\", \"manageIdentity\": \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely intheblockchain ecosystem.\", \"effortlessCryptoTransactions\": \"Effortless crypto transactions\", \"easilySend\": \"Easily send, receive, monitor your cryptocurrencies.Streamline your operations withdecentralized applications.\", \"getAWallet\": \"Get a Wallet\" }, \"restoreModal\": { \"title\": \"Restore\", \"step1\": { \"title\": \"Find your current recovery phrase\", \"text\": \"Open your wallet settings and locate therecoveryphrase\" }, \"step2\": { \"title\": \"Copy your recovery phrase\", \"text\": \"Write it down or copy it to a safe place\" }, \"step3\": { \"title\": \"Restore in a supported wallet\", \"text\": \"Enter the recovery phrase to access your wallet\" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"The wallets below dont support all features ofthe connected service. You can use your recovery phrase in one of the supported wallets above.\", \"walletNotSupportService\": \"{{ name }} doesnt support connected service\" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }} doesnt support the requestedaction\", \"description\": \"Install a supported wallet from the list below, restore it with your recovery phrase, then connect it and try again.\", \"info\": \"Learn how to restore your wallet\" }, \"version\": { \"description\": \"Your current version of {{ name }} or wallet contract type doesn't support the required features. Please update it to continue.\", \"updateButton\": \"Update {{ name }}\", \"aboutW5\": \"About W5\" }, \"disconnect\": { \"title\": \"Confirm Disconnect\", \"description\": \"You will be disconnected from your current wallet and redirected to connect {{ name }}.\", \"button\": \"Disconnect\" } } };\nconst actionModal$1 = { \"confirmTransaction\": { \"header\": \"Confirm thetransaction in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"signData\": { \"header\": \"Sign thedata in{{ name }}\", \"text\": \"It will only take amoment.\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst en = {\n  common: common$1,\n  button: button$1,\n  notifications: notifications$1,\n  walletItem: walletItem$1,\n  walletModal: walletModal$1,\n  actionModal: actionModal$1\n};\nconst common = { \"close\": \"\", \"openWallet\": \" \", \"copyLink\": \"\", \"linkCopied\": \" \", \"copied\": \"\", \"yourWallet\": \" \", \"retry\": \"\", \"get\": \"\", \"mobile\": \"\", \"browserExtension\": \"\", \"desktop\": \"\" };\nconst button = { \"connectWallet\": \" \", \"dropdown\": { \"copy\": \" \", \"copied\": \" !\", \"disconnect\": \" \" } };\nconst notifications = { \"confirm\": { \"header\": \" {{ name }},  .\" }, \"transactionSent\": { \"header\": \" \", \"text\": \"    .\" }, \"transactionCanceled\": { \"header\": \" \", \"text\": \"   .\" }, \"dataSigned\": { \"header\": \" \" }, \"signDataCanceled\": { \"header\": \"  \" } };\nconst walletItem = { \"walletOn\": \"Wallet \", \"recent\": \"\", \"installed\": \"\", \"popular\": \"\" };\nconst walletModal = { \"loading\": \" \", \"wallets\": \"\", \"mobileUniversalModal\": { \"connectYourWallet\": \" TON\", \"openWalletOnTelegramOrSelect\": \" Wallet Telegram   \", \"openWalletOnTelegram\": \" Wallet  Telegram\", \"chooseOtherApplication\": \"  \", \"openLink\": \"\", \"scan\": \"  \" }, \"desktopUniversalModal\": { \"connectYourWallet\": \" TON \", \"scan\": \" QR-  \", \"availableWallets\": \" \" }, \"mobileConnectionModal\": { \"showQR\": \" QR-\", \"scanQR\": \" QR-    {{ name }},  \", \"missingFeatures\": \" {{ name }},         dApp\", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"continueIn\": \"  {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"connectionDeclined\": \" \" }, \"desktopConnectionModal\": { \"scanQR\": \" QR-    {{ name }},  \", \"continueInExtension\": \"   {{ name }}\", \"dontHaveExtension\": \",    {{ name }}\", \"missingFeatures\": \" {{ name }},         dApp\", \"notSupportedWallet\": \"{{ name }}    . ,   ,   \", \"getWallet\": \" {{ name }}\", \"updateWallet\": \" {{ name }}\", \"chooseAnotherWallet\": \"  \", \"continueOnDesktop\": \" {{ name }} \", \"openWalletOnTelegram\": \" Wallet Telegram\", \"connectionDeclined\": \" \" }, \"infoModal\": { \"whatIsAWallet\": \"  ?\", \"secureDigitalAssets\": \"   \", \"walletProtects\": \"    ,  TON,   ,  .\", \"controlIdentity\": \"   Web3\", \"manageIdentity\": \"        .       .\", \"effortlessCryptoTransactions\": \" \", \"easilySend\": \" ,    .      .\", \"getAWallet\": \" \" }, \"restoreModal\": { \"title\": \"\", \"step1\": { \"title\": \"    \", \"text\": \"     \" }, \"step2\": { \"title\": \"   \", \"text\": \"      \" }, \"step3\": { \"title\": \"   \", \"text\": \"    \" } }, \"allWallets\": { \"walletsBelowNotSupported\": \"       .            .\", \"walletNotSupportService\": \"{{ name }}    \" }, \"featureNotSupported\": { \"wallet\": { \"title\": \"{{ name }}   \", \"description\": \"     ,      ,     .\", \"info\": \",   \" }, \"version\": { \"description\": \"  {{ name }}        .  ,  .\", \"updateButton\": \" {{ name }}\", \"aboutW5\": \" W5\" }, \"disconnect\": { \"title\": \" \", \"description\": \"          {{ name }}.\", \"button\": \"\" } } };\nconst actionModal = { \"confirmTransaction\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"signData\": { \"header\": \"  {{ name }}\", \"text\": \"   .\" }, \"transactionSent\": \"$notifications.transactionSent\", \"transactionCanceled\": \"$notifications.transactionCanceled\", \"dataSigned\": \"$notifications.dataSigned\", \"signDataCanceled\": \"$notifications.signDataCanceled\" };\nconst ru = {\n  common,\n  button,\n  notifications,\n  walletItem,\n  walletModal,\n  actionModal\n};\nconst i18nDictionary = {\n  en: parseDictionary(en),\n  ru: parseDictionary(ru)\n};\nfunction parseDictionary(dictionary) {\n  const refSymbol = \"$\";\n  const iterate = (subDictionary) => {\n    Object.entries(subDictionary).forEach(([key, value]) => {\n      if (typeof value === \"object\" && value) {\n        return iterate(value);\n      }\n      if (typeof value === \"string\") {\n        if (value[0] === refSymbol) {\n          const path = value.slice(1).split(\".\");\n          let obj = dictionary;\n          path.forEach((item) => {\n            if (item in obj) {\n              obj = obj[item];\n            } else {\n              throw new Error(\n                `Cannot parse translations: there is no property ${item} in translation`\n              );\n            }\n          });\n          subDictionary[key] = obj;\n        }\n        if (value.slice(0, 2) === `\\\\${refSymbol}`) {\n          subDictionary[key] = value.slice(1);\n        }\n      }\n    });\n  };\n  iterate(dictionary);\n  return dictionary;\n}\nconst ConnectorContext = createContext();\nconst $RAW = Symbol(\"store-raw\"), $NODE = Symbol(\"store-node\"), $HAS = Symbol(\"store-has\"), $SELF = Symbol(\"store-self\");\nfunction wrap$1(value) {\n  let p2 = value[$PROXY];\n  if (!p2) {\n    Object.defineProperty(value, $PROXY, {\n      value: p2 = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);\n      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n        const prop = keys[i2];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p2)\n          });\n        }\n      }\n    }\n  }\n  return p2;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);\n    else set.add(item);\n    for (let i2 = 0, l2 = item.length; i2 < l2; i2++) {\n      v = item[i2];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i2] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);\n    else set.add(item);\n    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);\n    for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n      prop = keys[i2];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = /* @__PURE__ */ Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s2, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s2.$ = set;\n  return nodes[property] = s2;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property], len = state.length;\n  if (value === void 0) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== void 0) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === void 0) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE), node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i2 = state.length; i2 < len; i2++) (node = nodes[i2]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i2 = 0; i2 < keys.length; i2 += 1) {\n    const key = keys[i2];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i2 = 0, len = next.length;\n    for (; i2 < len; i2++) {\n      const value = next[i2];\n      if (current[i2] !== value) setProperty(current, i2, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part, prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part, isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i2 = 0; i2 < part.length; i2++) {\n        updatePath(current, [part[i2]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i2 = 0; i2 < current.length; i2++) {\n        if (part(current[i2], i2)) updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i2 = from; i2 <= to; i2 += by) {\n        updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === void 0 && value == void 0) return;\n  value = unwrap(value);\n  if (part === void 0 || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\nconst defaultLightColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#0098EA\",\n  telegramButton: \"#0098EA\",\n  icon: {\n    primary: \"#0F0F0F\",\n    secondary: \"#7A8999\",\n    tertiary: \"#C1CAD2\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#FFFFFF\",\n    secondary: \"#F1F3F5\",\n    segment: \"#FFFFFF\",\n    tint: \"#F1F3F5\",\n    qr: \"#F1F3F5\"\n  },\n  text: {\n    primary: \"#0F0F0F\",\n    secondary: \"#6A7785\"\n  }\n};\nconst defaultDarkColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#0098EA\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#E5E5EA\",\n  telegramButton: \"#31A6F5\",\n  icon: {\n    primary: \"#E5E5EA\",\n    secondary: \"#909099\",\n    tertiary: \"#434347\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#121214\",\n    secondary: \"#18181A\",\n    segment: \"#262629\",\n    tint: \"#222224\",\n    qr: \"#FFFFFF\"\n  },\n  text: {\n    primary: \"#E5E5EA\",\n    secondary: \"#7D7D85\"\n  }\n};\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nfunction isObject(o2) {\n  return Object.prototype.toString.call(o2) === \"[object Object]\";\n}\nfunction isPlainObject(o2) {\n  var ctor, prot;\n  if (isObject(o2) === false) return false;\n  ctor = o2.constructor;\n  if (ctor === void 0) return true;\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction mergeOptions(options, defaultOptions) {\n  if (!options) {\n    return defaultOptions;\n  }\n  const overwriteMerge = (_, sourceArray, __) => sourceArray;\n  return deepmerge(defaultOptions, options, {\n    arrayMerge: overwriteMerge,\n    isMergeableObject: isPlainObject\n  });\n}\nconst [themeState, setThemeState] = createStore({\n  theme: THEME.LIGHT,\n  colors: defaultLightColorsSet,\n  borderRadius: \"m\"\n});\nconst themeColorsMappingDefault = {\n  [THEME.LIGHT]: defaultLightColorsSet,\n  [THEME.DARK]: defaultDarkColorsSet\n};\nconst themeCustomColors = {\n  [THEME.LIGHT]: void 0,\n  [THEME.DARK]: void 0\n};\nfunction setTheme(theme, colorsSet) {\n  if (colorsSet) {\n    themeCustomColors[THEME.DARK] = mergeOptions(\n      colorsSet[THEME.DARK],\n      themeCustomColors[THEME.DARK]\n    );\n    themeCustomColors[THEME.LIGHT] = mergeOptions(\n      colorsSet[THEME.LIGHT],\n      themeCustomColors[THEME.LIGHT]\n    );\n  }\n  setThemeState({\n    theme,\n    colors: mergeOptions(themeCustomColors[theme], themeColorsMappingDefault[theme])\n  });\n}\nfunction setBorderRadius(borderRadius) {\n  setThemeState({ borderRadius });\n}\nfunction setColors(colorsSet) {\n  themeCustomColors[THEME.DARK] = mergeOptions(\n    colorsSet[THEME.DARK],\n    themeCustomColors[THEME.DARK]\n  );\n  themeCustomColors[THEME.LIGHT] = mergeOptions(\n    colorsSet[THEME.LIGHT],\n    themeCustomColors[THEME.LIGHT]\n  );\n  setThemeState((state) => ({\n    colors: mergeOptions(\n      themeCustomColors[state.theme],\n      themeColorsMappingDefault[state.theme]\n    )\n  }));\n}\nconst ImagePlaceholder = styled.div`\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst Image = (props) => {\n  let imgRef;\n  const [image, setImage] = createSignal(null);\n  createEffect(() => {\n    const img = new window.Image();\n    img.src = props.src;\n    img.alt = props.alt || \"\";\n    img.setAttribute(\"draggable\", \"false\");\n    if (props.class) {\n      img.classList.add(props.class);\n    }\n    if (img.complete) {\n      return setImage(img);\n    }\n    img.addEventListener(\"load\", () => setImage(img));\n    return () => img.removeEventListener(\"load\", () => setImage(img));\n  });\n  return [createComponent(Show, {\n    get when() {\n      return image();\n    },\n    get children() {\n      return image();\n    }\n  }), createComponent(Show, {\n    get when() {\n      return !image();\n    },\n    get children() {\n      return createComponent(ImagePlaceholder, {\n        get [\"class\"]() {\n          return props.class;\n        },\n        ref(r$) {\n          var _ref$ = imgRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : imgRef = r$;\n        }\n      });\n    }\n  })];\n};\nlet initParams = {};\ntry {\n  let locationHash = location.hash.toString();\n  initParams = urlParseHashParams(locationHash);\n} catch (e2) {\n}\nlet tmaPlatform = \"unknown\";\nif (initParams == null ? void 0 : initParams.tgWebAppPlatform) {\n  tmaPlatform = (_a = initParams.tgWebAppPlatform) != null ? _a : \"unknown\";\n}\nif (tmaPlatform === \"unknown\") {\n  const window2 = getWindow$1();\n  tmaPlatform = (_d = (_c = (_b = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : \"unknown\";\n}\nlet webAppVersion = \"6.0\";\nif (initParams == null ? void 0 : initParams.tgWebAppVersion) {\n  webAppVersion = initParams.tgWebAppVersion;\n}\nif (!webAppVersion) {\n  const window2 = getWindow$1();\n  webAppVersion = (_g = (_f = (_e = window2 == null ? void 0 : window2.Telegram) == null ? void 0 : _e.WebApp) == null ? void 0 : _f.version) != null ? _g : \"6.0\";\n}\nfunction isTmaPlatform(...platforms) {\n  return platforms.includes(tmaPlatform);\n}\nfunction isInTMA() {\n  var _a2;\n  return tmaPlatform !== \"unknown\" || !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebviewProxy);\n}\nfunction isInTelegramBrowser() {\n  var _a2;\n  const isTelegramWebview = !!((_a2 = getWindow$1()) == null ? void 0 : _a2.TelegramWebview);\n  return (isInTMA() || isTelegramWebview) && tmaPlatform === \"unknown\";\n}\nfunction sendExpand() {\n  postEvent(\"web_app_expand\", {});\n}\nfunction sendOpenTelegramLink(link, fallback) {\n  const url = new URL(link);\n  if (url.protocol !== \"http:\" && url.protocol !== \"https:\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url protocol is not supported: ${url}`);\n  }\n  if (url.hostname !== \"t.me\") {\n    if (fallback) {\n      return fallback();\n    }\n    throw new TonConnectUIError(`Url host is not supported: ${url}`);\n  }\n  const pathFull = url.pathname + url.search;\n  if (isIframe() || versionAtLeast(\"6.1\")) {\n    postEvent(\"web_app_open_tg_link\", { path_full: pathFull });\n  } else {\n    openLinkBlank(\"https://t.me\" + pathFull);\n  }\n}\nfunction isIframe() {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      return false;\n    }\n    return window2.parent != null && window2 !== window2.parent;\n  } catch (e2) {\n    return false;\n  }\n}\nfunction postEvent(eventType, eventData) {\n  try {\n    const window2 = getWindow$1();\n    if (!window2) {\n      throw new TonConnectUIError(`Can't post event to parent window: window is not defined`);\n    }\n    if (window2.TelegramWebviewProxy !== void 0) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    } else if (window2.external && \"notify\" in window2.external) {\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.external.notify(JSON.stringify({ eventType, eventData }));\n    } else if (isIframe()) {\n      const trustedTarget = \"*\";\n      const message = JSON.stringify({ eventType, eventData });\n      logDebug(\"postEvent\", eventType, eventData);\n      window2.parent.postMessage(message, trustedTarget);\n    } else {\n      throw new TonConnectUIError(`Can't post event to TMA`);\n    }\n  } catch (e2) {\n    logError(`Can't post event to parent window: ${e2}`);\n  }\n}\nfunction urlParseHashParams(locationHash) {\n  locationHash = locationHash.replace(/^#/, \"\");\n  let params = {};\n  if (!locationHash.length) {\n    return params;\n  }\n  if (locationHash.indexOf(\"=\") < 0 && locationHash.indexOf(\"?\") < 0) {\n    params._path = urlSafeDecode(locationHash);\n    return params;\n  }\n  let qIndex = locationHash.indexOf(\"?\");\n  if (qIndex >= 0) {\n    let pathParam = locationHash.substr(0, qIndex);\n    params._path = urlSafeDecode(pathParam);\n    locationHash = locationHash.substr(qIndex + 1);\n  }\n  let query_params = urlParseQueryString(locationHash);\n  for (let k in query_params) {\n    params[k] = query_params[k];\n  }\n  return params;\n}\nfunction urlSafeDecode(urlencoded) {\n  try {\n    urlencoded = urlencoded.replace(/\\+/g, \"%20\");\n    return decodeURIComponent(urlencoded);\n  } catch (e2) {\n    return urlencoded;\n  }\n}\nfunction urlParseQueryString(queryString) {\n  let params = {};\n  if (!queryString.length) {\n    return params;\n  }\n  let queryStringParams = queryString.split(\"&\");\n  let i2, param, paramName, paramValue;\n  for (i2 = 0; i2 < queryStringParams.length; i2++) {\n    param = queryStringParams[i2].split(\"=\");\n    paramName = urlSafeDecode(param[0]);\n    paramValue = param[1] == null ? null : urlSafeDecode(param[1]);\n    params[paramName] = paramValue;\n  }\n  return params;\n}\nfunction versionCompare(v1, v2) {\n  if (typeof v1 !== \"string\") v1 = \"\";\n  let v1List = v1.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let v2List = v2.replace(/^\\s+|\\s+$/g, \"\").split(\".\");\n  let a2, i2, p1, p2;\n  a2 = Math.max(v1List.length, v2List.length);\n  for (i2 = 0; i2 < a2; i2++) {\n    p1 = parseInt(v1List[i2]) || 0;\n    p2 = parseInt(v2List[i2]) || 0;\n    if (p1 === p2) continue;\n    if (p1 > p2) return 1;\n    return -1;\n  }\n  return 0;\n}\nfunction versionAtLeast(ver) {\n  return versionCompare(webAppVersion, ver) >= 0;\n}\nconst maxWidth = {\n  mobile: 440,\n  tablet: 1020\n};\nfunction isDevice(device) {\n  const window2 = getWindow$1();\n  if (!window2) {\n    return device === \"desktop\";\n  }\n  if (isTmaPlatform(\"weba\")) {\n    return true;\n  }\n  const width = window2.innerWidth;\n  switch (device) {\n    case \"desktop\":\n      return width > maxWidth.tablet;\n    case \"tablet\":\n      return width > maxWidth.mobile;\n    default:\n    case \"mobile\":\n      return width <= maxWidth.mobile || isOS(\"ios\", \"android\", \"ipad\");\n  }\n}\nfunction media(device) {\n  switch (device) {\n    case \"mobile\":\n      return `@media (max-width: ${maxWidth.mobile}px)`;\n    case \"tablet\":\n      return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;\n    default:\n    case \"desktop\":\n      return `@media (min-width: ${maxWidth.tablet}px)`;\n  }\n}\nconst mediaTouch = \"@media (hover: none)\";\nconst mediaNotTouch = \"@media not all and (hover: none)\";\nconst borders$6 = {\n  m: \"100vh\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst scaleValues = {\n  s: 0.02,\n  m: 0.04\n};\nconst ButtonStyled$1 = styled.button`\n    display: ${(props) => props.leftIcon || props.rightIcon ? \"flex\" : \"inline-block\"};\n    gap: ${(props) => props.leftIcon || props.rightIcon ? \"6px\" : \"unset\"};\n    align-items: ${(props) => props.leftIcon || props.rightIcon ? \"center\" : \"unset\"};\n    justify-content: ${(props) => props.leftIcon || props.rightIcon ? \"space-between\" : \"unset\"};\n    background-color: ${(props) => props.appearance === \"flat\" ? \"transparent\" : props.appearance === \"secondary\" ? props.theme.colors.background.tint : rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.appearance === \"secondary\" ? props.theme.colors.text.primary : props.theme.colors.accent};\n\n    padding: ${(props) => props.appearance === \"flat\" ? \"0\" : \"9px 16px\"};\n    padding-left: ${(props) => props.leftIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    padding-right: ${(props) => props.rightIcon && props.appearance !== \"flat\" ? \"12px\" : \"16px\"};\n    border: none;\n    border-radius: ${(props) => borders$6[props.theme.borderRadius]};\n    cursor: ${(props) => props.disabled ? \"not-allowed\" : \"pointer\"};\n\n    font-size: 14px;\n    font-weight: 510;\n    line-height: 18px;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 + scaleValues[props.scale]})`};\n        }\n    }\n\n    &:active {\n        transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale]})`};\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale] * 2})`};\n        }\n    }\n`;\nfunction useDataAttributes(props) {\n  const keys = untrack(() => Object.keys(props).filter((key) => key.startsWith(\"data-\")));\n  const [dataAttrs] = splitProps(props, keys);\n  return dataAttrs;\n}\nconst Button = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(ButtonStyled$1, mergeProps({\n    type: \"button\",\n    get appearance() {\n      return props.appearance || \"primary\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: (e2) => {\n      var _a2;\n      return (_a2 = props.onClick) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseEnter: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseEnter) == null ? void 0 : _a2.call(props, e2);\n    },\n    onMouseLeave: (e2) => {\n      var _a2;\n      return (_a2 = props.onMouseLeave) == null ? void 0 : _a2.call(props, e2);\n    },\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get disabled() {\n      return props.disabled;\n    },\n    get scale() {\n      return props.scale || \"m\";\n    },\n    get leftIcon() {\n      return !!props.leftIcon;\n    },\n    get rightIcon() {\n      return !!props.rightIcon;\n    },\n    \"data-tc-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [memo(() => props.leftIcon), memo(() => props.children), memo(() => props.rightIcon)];\n    }\n  }));\n};\nconst noop = () => {\n};\nconst noopTransition = (el, done) => done();\nfunction createSwitchTransition(source, options) {\n  const initSource = untrack(source);\n  const initReturned = initSource ? [initSource] : [];\n  const { onEnter = noopTransition, onExit = noopTransition } = options;\n  const [returned, setReturned] = createSignal(options.appear ? [] : initReturned);\n  const [isTransitionPending] = useTransition();\n  let next;\n  let isExiting = false;\n  function exitTransition2(el, after) {\n    if (!el)\n      return after && after();\n    isExiting = true;\n    onExit(el, () => {\n      batch(() => {\n        isExiting = false;\n        setReturned((p2) => p2.filter((e2) => e2 !== el));\n        after && after();\n      });\n    });\n  }\n  function enterTransition2(after) {\n    const el = next;\n    if (!el)\n      return after && after();\n    next = void 0;\n    setReturned((p2) => [el, ...p2]);\n    onEnter(el, after != null ? after : noop);\n  }\n  const triggerTransitions = options.mode === \"out-in\" ? (\n    // exit -> enter\n    // exit -> enter\n    (prev) => isExiting || exitTransition2(prev, enterTransition2)\n  ) : options.mode === \"in-out\" ? (\n    // enter -> exit\n    // enter -> exit\n    (prev) => enterTransition2(() => exitTransition2(prev))\n  ) : (\n    // exit & enter\n    // exit & enter\n    (prev) => {\n      exitTransition2(prev);\n      enterTransition2();\n    }\n  );\n  createComputed((prev) => {\n    const el = source();\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (el !== prev) {\n      next = el;\n      batch(() => untrack(() => triggerTransitions(prev)));\n    }\n    return el;\n  }, options.appear ? void 0 : initSource);\n  return returned;\n}\nfunction createListTransition(source, options) {\n  const initSource = untrack(source);\n  const { onChange } = options;\n  let prevSet = new Set(options.appear ? void 0 : initSource);\n  const exiting = /* @__PURE__ */ new WeakSet();\n  const [toRemove, setToRemove] = createSignal([], { equals: false });\n  const [isTransitionPending] = useTransition();\n  const finishRemoved = (els) => {\n    setToRemove((p2) => (p2.push.apply(p2, els), p2));\n    for (const el of els)\n      exiting.delete(el);\n  };\n  const handleRemoved = (els, el, i2) => els.splice(i2, 0, el);\n  return createMemo((prev) => {\n    const elsToRemove = toRemove();\n    const sourceList = source();\n    sourceList[$TRACK];\n    if (untrack(isTransitionPending)) {\n      isTransitionPending();\n      return prev;\n    }\n    if (elsToRemove.length) {\n      const next = prev.filter((e2) => !elsToRemove.includes(e2));\n      elsToRemove.length = 0;\n      onChange({ list: next, added: [], removed: [], unchanged: next, finishRemoved });\n      return next;\n    }\n    return untrack(() => {\n      const nextSet = new Set(sourceList);\n      const next = sourceList.slice();\n      const added = [];\n      const removed = [];\n      const unchanged = [];\n      for (const el of sourceList) {\n        (prevSet.has(el) ? unchanged : added).push(el);\n      }\n      let nothingChanged = !added.length;\n      for (let i2 = 0; i2 < prev.length; i2++) {\n        const el = prev[i2];\n        if (!nextSet.has(el)) {\n          if (!exiting.has(el)) {\n            removed.push(el);\n            exiting.add(el);\n          }\n          handleRemoved(next, el, i2);\n        }\n        if (nothingChanged && el !== next[i2])\n          nothingChanged = false;\n      }\n      if (!removed.length && nothingChanged)\n        return prev;\n      onChange({ list: next, added, removed, unchanged, finishRemoved });\n      prevSet = nextSet;\n      return next;\n    });\n  }, options.appear ? [] : initSource.slice());\n}\nconst defaultElementPredicate = (item) => item instanceof Element;\nfunction getResolvedElements(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getResolvedElements(value(), predicate);\n  if (Array.isArray(value)) {\n    const results = [];\n    for (const item of value) {\n      const result = getResolvedElements(item, predicate);\n      if (result)\n        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results.length ? results : null;\n  }\n  return null;\n}\nfunction resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  const memo2 = createMemo(() => getResolvedElements(children2(), predicate));\n  memo2.toArray = () => {\n    const value = memo2();\n    return Array.isArray(value) ? value : value ? [value] : [];\n  };\n  return memo2;\n}\nfunction getFirstChild(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getFirstChild(value(), predicate);\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      const result = getFirstChild(item, predicate);\n      if (result)\n        return result;\n    }\n  }\n  return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  return createMemo(() => getFirstChild(children2(), predicate));\n}\nfunction createClassnames(props) {\n  return createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActive: (props.enterActiveClass || name + \"-enter-active\").split(\" \"),\n      enter: (props.enterClass || name + \"-enter\").split(\" \"),\n      enterTo: (props.enterToClass || name + \"-enter-to\").split(\" \"),\n      exitActive: (props.exitActiveClass || name + \"-exit-active\").split(\" \"),\n      exit: (props.exitClass || name + \"-exit\").split(\" \"),\n      exitTo: (props.exitToClass || name + \"-exit-to\").split(\" \"),\n      move: (props.moveClass || name + \"-move\").split(\" \")\n    };\n  });\n}\nfunction nextFrame(fn) {\n  requestAnimationFrame(() => requestAnimationFrame(fn));\n}\nfunction enterTransition(classes, events, el, done) {\n  const { onBeforeEnter, onEnter, onAfterEnter } = events;\n  onBeforeEnter == null ? void 0 : onBeforeEnter(el);\n  el.classList.add(...classes.enter);\n  el.classList.add(...classes.enterActive);\n  queueMicrotask(() => {\n    if (!el.parentNode)\n      return done == null ? void 0 : done();\n    onEnter == null ? void 0 : onEnter(el, () => endTransition());\n  });\n  nextFrame(() => {\n    el.classList.remove(...classes.enter);\n    el.classList.add(...classes.enterTo);\n    if (!onEnter || onEnter.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.enterActive);\n      el.classList.remove(...classes.enterTo);\n      onAfterEnter == null ? void 0 : onAfterEnter(el);\n    }\n  }\n}\nfunction exitTransition(classes, events, el, done) {\n  const { onBeforeExit, onExit, onAfterExit } = events;\n  if (!el.parentNode)\n    return done == null ? void 0 : done();\n  onBeforeExit == null ? void 0 : onBeforeExit(el);\n  el.classList.add(...classes.exit);\n  el.classList.add(...classes.exitActive);\n  onExit == null ? void 0 : onExit(el, () => endTransition());\n  nextFrame(() => {\n    el.classList.remove(...classes.exit);\n    el.classList.add(...classes.exitTo);\n    if (!onExit || onExit.length < 2) {\n      el.addEventListener(\"transitionend\", endTransition);\n      el.addEventListener(\"animationend\", endTransition);\n    }\n  });\n  function endTransition(e2) {\n    if (!e2 || e2.target === el) {\n      done == null ? void 0 : done();\n      el.removeEventListener(\"transitionend\", endTransition);\n      el.removeEventListener(\"animationend\", endTransition);\n      el.classList.remove(...classes.exitActive);\n      el.classList.remove(...classes.exitTo);\n      onAfterExit == null ? void 0 : onAfterExit(el);\n    }\n  }\n}\nconst TRANSITION_MODE_MAP = {\n  inout: \"in-out\",\n  outin: \"out-in\"\n};\nconst Transition = (props) => {\n  const classnames = createClassnames(props);\n  return createSwitchTransition(resolveFirst(() => props.children), {\n    mode: TRANSITION_MODE_MAP[props.mode],\n    appear: props.appear,\n    onEnter(el, done) {\n      enterTransition(classnames(), props, el, done);\n    },\n    onExit(el, done) {\n      exitTransition(classnames(), props, el, done);\n    }\n  });\n};\nconst TransitionGroup = (props) => {\n  const classnames = createClassnames(props);\n  return createListTransition(resolveElements(() => props.children).toArray, {\n    appear: props.appear,\n    onChange({ added, removed, finishRemoved, list }) {\n      const classes = classnames();\n      for (const el of added) {\n        enterTransition(classes, props, el);\n      }\n      const toMove = [];\n      for (const el of list) {\n        if (el.isConnected && (el instanceof HTMLElement || el instanceof SVGElement)) {\n          toMove.push({ el, rect: el.getBoundingClientRect() });\n        }\n      }\n      queueMicrotask(() => {\n        const moved = [];\n        for (const { el, rect } of toMove) {\n          if (el.isConnected) {\n            const newRect = el.getBoundingClientRect(), dX = rect.left - newRect.left, dY = rect.top - newRect.top;\n            if (dX || dY) {\n              el.style.transform = `translate(${dX}px, ${dY}px)`;\n              el.style.transitionDuration = \"0s\";\n              moved.push(el);\n            }\n          }\n        }\n        document.body.offsetHeight;\n        for (const el of moved) {\n          let endTransition = function(e2) {\n            if (e2.target === el || /transform$/.test(e2.propertyName)) {\n              el.removeEventListener(\"transitionend\", endTransition);\n              el.classList.remove(...classes.move);\n            }\n          };\n          el.classList.add(...classes.move);\n          el.style.transform = el.style.transitionDuration = \"\";\n          el.addEventListener(\"transitionend\", endTransition);\n        }\n      });\n      for (const el of removed) {\n        exitTransition(classes, props, el, () => finishRemoved([el]));\n      }\n    }\n  });\n};\nfunction clickOutside$1(el, accessor) {\n  const onClick = (e2) => {\n    var _a2;\n    return !el.contains(e2.target) && ((_a2 = accessor()) == null ? void 0 : _a2());\n  };\n  document.body.addEventListener(\"click\", onClick);\n  onCleanup(() => document.body.removeEventListener(\"click\", onClick));\n}\nfunction escPressed(_, accessor) {\n  const onKeyPress = (e2) => {\n    var _a2, _b2;\n    if (e2.key === \"Escape\") {\n      (_a2 = document.activeElement) == null ? void 0 : _a2.blur();\n      (_b2 = accessor()) == null ? void 0 : _b2();\n    }\n  };\n  document.body.addEventListener(\"keydown\", onKeyPress);\n  onCleanup(() => document.body.removeEventListener(\"keydown\", onKeyPress));\n}\nfunction androidBackHandler$1(_, config) {\n  const {\n    isEnabled,\n    onClose\n  } = config();\n  if (!isEnabled) {\n    return;\n  }\n  const userOSIsAndroid = getUserAgent().os === \"android\";\n  if (!userOSIsAndroid) {\n    return;\n  }\n  window.history.pushState(ROUTE_STATE, \"\");\n  const popstateHandler = (event) => {\n    event.preventDefault();\n    onClose();\n  };\n  window.addEventListener(\"popstate\", popstateHandler, {\n    once: true\n  });\n  onCleanup(() => {\n    window.removeEventListener(\"popstate\", popstateHandler);\n    createMacrotask(() => {\n      var _a2;\n      if (((_a2 = window.history.state) == null ? void 0 : _a2[ROUTE_STATE_KEY]) === true) {\n        window.history.back();\n      }\n    });\n  });\n}\nconst ROUTE_STATE_KEY = \"androidBackHandler\";\nconst ROUTE_STATE = {\n  [ROUTE_STATE_KEY]: true\n};\nvar _tmpl$$v = /* @__PURE__ */ template$1(`<svg><path fill-rule=evenodd clip-rule=evenodd d=\"M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z\"></svg>`, false, true, false);\nconst rotationDegrees = {\n  left: 0,\n  top: 90,\n  right: 180,\n  bottom: 270\n};\nconst ArrowIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  const direction = () => props.direction || \"left\";\n  const Svg = styled(\"svg\")`\n        transform: rotate(${(props2) => rotationDegrees[props2.svgDirection]}deg);\n        transition: transform 0.1s ease-in-out;\n    `;\n  return createComponent(Svg, {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"16\",\n    height: \"16\",\n    viewBox: \"0 0 16 16\",\n    fill: \"none\",\n    get svgDirection() {\n      return direction();\n    },\n    get children() {\n      var _el$ = _tmpl$$v();\n      createRenderEffect(() => setAttribute(_el$, \"fill\", fill()));\n      return _el$;\n    }\n  });\n};\nvar _tmpl$$u = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z\">`);\nconst CloseIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$u(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst IconButtonStyled = styled.button`\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background-color: ${(props) => props.theme.colors.background.tint};\n    border: none;\n    cursor: pointer;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst IconButton = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const icon = () => props.icon || \"close\";\n  return createComponent(IconButtonStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-icon-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !!props.children;\n        },\n        get children() {\n          return props.children;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.children;\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return icon() === \"close\";\n                },\n                get children() {\n                  return createComponent(CloseIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"arrow\";\n                },\n                get children() {\n                  return createComponent(ArrowIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"question\";\n                },\n                get children() {\n                  return createComponent(QuestionIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return typeof icon() !== \"string\";\n                },\n                get children() {\n                  return icon();\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  }));\n};\nconst borders$5 = {\n  m: \"24px\",\n  s: \"16px\",\n  none: \"0\"\n};\nconst ModalBackgroundStyled = styled.div`\n    display: flex;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.4);\n    padding: 20px 0;\n    overflow-y: auto;\n\n    ${media(\"mobile\")} {\n        padding-bottom: 0;\n    }\n`;\nconst ModalWrapperClass = u`\n    box-shadow:\n        0 4px 16px rgba(0, 0, 0, 0.08),\n        0 16px 64px rgba(0, 0, 0, 0.16);\n    width: fit-content;\n    margin: auto;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        height: fit-content;\n        margin: auto 0 0 0;\n    }\n`;\nconst ModalBodyStyled = styled.div`\n    position: relative;\n    min-height: 100px;\n    width: 416px;\n    padding: 44px 56px 24px;\n\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$5[props.theme.borderRadius]};\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst CloseButtonStyled = styled(IconButton)`\n    position: absolute;\n    right: 16px;\n    top: 16px;\n`;\nconst ModalFooterStyled = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 16px 16px 16px 18px;\n    border-radius: 0 0 ${(props) => borders$5[props.theme.borderRadius]}\n        ${(props) => borders$5[props.theme.borderRadius]};\n`;\nconst QuestionButtonStyled = styled(IconButton)`\n    background-color: ${(props) => rgba(props.theme.colors.icon.secondary, 0.12)};\n`;\nclass AnimationTimelineNoop {\n  constructor() {\n    this.currentTime = 0;\n  }\n}\nconst _AnimationNoop = class _AnimationNoop {\n  constructor() {\n    this.currentTime = 0;\n    this.playbackRate = 1;\n    this.startTime = null;\n    this.timeline = new AnimationTimelineNoop();\n    this.finished = Promise.resolve(this);\n    this.effect = null;\n    this.id = \"\";\n    this.pending = false;\n    this.playState = \"finished\";\n    this.replaceState = \"active\";\n    this.ready = Promise.resolve(this);\n    this.oncancel = null;\n    this.onfinish = null;\n    this.onremove = null;\n  }\n  static create() {\n    if (!_AnimationNoop._instance) {\n      logWarning(\n        \"Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API.\"\n      );\n      _AnimationNoop._instance = new _AnimationNoop();\n    }\n    return _AnimationNoop._instance;\n  }\n  cancel() {\n  }\n  finish() {\n  }\n  pause() {\n  }\n  play() {\n  }\n  reverse() {\n  }\n  addEventListener(_type, _listener, _options) {\n  }\n  dispatchEvent(_event) {\n    return false;\n  }\n  removeEventListener(_type, _callback, _options) {\n  }\n  updatePlaybackRate(_playbackRate) {\n  }\n  commitStyles() {\n  }\n  persist() {\n  }\n};\n_AnimationNoop._instance = null;\nlet AnimationNoop = _AnimationNoop;\nfunction animate(element, keyframes, options) {\n  if (\"animate\" in element) {\n    return element.animate(keyframes, options);\n  }\n  return AnimationNoop.create();\n}\nvar _tmpl$$t = /* @__PURE__ */ template$1(`<div>`);\nconst clickOutside = clickOutside$1;\nconst keyPressed = escPressed;\nconst androidBackHandler = androidBackHandler$1;\nconst Modal = (props) => {\n  const theme = useTheme();\n  const dataAttrs = useDataAttributes(props);\n  createEffect(() => {\n    if (props.opened) {\n      disableScroll();\n    } else {\n      enableScroll();\n    }\n  });\n  return createComponent(Transition, {\n    onBeforeEnter: (el) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      animate(el, [{\n        opacity: 0\n      }, {\n        opacity: 1\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        animate(el.firstElementChild, [{\n          transform: \"translateY(390px)\"\n        }, {\n          transform: \"translateY(0)\"\n        }], {\n          duration\n        });\n      }\n    },\n    onExit: (el, done) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      const backgroundAnimation = animate(el, [{\n        opacity: 1\n      }, {\n        opacity: 0\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        const contentAnimation = animate(el.firstElementChild, [{\n          transform: \"translateY(0)\"\n        }, {\n          transform: \"translateY(390px)\"\n        }], {\n          duration\n        });\n        Promise.all([backgroundAnimation.finished, contentAnimation.finished]).then(done);\n      } else {\n        backgroundAnimation.finished.then(done);\n      }\n    },\n    get children() {\n      return createComponent(Show, {\n        get when() {\n          return props.opened;\n        },\n        get children() {\n          return createComponent(ModalBackgroundStyled, mergeProps({\n            \"data-tc-modal\": \"true\"\n          }, dataAttrs, {\n            get children() {\n              var _el$ = _tmpl$$t();\n              use(androidBackHandler, _el$, () => ({\n                isEnabled: props.enableAndroidBackHandler,\n                onClose: () => props.onClose()\n              }));\n              use(keyPressed, _el$, () => () => props.onClose());\n              use(clickOutside, _el$, () => () => props.onClose());\n              insert(_el$, createComponent(ModalBodyStyled, {\n                get [\"class\"]() {\n                  return props.class;\n                },\n                get children() {\n                  return [createComponent(CloseButtonStyled, {\n                    icon: \"close\",\n                    onClick: () => props.onClose()\n                  }), memo(() => props.children)];\n                }\n              }), null);\n              insert(_el$, createComponent(Show, {\n                get when() {\n                  return props.onClickQuestion && props.showFooter;\n                },\n                get children() {\n                  return createComponent(ModalFooterStyled, {\n                    get children() {\n                      return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {\n                        get onClick() {\n                          return props.onClickQuestion;\n                        },\n                        icon: \"question\"\n                      })];\n                    }\n                  });\n                }\n              }), null);\n              createRenderEffect(() => className(_el$, cn(ModalWrapperClass, u`\n                                border-radius: ${borders$5[theme.borderRadius]};\n                                background-color: ${theme.colors.background.tint};\n\n                                ${media(\"mobile\")} {\n                                    border-radius: ${borders$5[theme.borderRadius]}\n                                        ${borders$5[theme.borderRadius]} 0 0;\n                                }\n                            `)));\n              return _el$;\n            }\n          }));\n        }\n      });\n    }\n  });\n};\nconst wrapperBorderRadius = {\n  m: \"22px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst sliderBorderRadius = {\n  m: \"18px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst TabBarStyled = styled.div`\n    display: grid;\n    grid-template: 1fr / 1fr 1fr;\n    width: fit-content;\n    justify-items: center;\n    gap: 4px;\n\n    position: relative;\n    padding: 4px;\n    border-radius: ${(props) => wrapperBorderRadius[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst SliderStyled = styled.div`\n    position: absolute;\n    top: 4px;\n    left: 4px;\n\n    height: calc(100% - 8px);\n    width: calc(50% - 4px);\n\n    border-radius: ${(props) => sliderBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.segment};\n\n    transform: ${(props) => props.right ? \"translateX(100%)\" : \"translateX(0)\"};\n\n    transition: transform 0.13s ease-in-out;\n`;\nconst InputStyled = styled.input`\n    display: none;\n`;\nconst LabelStyled = styled.label`\n    padding: 9px 12px;\n    z-index: 1;\n\n    cursor: ${(props) => props.isActive ? \"default\" : \"pointer\"};\n\n    transition: transform 0.13s ease-in-out;\n\n    &:hover {\n        transform: ${(props) => props.isActive ? \"none\" : \"scale(1.025)\"};\n    }\n\n    > * {\n        ${(props) => !props.isActive ? `color: ${props.theme.colors.text.secondary};` : \"\"}\n    }\n`;\nconst TabBar = (props) => {\n  const groupName = \"tabBar\" + Math.floor(Math.random() * 1e4);\n  return createComponent(TabBarStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-tab-bar\": \"true\",\n    get children() {\n      return [createComponent(SliderStyled, {\n        get right() {\n          return props.selectedTabIndex === 1;\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 0;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            name: groupName,\n            get checked() {\n              return props.selectedTabIndex === 0;\n            },\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 0);\n            }\n          }), memo(() => props.tab1)];\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 1;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            get checked() {\n              return props.selectedTabIndex === 1;\n            },\n            name: groupName,\n            onInput: () => {\n              var _a2;\n              return (_a2 = props.onSelectedTabIndexChange) == null ? void 0 : _a2.call(props, 1);\n            }\n          }), memo(() => props.tab2)];\n        }\n      })];\n    }\n  });\n};\nconst backgroundBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst imageBorders = {\n  m: \"12px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst qrNormalSize = 256;\nconst imgSizeDefault = 60;\nconst picSizeDefault = 48;\nconst qrPaddingTop = 24;\nconst CopyIconButton = styled.div`\n    width: 52px;\n    height: 52px;\n    background: transparent;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: transform 0.125s ease-in-out;\n`;\nconst QrCodeBackground = styled.button`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n    background-color: ${(props) => props.theme.colors.background.qr};\n    border-radius: ${(props) => backgroundBorders[props.theme.borderRadius]};\n    padding: ${toPx(qrPaddingTop)} 0;\n    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};\n    width: 100%;\n\n    overflow: hidden;\n    cursor: pointer;\n    border: none;\n\n    ${mediaNotTouch} {\n        &:hover {\n            ${CopyIconButton.class} {\n                transform: scale(1.04);\n            }\n        }\n    }\n\n    &:active {\n        ${CopyIconButton.class} {\n            transform: scale(0.96);\n        }\n    }\n\n    ${mediaTouch} {\n        &:active {\n            ${CopyIconButton.class} {\n                transform: scale(0.92);\n            }\n        }\n    }\n`;\nconst QrCodeWrapper$2 = styled.div`\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 0 auto;\n\n    > div:first-child {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    rect {\n        fill: transparent;\n    }\n\n    path {\n        fill: ${(props) => props.theme.colors.constant.black};\n    }\n`;\nconst ImageBackground = styled.div`\n    position: absolute;\n    width: ${toPx(imgSizeDefault)};\n    height: ${toPx(imgSizeDefault)};\n    background: ${(props) => props.theme.colors.background.qr};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst ImageStyled$3 = styled(Image)`\n    width: ${(props) => toPx(props.size)};\n    height: ${(props) => toPx(props.size)};\n    border-radius: ${(props) => imageBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.qr};\n`;\nconst CopiedBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar qrcode$1 = { exports: {} };\nvar hasRequiredQrcode;\nfunction requireQrcode() {\n  if (hasRequiredQrcode) return qrcode$1.exports;\n  hasRequiredQrcode = 1;\n  (function(module, exports) {\n    var qrcode2 = function() {\n      var qrcode3 = function(typeNumber, errorCorrectionLevel) {\n        var PAD0 = 236;\n        var PAD1 = 17;\n        var _typeNumber = typeNumber;\n        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];\n        var _modules = null;\n        var _moduleCount = 0;\n        var _dataCache = null;\n        var _dataList = [];\n        var _this = {};\n        var makeImpl = function(test, maskPattern) {\n          _moduleCount = _typeNumber * 4 + 17;\n          _modules = function(moduleCount) {\n            var modules = new Array(moduleCount);\n            for (var row = 0; row < moduleCount; row += 1) {\n              modules[row] = new Array(moduleCount);\n              for (var col = 0; col < moduleCount; col += 1) {\n                modules[row][col] = null;\n              }\n            }\n            return modules;\n          }(_moduleCount);\n          setupPositionProbePattern(0, 0);\n          setupPositionProbePattern(_moduleCount - 7, 0);\n          setupPositionProbePattern(0, _moduleCount - 7);\n          setupPositionAdjustPattern();\n          setupTimingPattern();\n          setupTypeInfo(test, maskPattern);\n          if (_typeNumber >= 7) {\n            setupTypeNumber(test);\n          }\n          if (_dataCache == null) {\n            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n          }\n          mapData(_dataCache, maskPattern);\n        };\n        var setupPositionProbePattern = function(row, col) {\n          for (var r = -1; r <= 7; r += 1) {\n            if (row + r <= -1 || _moduleCount <= row + r) continue;\n            for (var c2 = -1; c2 <= 7; c2 += 1) {\n              if (col + c2 <= -1 || _moduleCount <= col + c2) continue;\n              if (0 <= r && r <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c2 && c2 <= 4) {\n                _modules[row + r][col + c2] = true;\n              } else {\n                _modules[row + r][col + c2] = false;\n              }\n            }\n          }\n        };\n        var getBestMaskPattern = function() {\n          var minLostPoint = 0;\n          var pattern = 0;\n          for (var i2 = 0; i2 < 8; i2 += 1) {\n            makeImpl(true, i2);\n            var lostPoint = QRUtil.getLostPoint(_this);\n            if (i2 == 0 || minLostPoint > lostPoint) {\n              minLostPoint = lostPoint;\n              pattern = i2;\n            }\n          }\n          return pattern;\n        };\n        var setupTimingPattern = function() {\n          for (var r = 8; r < _moduleCount - 8; r += 1) {\n            if (_modules[r][6] != null) {\n              continue;\n            }\n            _modules[r][6] = r % 2 == 0;\n          }\n          for (var c2 = 8; c2 < _moduleCount - 8; c2 += 1) {\n            if (_modules[6][c2] != null) {\n              continue;\n            }\n            _modules[6][c2] = c2 % 2 == 0;\n          }\n        };\n        var setupPositionAdjustPattern = function() {\n          var pos = QRUtil.getPatternPosition(_typeNumber);\n          for (var i2 = 0; i2 < pos.length; i2 += 1) {\n            for (var j = 0; j < pos.length; j += 1) {\n              var row = pos[i2];\n              var col = pos[j];\n              if (_modules[row][col] != null) {\n                continue;\n              }\n              for (var r = -2; r <= 2; r += 1) {\n                for (var c2 = -2; c2 <= 2; c2 += 1) {\n                  if (r == -2 || r == 2 || c2 == -2 || c2 == 2 || r == 0 && c2 == 0) {\n                    _modules[row + r][col + c2] = true;\n                  } else {\n                    _modules[row + r][col + c2] = false;\n                  }\n                }\n              }\n            }\n          }\n        };\n        var setupTypeNumber = function(test) {\n          var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[Math.floor(i2 / 3)][i2 % 3 + _moduleCount - 8 - 3] = mod;\n          }\n          for (var i2 = 0; i2 < 18; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            _modules[i2 % 3 + _moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;\n          }\n        };\n        var setupTypeInfo = function(test, maskPattern) {\n          var data = _errorCorrectionLevel << 3 | maskPattern;\n          var bits = QRUtil.getBCHTypeInfo(data);\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 6) {\n              _modules[i2][8] = mod;\n            } else if (i2 < 8) {\n              _modules[i2 + 1][8] = mod;\n            } else {\n              _modules[_moduleCount - 15 + i2][8] = mod;\n            }\n          }\n          for (var i2 = 0; i2 < 15; i2 += 1) {\n            var mod = !test && (bits >> i2 & 1) == 1;\n            if (i2 < 8) {\n              _modules[8][_moduleCount - i2 - 1] = mod;\n            } else if (i2 < 9) {\n              _modules[8][15 - i2 - 1 + 1] = mod;\n            } else {\n              _modules[8][15 - i2 - 1] = mod;\n            }\n          }\n          _modules[_moduleCount - 8][8] = !test;\n        };\n        var mapData = function(data, maskPattern) {\n          var inc = -1;\n          var row = _moduleCount - 1;\n          var bitIndex = 7;\n          var byteIndex = 0;\n          var maskFunc = QRUtil.getMaskFunction(maskPattern);\n          for (var col = _moduleCount - 1; col > 0; col -= 2) {\n            if (col == 6) col -= 1;\n            while (true) {\n              for (var c2 = 0; c2 < 2; c2 += 1) {\n                if (_modules[row][col - c2] == null) {\n                  var dark = false;\n                  if (byteIndex < data.length) {\n                    dark = (data[byteIndex] >>> bitIndex & 1) == 1;\n                  }\n                  var mask = maskFunc(row, col - c2);\n                  if (mask) {\n                    dark = !dark;\n                  }\n                  _modules[row][col - c2] = dark;\n                  bitIndex -= 1;\n                  if (bitIndex == -1) {\n                    byteIndex += 1;\n                    bitIndex = 7;\n                  }\n                }\n              }\n              row += inc;\n              if (row < 0 || _moduleCount <= row) {\n                row -= inc;\n                inc = -inc;\n                break;\n              }\n            }\n          }\n        };\n        var createBytes = function(buffer, rsBlocks) {\n          var offset = 0;\n          var maxDcCount = 0;\n          var maxEcCount = 0;\n          var dcdata = new Array(rsBlocks.length);\n          var ecdata = new Array(rsBlocks.length);\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            var dcCount = rsBlocks[r].dataCount;\n            var ecCount = rsBlocks[r].totalCount - dcCount;\n            maxDcCount = Math.max(maxDcCount, dcCount);\n            maxEcCount = Math.max(maxEcCount, ecCount);\n            dcdata[r] = new Array(dcCount);\n            for (var i2 = 0; i2 < dcdata[r].length; i2 += 1) {\n              dcdata[r][i2] = 255 & buffer.getBuffer()[i2 + offset];\n            }\n            offset += dcCount;\n            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n            var modPoly = rawPoly.mod(rsPoly);\n            ecdata[r] = new Array(rsPoly.getLength() - 1);\n            for (var i2 = 0; i2 < ecdata[r].length; i2 += 1) {\n              var modIndex = i2 + modPoly.getLength() - ecdata[r].length;\n              ecdata[r][i2] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n            }\n          }\n          var totalCodeCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalCodeCount += rsBlocks[i2].totalCount;\n          }\n          var data = new Array(totalCodeCount);\n          var index = 0;\n          for (var i2 = 0; i2 < maxDcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < dcdata[r].length) {\n                data[index] = dcdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          for (var i2 = 0; i2 < maxEcCount; i2 += 1) {\n            for (var r = 0; r < rsBlocks.length; r += 1) {\n              if (i2 < ecdata[r].length) {\n                data[index] = ecdata[r][i2];\n                index += 1;\n              }\n            }\n          }\n          return data;\n        };\n        var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {\n          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);\n          var buffer = qrBitBuffer();\n          for (var i2 = 0; i2 < dataList.length; i2 += 1) {\n            var data = dataList[i2];\n            buffer.put(data.getMode(), 4);\n            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n            data.write(buffer);\n          }\n          var totalDataCount = 0;\n          for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n            totalDataCount += rsBlocks[i2].dataCount;\n          }\n          if (buffer.getLengthInBits() > totalDataCount * 8) {\n            throw \"code length overflow. (\" + buffer.getLengthInBits() + \">\" + totalDataCount * 8 + \")\";\n          }\n          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n            buffer.put(0, 4);\n          }\n          while (buffer.getLengthInBits() % 8 != 0) {\n            buffer.putBit(false);\n          }\n          while (true) {\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD0, 8);\n            if (buffer.getLengthInBits() >= totalDataCount * 8) {\n              break;\n            }\n            buffer.put(PAD1, 8);\n          }\n          return createBytes(buffer, rsBlocks);\n        };\n        _this.addData = function(data, mode) {\n          mode = mode || \"Byte\";\n          var newData = null;\n          switch (mode) {\n            case \"Numeric\":\n              newData = qrNumber(data);\n              break;\n            case \"Alphanumeric\":\n              newData = qrAlphaNum(data);\n              break;\n            case \"Byte\":\n              newData = qr8BitByte(data);\n              break;\n            case \"Kanji\":\n              newData = qrKanji(data);\n              break;\n            default:\n              throw \"mode:\" + mode;\n          }\n          _dataList.push(newData);\n          _dataCache = null;\n        };\n        _this.isDark = function(row, col) {\n          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n            throw row + \",\" + col;\n          }\n          return _modules[row][col];\n        };\n        _this.getModuleCount = function() {\n          return _moduleCount;\n        };\n        _this.make = function() {\n          if (_typeNumber < 1) {\n            var typeNumber2 = 1;\n            for (; typeNumber2 < 40; typeNumber2++) {\n              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);\n              var buffer = qrBitBuffer();\n              for (var i2 = 0; i2 < _dataList.length; i2++) {\n                var data = _dataList[i2];\n                buffer.put(data.getMode(), 4);\n                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n                data.write(buffer);\n              }\n              var totalDataCount = 0;\n              for (var i2 = 0; i2 < rsBlocks.length; i2++) {\n                totalDataCount += rsBlocks[i2].dataCount;\n              }\n              if (buffer.getLengthInBits() <= totalDataCount * 8) {\n                break;\n              }\n            }\n            _typeNumber = typeNumber2;\n          }\n          makeImpl(false, getBestMaskPattern());\n        };\n        _this.createTableTag = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var qrHtml = \"\";\n          qrHtml += '<table style=\"';\n          qrHtml += \" border-width: 0px; border-style: none;\";\n          qrHtml += \" border-collapse: collapse;\";\n          qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\n          qrHtml += '\">';\n          qrHtml += \"<tbody>\";\n          for (var r = 0; r < _this.getModuleCount(); r += 1) {\n            qrHtml += \"<tr>\";\n            for (var c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              qrHtml += '<td style=\"';\n              qrHtml += \" border-width: 0px; border-style: none;\";\n              qrHtml += \" border-collapse: collapse;\";\n              qrHtml += \" padding: 0px; margin: 0px;\";\n              qrHtml += \" width: \" + cellSize + \"px;\";\n              qrHtml += \" height: \" + cellSize + \"px;\";\n              qrHtml += \" background-color: \";\n              qrHtml += _this.isDark(r, c2) ? \"#000000\" : \"#ffffff\";\n              qrHtml += \";\";\n              qrHtml += '\"/>';\n            }\n            qrHtml += \"</tr>\";\n          }\n          qrHtml += \"</tbody>\";\n          qrHtml += \"</table>\";\n          return qrHtml;\n        };\n        _this.createSvgTag = function(cellSize, margin, alt, title) {\n          var opts = {};\n          if (typeof arguments[0] == \"object\") {\n            opts = arguments[0];\n            cellSize = opts.cellSize;\n            margin = opts.margin;\n            alt = opts.alt;\n            title = opts.title;\n          }\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          alt = typeof alt === \"string\" ? { text: alt } : alt || {};\n          alt.text = alt.text || null;\n          alt.id = alt.text ? alt.id || \"qrcode-description\" : null;\n          title = typeof title === \"string\" ? { text: title } : title || {};\n          title.text = title.text || null;\n          title.id = title.text ? title.id || \"qrcode-title\" : null;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var c2, mc, r, mr, qrSvg = \"\", rect;\n          rect = \"l\" + cellSize + \",0 0,\" + cellSize + \" -\" + cellSize + \",0 0,-\" + cellSize + \"z \";\n          qrSvg += '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"';\n          qrSvg += !opts.scalable ? ' width=\"' + size + 'px\" height=\"' + size + 'px\"' : \"\";\n          qrSvg += ' viewBox=\"0 0 ' + size + \" \" + size + '\" ';\n          qrSvg += ' preserveAspectRatio=\"xMinYMin meet\"';\n          qrSvg += title.text || alt.text ? ' role=\"img\" aria-labelledby=\"' + escapeXml([title.id, alt.id].join(\" \").trim()) + '\"' : \"\";\n          qrSvg += \">\";\n          qrSvg += title.text ? '<title id=\"' + escapeXml(title.id) + '\">' + escapeXml(title.text) + \"</title>\" : \"\";\n          qrSvg += alt.text ? '<description id=\"' + escapeXml(alt.id) + '\">' + escapeXml(alt.text) + \"</description>\" : \"\";\n          qrSvg += '<rect width=\"100%\" height=\"100%\" fill=\"white\" cx=\"0\" cy=\"0\"/>';\n          qrSvg += '<path d=\"';\n          for (r = 0; r < _this.getModuleCount(); r += 1) {\n            mr = r * cellSize + margin;\n            for (c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n              if (_this.isDark(r, c2)) {\n                mc = c2 * cellSize + margin;\n                qrSvg += \"M\" + mc + \",\" + mr + rect;\n              }\n            }\n          }\n          qrSvg += '\" stroke=\"transparent\" fill=\"black\"/>';\n          qrSvg += \"</svg>\";\n          return qrSvg;\n        };\n        _this.createDataURL = function(cellSize, margin) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          return createDataURL(size, size, function(x, y) {\n            if (min2 <= x && x < max2 && min2 <= y && y < max2) {\n              var c2 = Math.floor((x - min2) / cellSize);\n              var r = Math.floor((y - min2) / cellSize);\n              return _this.isDark(r, c2) ? 0 : 1;\n            } else {\n              return 1;\n            }\n          });\n        };\n        _this.createImgTag = function(cellSize, margin, alt) {\n          cellSize = cellSize || 2;\n          margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var img = \"\";\n          img += \"<img\";\n          img += ' src=\"';\n          img += _this.createDataURL(cellSize, margin);\n          img += '\"';\n          img += ' width=\"';\n          img += size;\n          img += '\"';\n          img += ' height=\"';\n          img += size;\n          img += '\"';\n          if (alt) {\n            img += ' alt=\"';\n            img += escapeXml(alt);\n            img += '\"';\n          }\n          img += \"/>\";\n          return img;\n        };\n        var escapeXml = function(s2) {\n          var escaped = \"\";\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charAt(i2);\n            switch (c2) {\n              case \"<\":\n                escaped += \"&lt;\";\n                break;\n              case \">\":\n                escaped += \"&gt;\";\n                break;\n              case \"&\":\n                escaped += \"&amp;\";\n                break;\n              case '\"':\n                escaped += \"&quot;\";\n                break;\n              default:\n                escaped += c2;\n                break;\n            }\n          }\n          return escaped;\n        };\n        var _createHalfASCII = function(margin) {\n          var cellSize = 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r1, r2, p2;\n          var blocks = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \"\",\n            \"  \": \" \"\n          };\n          var blocksLastLineNoMargin = {\n            \"\": \"\",\n            \" \": \"\",\n            \" \": \" \",\n            \"  \": \" \"\n          };\n          var ascii = \"\";\n          for (y = 0; y < size; y += 2) {\n            r1 = Math.floor((y - min2) / cellSize);\n            r2 = Math.floor((y + 1 - min2) / cellSize);\n            for (x = 0; x < size; x += 1) {\n              p2 = \"\";\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r1, Math.floor((x - min2) / cellSize))) {\n                p2 = \" \";\n              }\n              if (min2 <= x && x < max2 && min2 <= y + 1 && y + 1 < max2 && _this.isDark(r2, Math.floor((x - min2) / cellSize))) {\n                p2 += \" \";\n              } else {\n                p2 += \"\";\n              }\n              ascii += margin < 1 && y + 1 >= max2 ? blocksLastLineNoMargin[p2] : blocks[p2];\n            }\n            ascii += \"\\n\";\n          }\n          if (size % 2 && margin > 0) {\n            return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join(\"\");\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.createASCII = function(cellSize, margin) {\n          cellSize = cellSize || 1;\n          if (cellSize < 2) {\n            return _createHalfASCII(margin);\n          }\n          cellSize -= 1;\n          margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n          var size = _this.getModuleCount() * cellSize + margin * 2;\n          var min2 = margin;\n          var max2 = size - margin;\n          var y, x, r, p2;\n          var white = Array(cellSize + 1).join(\"\");\n          var black = Array(cellSize + 1).join(\"  \");\n          var ascii = \"\";\n          var line = \"\";\n          for (y = 0; y < size; y += 1) {\n            r = Math.floor((y - min2) / cellSize);\n            line = \"\";\n            for (x = 0; x < size; x += 1) {\n              p2 = 1;\n              if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r, Math.floor((x - min2) / cellSize))) {\n                p2 = 0;\n              }\n              line += p2 ? white : black;\n            }\n            for (r = 0; r < cellSize; r += 1) {\n              ascii += line + \"\\n\";\n            }\n          }\n          return ascii.substring(0, ascii.length - 1);\n        };\n        _this.renderTo2dContext = function(context, cellSize) {\n          cellSize = cellSize || 2;\n          var length = _this.getModuleCount();\n          for (var row = 0; row < length; row++) {\n            for (var col = 0; col < length; col++) {\n              context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\n              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n            }\n          }\n        };\n        return _this;\n      };\n      qrcode3.stringToBytesFuncs = {\n        \"default\": function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            bytes.push(c2 & 255);\n          }\n          return bytes;\n        }\n      };\n      qrcode3.stringToBytes = qrcode3.stringToBytesFuncs[\"default\"];\n      qrcode3.createStringToBytes = function(unicodeData, numChars) {\n        var unicodeMap = function() {\n          var bin = base64DecodeInputStream(unicodeData);\n          var read = function() {\n            var b = bin.read();\n            if (b == -1) throw \"eof\";\n            return b;\n          };\n          var count = 0;\n          var unicodeMap2 = {};\n          while (true) {\n            var b0 = bin.read();\n            if (b0 == -1) break;\n            var b1 = read();\n            var b2 = read();\n            var b3 = read();\n            var k = String.fromCharCode(b0 << 8 | b1);\n            var v = b2 << 8 | b3;\n            unicodeMap2[k] = v;\n            count += 1;\n          }\n          if (count != numChars) {\n            throw count + \" != \" + numChars;\n          }\n          return unicodeMap2;\n        }();\n        var unknownChar = \"?\".charCodeAt(0);\n        return function(s2) {\n          var bytes = [];\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            var c2 = s2.charCodeAt(i2);\n            if (c2 < 128) {\n              bytes.push(c2);\n            } else {\n              var b = unicodeMap[s2.charAt(i2)];\n              if (typeof b == \"number\") {\n                if ((b & 255) == b) {\n                  bytes.push(b);\n                } else {\n                  bytes.push(b >>> 8);\n                  bytes.push(b & 255);\n                }\n              } else {\n                bytes.push(unknownChar);\n              }\n            }\n          }\n          return bytes;\n        };\n      };\n      var QRMode = {\n        MODE_NUMBER: 1 << 0,\n        MODE_ALPHA_NUM: 1 << 1,\n        MODE_8BIT_BYTE: 1 << 2,\n        MODE_KANJI: 1 << 3\n      };\n      var QRErrorCorrectionLevel = {\n        L: 1,\n        M: 0,\n        Q: 3,\n        H: 2\n      };\n      var QRMaskPattern = {\n        PATTERN000: 0,\n        PATTERN001: 1,\n        PATTERN010: 2,\n        PATTERN011: 3,\n        PATTERN100: 4,\n        PATTERN101: 5,\n        PATTERN110: 6,\n        PATTERN111: 7\n      };\n      var QRUtil = function() {\n        var PATTERN_POSITION_TABLE = [\n          [],\n          [6, 18],\n          [6, 22],\n          [6, 26],\n          [6, 30],\n          [6, 34],\n          [6, 22, 38],\n          [6, 24, 42],\n          [6, 26, 46],\n          [6, 28, 50],\n          [6, 30, 54],\n          [6, 32, 58],\n          [6, 34, 62],\n          [6, 26, 46, 66],\n          [6, 26, 48, 70],\n          [6, 26, 50, 74],\n          [6, 30, 54, 78],\n          [6, 30, 56, 82],\n          [6, 30, 58, 86],\n          [6, 34, 62, 90],\n          [6, 28, 50, 72, 94],\n          [6, 26, 50, 74, 98],\n          [6, 30, 54, 78, 102],\n          [6, 28, 54, 80, 106],\n          [6, 32, 58, 84, 110],\n          [6, 30, 58, 86, 114],\n          [6, 34, 62, 90, 118],\n          [6, 26, 50, 74, 98, 122],\n          [6, 30, 54, 78, 102, 126],\n          [6, 26, 52, 78, 104, 130],\n          [6, 30, 56, 82, 108, 134],\n          [6, 34, 60, 86, 112, 138],\n          [6, 30, 58, 86, 114, 142],\n          [6, 34, 62, 90, 118, 146],\n          [6, 30, 54, 78, 102, 126, 150],\n          [6, 24, 50, 76, 102, 128, 154],\n          [6, 28, 54, 80, 106, 132, 158],\n          [6, 32, 58, 84, 110, 136, 162],\n          [6, 26, 54, 82, 110, 138, 166],\n          [6, 30, 58, 86, 114, 142, 170]\n        ];\n        var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n        var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n        var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n        var _this = {};\n        var getBCHDigit = function(data) {\n          var digit = 0;\n          while (data != 0) {\n            digit += 1;\n            data >>>= 1;\n          }\n          return digit;\n        };\n        _this.getBCHTypeInfo = function(data) {\n          var d = data << 10;\n          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n            d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);\n          }\n          return (data << 10 | d) ^ G15_MASK;\n        };\n        _this.getBCHTypeNumber = function(data) {\n          var d = data << 12;\n          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n            d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);\n          }\n          return data << 12 | d;\n        };\n        _this.getPatternPosition = function(typeNumber) {\n          return PATTERN_POSITION_TABLE[typeNumber - 1];\n        };\n        _this.getMaskFunction = function(maskPattern) {\n          switch (maskPattern) {\n            case QRMaskPattern.PATTERN000:\n              return function(i2, j) {\n                return (i2 + j) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN001:\n              return function(i2, j) {\n                return i2 % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN010:\n              return function(i2, j) {\n                return j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN011:\n              return function(i2, j) {\n                return (i2 + j) % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN100:\n              return function(i2, j) {\n                return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN101:\n              return function(i2, j) {\n                return i2 * j % 2 + i2 * j % 3 == 0;\n              };\n            case QRMaskPattern.PATTERN110:\n              return function(i2, j) {\n                return (i2 * j % 2 + i2 * j % 3) % 2 == 0;\n              };\n            case QRMaskPattern.PATTERN111:\n              return function(i2, j) {\n                return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;\n              };\n            default:\n              throw \"bad maskPattern:\" + maskPattern;\n          }\n        };\n        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {\n          var a2 = qrPolynomial([1], 0);\n          for (var i2 = 0; i2 < errorCorrectLength; i2 += 1) {\n            a2 = a2.multiply(qrPolynomial([1, QRMath.gexp(i2)], 0));\n          }\n          return a2;\n        };\n        _this.getLengthInBits = function(mode, type) {\n          if (1 <= type && type < 10) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 10;\n              case QRMode.MODE_ALPHA_NUM:\n                return 9;\n              case QRMode.MODE_8BIT_BYTE:\n                return 8;\n              case QRMode.MODE_KANJI:\n                return 8;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 27) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 12;\n              case QRMode.MODE_ALPHA_NUM:\n                return 11;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 10;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else if (type < 41) {\n            switch (mode) {\n              case QRMode.MODE_NUMBER:\n                return 14;\n              case QRMode.MODE_ALPHA_NUM:\n                return 13;\n              case QRMode.MODE_8BIT_BYTE:\n                return 16;\n              case QRMode.MODE_KANJI:\n                return 12;\n              default:\n                throw \"mode:\" + mode;\n            }\n          } else {\n            throw \"type:\" + type;\n          }\n        };\n        _this.getLostPoint = function(qrcode4) {\n          var moduleCount = qrcode4.getModuleCount();\n          var lostPoint = 0;\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount; col += 1) {\n              var sameCount = 0;\n              var dark = qrcode4.isDark(row, col);\n              for (var r = -1; r <= 1; r += 1) {\n                if (row + r < 0 || moduleCount <= row + r) {\n                  continue;\n                }\n                for (var c2 = -1; c2 <= 1; c2 += 1) {\n                  if (col + c2 < 0 || moduleCount <= col + c2) {\n                    continue;\n                  }\n                  if (r == 0 && c2 == 0) {\n                    continue;\n                  }\n                  if (dark == qrcode4.isDark(row + r, col + c2)) {\n                    sameCount += 1;\n                  }\n                }\n              }\n              if (sameCount > 5) {\n                lostPoint += 3 + sameCount - 5;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount - 1; row += 1) {\n            for (var col = 0; col < moduleCount - 1; col += 1) {\n              var count = 0;\n              if (qrcode4.isDark(row, col)) count += 1;\n              if (qrcode4.isDark(row + 1, col)) count += 1;\n              if (qrcode4.isDark(row, col + 1)) count += 1;\n              if (qrcode4.isDark(row + 1, col + 1)) count += 1;\n              if (count == 0 || count == 4) {\n                lostPoint += 3;\n              }\n            }\n          }\n          for (var row = 0; row < moduleCount; row += 1) {\n            for (var col = 0; col < moduleCount - 6; col += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row, col + 1) && qrcode4.isDark(row, col + 2) && qrcode4.isDark(row, col + 3) && qrcode4.isDark(row, col + 4) && !qrcode4.isDark(row, col + 5) && qrcode4.isDark(row, col + 6)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount - 6; row += 1) {\n              if (qrcode4.isDark(row, col) && !qrcode4.isDark(row + 1, col) && qrcode4.isDark(row + 2, col) && qrcode4.isDark(row + 3, col) && qrcode4.isDark(row + 4, col) && !qrcode4.isDark(row + 5, col) && qrcode4.isDark(row + 6, col)) {\n                lostPoint += 40;\n              }\n            }\n          }\n          var darkCount = 0;\n          for (var col = 0; col < moduleCount; col += 1) {\n            for (var row = 0; row < moduleCount; row += 1) {\n              if (qrcode4.isDark(row, col)) {\n                darkCount += 1;\n              }\n            }\n          }\n          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n          lostPoint += ratio * 10;\n          return lostPoint;\n        };\n        return _this;\n      }();\n      var QRMath = function() {\n        var EXP_TABLE = new Array(256);\n        var LOG_TABLE = new Array(256);\n        for (var i2 = 0; i2 < 8; i2 += 1) {\n          EXP_TABLE[i2] = 1 << i2;\n        }\n        for (var i2 = 8; i2 < 256; i2 += 1) {\n          EXP_TABLE[i2] = EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];\n        }\n        for (var i2 = 0; i2 < 255; i2 += 1) {\n          LOG_TABLE[EXP_TABLE[i2]] = i2;\n        }\n        var _this = {};\n        _this.glog = function(n2) {\n          if (n2 < 1) {\n            throw \"glog(\" + n2 + \")\";\n          }\n          return LOG_TABLE[n2];\n        };\n        _this.gexp = function(n2) {\n          while (n2 < 0) {\n            n2 += 255;\n          }\n          while (n2 >= 256) {\n            n2 -= 255;\n          }\n          return EXP_TABLE[n2];\n        };\n        return _this;\n      }();\n      function qrPolynomial(num, shift2) {\n        if (typeof num.length == \"undefined\") {\n          throw num.length + \"/\" + shift2;\n        }\n        var _num = function() {\n          var offset = 0;\n          while (offset < num.length && num[offset] == 0) {\n            offset += 1;\n          }\n          var _num2 = new Array(num.length - offset + shift2);\n          for (var i2 = 0; i2 < num.length - offset; i2 += 1) {\n            _num2[i2] = num[i2 + offset];\n          }\n          return _num2;\n        }();\n        var _this = {};\n        _this.getAt = function(index) {\n          return _num[index];\n        };\n        _this.getLength = function() {\n          return _num.length;\n        };\n        _this.multiply = function(e2) {\n          var num2 = new Array(_this.getLength() + e2.getLength() - 1);\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            for (var j = 0; j < e2.getLength(); j += 1) {\n              num2[i2 + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i2)) + QRMath.glog(e2.getAt(j)));\n            }\n          }\n          return qrPolynomial(num2, 0);\n        };\n        _this.mod = function(e2) {\n          if (_this.getLength() - e2.getLength() < 0) {\n            return _this;\n          }\n          var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e2.getAt(0));\n          var num2 = new Array(_this.getLength());\n          for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n            num2[i2] = _this.getAt(i2);\n          }\n          for (var i2 = 0; i2 < e2.getLength(); i2 += 1) {\n            num2[i2] ^= QRMath.gexp(QRMath.glog(e2.getAt(i2)) + ratio);\n          }\n          return qrPolynomial(num2, 0).mod(e2);\n        };\n        return _this;\n      }\n      var QRRSBlock = function() {\n        var RS_BLOCK_TABLE = [\n          // L\n          // M\n          // Q\n          // H\n          // 1\n          [1, 26, 19],\n          [1, 26, 16],\n          [1, 26, 13],\n          [1, 26, 9],\n          // 2\n          [1, 44, 34],\n          [1, 44, 28],\n          [1, 44, 22],\n          [1, 44, 16],\n          // 3\n          [1, 70, 55],\n          [1, 70, 44],\n          [2, 35, 17],\n          [2, 35, 13],\n          // 4\n          [1, 100, 80],\n          [2, 50, 32],\n          [2, 50, 24],\n          [4, 25, 9],\n          // 5\n          [1, 134, 108],\n          [2, 67, 43],\n          [2, 33, 15, 2, 34, 16],\n          [2, 33, 11, 2, 34, 12],\n          // 6\n          [2, 86, 68],\n          [4, 43, 27],\n          [4, 43, 19],\n          [4, 43, 15],\n          // 7\n          [2, 98, 78],\n          [4, 49, 31],\n          [2, 32, 14, 4, 33, 15],\n          [4, 39, 13, 1, 40, 14],\n          // 8\n          [2, 121, 97],\n          [2, 60, 38, 2, 61, 39],\n          [4, 40, 18, 2, 41, 19],\n          [4, 40, 14, 2, 41, 15],\n          // 9\n          [2, 146, 116],\n          [3, 58, 36, 2, 59, 37],\n          [4, 36, 16, 4, 37, 17],\n          [4, 36, 12, 4, 37, 13],\n          // 10\n          [2, 86, 68, 2, 87, 69],\n          [4, 69, 43, 1, 70, 44],\n          [6, 43, 19, 2, 44, 20],\n          [6, 43, 15, 2, 44, 16],\n          // 11\n          [4, 101, 81],\n          [1, 80, 50, 4, 81, 51],\n          [4, 50, 22, 4, 51, 23],\n          [3, 36, 12, 8, 37, 13],\n          // 12\n          [2, 116, 92, 2, 117, 93],\n          [6, 58, 36, 2, 59, 37],\n          [4, 46, 20, 6, 47, 21],\n          [7, 42, 14, 4, 43, 15],\n          // 13\n          [4, 133, 107],\n          [8, 59, 37, 1, 60, 38],\n          [8, 44, 20, 4, 45, 21],\n          [12, 33, 11, 4, 34, 12],\n          // 14\n          [3, 145, 115, 1, 146, 116],\n          [4, 64, 40, 5, 65, 41],\n          [11, 36, 16, 5, 37, 17],\n          [11, 36, 12, 5, 37, 13],\n          // 15\n          [5, 109, 87, 1, 110, 88],\n          [5, 65, 41, 5, 66, 42],\n          [5, 54, 24, 7, 55, 25],\n          [11, 36, 12, 7, 37, 13],\n          // 16\n          [5, 122, 98, 1, 123, 99],\n          [7, 73, 45, 3, 74, 46],\n          [15, 43, 19, 2, 44, 20],\n          [3, 45, 15, 13, 46, 16],\n          // 17\n          [1, 135, 107, 5, 136, 108],\n          [10, 74, 46, 1, 75, 47],\n          [1, 50, 22, 15, 51, 23],\n          [2, 42, 14, 17, 43, 15],\n          // 18\n          [5, 150, 120, 1, 151, 121],\n          [9, 69, 43, 4, 70, 44],\n          [17, 50, 22, 1, 51, 23],\n          [2, 42, 14, 19, 43, 15],\n          // 19\n          [3, 141, 113, 4, 142, 114],\n          [3, 70, 44, 11, 71, 45],\n          [17, 47, 21, 4, 48, 22],\n          [9, 39, 13, 16, 40, 14],\n          // 20\n          [3, 135, 107, 5, 136, 108],\n          [3, 67, 41, 13, 68, 42],\n          [15, 54, 24, 5, 55, 25],\n          [15, 43, 15, 10, 44, 16],\n          // 21\n          [4, 144, 116, 4, 145, 117],\n          [17, 68, 42],\n          [17, 50, 22, 6, 51, 23],\n          [19, 46, 16, 6, 47, 17],\n          // 22\n          [2, 139, 111, 7, 140, 112],\n          [17, 74, 46],\n          [7, 54, 24, 16, 55, 25],\n          [34, 37, 13],\n          // 23\n          [4, 151, 121, 5, 152, 122],\n          [4, 75, 47, 14, 76, 48],\n          [11, 54, 24, 14, 55, 25],\n          [16, 45, 15, 14, 46, 16],\n          // 24\n          [6, 147, 117, 4, 148, 118],\n          [6, 73, 45, 14, 74, 46],\n          [11, 54, 24, 16, 55, 25],\n          [30, 46, 16, 2, 47, 17],\n          // 25\n          [8, 132, 106, 4, 133, 107],\n          [8, 75, 47, 13, 76, 48],\n          [7, 54, 24, 22, 55, 25],\n          [22, 45, 15, 13, 46, 16],\n          // 26\n          [10, 142, 114, 2, 143, 115],\n          [19, 74, 46, 4, 75, 47],\n          [28, 50, 22, 6, 51, 23],\n          [33, 46, 16, 4, 47, 17],\n          // 27\n          [8, 152, 122, 4, 153, 123],\n          [22, 73, 45, 3, 74, 46],\n          [8, 53, 23, 26, 54, 24],\n          [12, 45, 15, 28, 46, 16],\n          // 28\n          [3, 147, 117, 10, 148, 118],\n          [3, 73, 45, 23, 74, 46],\n          [4, 54, 24, 31, 55, 25],\n          [11, 45, 15, 31, 46, 16],\n          // 29\n          [7, 146, 116, 7, 147, 117],\n          [21, 73, 45, 7, 74, 46],\n          [1, 53, 23, 37, 54, 24],\n          [19, 45, 15, 26, 46, 16],\n          // 30\n          [5, 145, 115, 10, 146, 116],\n          [19, 75, 47, 10, 76, 48],\n          [15, 54, 24, 25, 55, 25],\n          [23, 45, 15, 25, 46, 16],\n          // 31\n          [13, 145, 115, 3, 146, 116],\n          [2, 74, 46, 29, 75, 47],\n          [42, 54, 24, 1, 55, 25],\n          [23, 45, 15, 28, 46, 16],\n          // 32\n          [17, 145, 115],\n          [10, 74, 46, 23, 75, 47],\n          [10, 54, 24, 35, 55, 25],\n          [19, 45, 15, 35, 46, 16],\n          // 33\n          [17, 145, 115, 1, 146, 116],\n          [14, 74, 46, 21, 75, 47],\n          [29, 54, 24, 19, 55, 25],\n          [11, 45, 15, 46, 46, 16],\n          // 34\n          [13, 145, 115, 6, 146, 116],\n          [14, 74, 46, 23, 75, 47],\n          [44, 54, 24, 7, 55, 25],\n          [59, 46, 16, 1, 47, 17],\n          // 35\n          [12, 151, 121, 7, 152, 122],\n          [12, 75, 47, 26, 76, 48],\n          [39, 54, 24, 14, 55, 25],\n          [22, 45, 15, 41, 46, 16],\n          // 36\n          [6, 151, 121, 14, 152, 122],\n          [6, 75, 47, 34, 76, 48],\n          [46, 54, 24, 10, 55, 25],\n          [2, 45, 15, 64, 46, 16],\n          // 37\n          [17, 152, 122, 4, 153, 123],\n          [29, 74, 46, 14, 75, 47],\n          [49, 54, 24, 10, 55, 25],\n          [24, 45, 15, 46, 46, 16],\n          // 38\n          [4, 152, 122, 18, 153, 123],\n          [13, 74, 46, 32, 75, 47],\n          [48, 54, 24, 14, 55, 25],\n          [42, 45, 15, 32, 46, 16],\n          // 39\n          [20, 147, 117, 4, 148, 118],\n          [40, 75, 47, 7, 76, 48],\n          [43, 54, 24, 22, 55, 25],\n          [10, 45, 15, 67, 46, 16],\n          // 40\n          [19, 148, 118, 6, 149, 119],\n          [18, 75, 47, 31, 76, 48],\n          [34, 54, 24, 34, 55, 25],\n          [20, 45, 15, 61, 46, 16]\n        ];\n        var qrRSBlock = function(totalCount, dataCount) {\n          var _this2 = {};\n          _this2.totalCount = totalCount;\n          _this2.dataCount = dataCount;\n          return _this2;\n        };\n        var _this = {};\n        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {\n          switch (errorCorrectionLevel) {\n            case QRErrorCorrectionLevel.L:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n            case QRErrorCorrectionLevel.M:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n            case QRErrorCorrectionLevel.Q:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n            case QRErrorCorrectionLevel.H:\n              return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n            default:\n              return void 0;\n          }\n        };\n        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {\n          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);\n          if (typeof rsBlock == \"undefined\") {\n            throw \"bad rs block @ typeNumber:\" + typeNumber + \"/errorCorrectionLevel:\" + errorCorrectionLevel;\n          }\n          var length = rsBlock.length / 3;\n          var list = [];\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            var count = rsBlock[i2 * 3 + 0];\n            var totalCount = rsBlock[i2 * 3 + 1];\n            var dataCount = rsBlock[i2 * 3 + 2];\n            for (var j = 0; j < count; j += 1) {\n              list.push(qrRSBlock(totalCount, dataCount));\n            }\n          }\n          return list;\n        };\n        return _this;\n      }();\n      var qrBitBuffer = function() {\n        var _buffer = [];\n        var _length = 0;\n        var _this = {};\n        _this.getBuffer = function() {\n          return _buffer;\n        };\n        _this.getAt = function(index) {\n          var bufIndex = Math.floor(index / 8);\n          return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;\n        };\n        _this.put = function(num, length) {\n          for (var i2 = 0; i2 < length; i2 += 1) {\n            _this.putBit((num >>> length - i2 - 1 & 1) == 1);\n          }\n        };\n        _this.getLengthInBits = function() {\n          return _length;\n        };\n        _this.putBit = function(bit) {\n          var bufIndex = Math.floor(_length / 8);\n          if (_buffer.length <= bufIndex) {\n            _buffer.push(0);\n          }\n          if (bit) {\n            _buffer[bufIndex] |= 128 >>> _length % 8;\n          }\n          _length += 1;\n        };\n        return _this;\n      };\n      var qrNumber = function(data) {\n        var _mode = QRMode.MODE_NUMBER;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var data2 = _data;\n          var i2 = 0;\n          while (i2 + 2 < data2.length) {\n            buffer.put(strToNum(data2.substring(i2, i2 + 3)), 10);\n            i2 += 3;\n          }\n          if (i2 < data2.length) {\n            if (data2.length - i2 == 1) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 1)), 4);\n            } else if (data2.length - i2 == 2) {\n              buffer.put(strToNum(data2.substring(i2, i2 + 2)), 7);\n            }\n          }\n        };\n        var strToNum = function(s2) {\n          var num = 0;\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            num = num * 10 + chatToNum(s2.charAt(i2));\n          }\n          return num;\n        };\n        var chatToNum = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          }\n          throw \"illegal char :\" + c2;\n        };\n        return _this;\n      };\n      var qrAlphaNum = function(data) {\n        var _mode = QRMode.MODE_ALPHA_NUM;\n        var _data = data;\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _data.length;\n        };\n        _this.write = function(buffer) {\n          var s2 = _data;\n          var i2 = 0;\n          while (i2 + 1 < s2.length) {\n            buffer.put(\n              getCode(s2.charAt(i2)) * 45 + getCode(s2.charAt(i2 + 1)),\n              11\n            );\n            i2 += 2;\n          }\n          if (i2 < s2.length) {\n            buffer.put(getCode(s2.charAt(i2)), 6);\n          }\n        };\n        var getCode = function(c2) {\n          if (\"0\" <= c2 && c2 <= \"9\") {\n            return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n          } else if (\"A\" <= c2 && c2 <= \"Z\") {\n            return c2.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\n          } else {\n            switch (c2) {\n              case \" \":\n                return 36;\n              case \"$\":\n                return 37;\n              case \"%\":\n                return 38;\n              case \"*\":\n                return 39;\n              case \"+\":\n                return 40;\n              case \"-\":\n                return 41;\n              case \".\":\n                return 42;\n              case \"/\":\n                return 43;\n              case \":\":\n                return 44;\n              default:\n                throw \"illegal char :\" + c2;\n            }\n          }\n        };\n        return _this;\n      };\n      var qr8BitByte = function(data) {\n        var _mode = QRMode.MODE_8BIT_BYTE;\n        var _bytes = qrcode3.stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return _bytes.length;\n        };\n        _this.write = function(buffer) {\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            buffer.put(_bytes[i2], 8);\n          }\n        };\n        return _this;\n      };\n      var qrKanji = function(data) {\n        var _mode = QRMode.MODE_KANJI;\n        var stringToBytes = qrcode3.stringToBytesFuncs[\"SJIS\"];\n        if (!stringToBytes) {\n          throw \"sjis not supported.\";\n        }\n        !function(c2, code) {\n          var test = stringToBytes(c2);\n          if (test.length != 2 || (test[0] << 8 | test[1]) != code) {\n            throw \"sjis not supported.\";\n          }\n        }(\"\", 38726);\n        var _bytes = stringToBytes(data);\n        var _this = {};\n        _this.getMode = function() {\n          return _mode;\n        };\n        _this.getLength = function(buffer) {\n          return ~~(_bytes.length / 2);\n        };\n        _this.write = function(buffer) {\n          var data2 = _bytes;\n          var i2 = 0;\n          while (i2 + 1 < data2.length) {\n            var c2 = (255 & data2[i2]) << 8 | 255 & data2[i2 + 1];\n            if (33088 <= c2 && c2 <= 40956) {\n              c2 -= 33088;\n            } else if (57408 <= c2 && c2 <= 60351) {\n              c2 -= 49472;\n            } else {\n              throw \"illegal char at \" + (i2 + 1) + \"/\" + c2;\n            }\n            c2 = (c2 >>> 8 & 255) * 192 + (c2 & 255);\n            buffer.put(c2, 13);\n            i2 += 2;\n          }\n          if (i2 < data2.length) {\n            throw \"illegal char at \" + (i2 + 1);\n          }\n        };\n        return _this;\n      };\n      var byteArrayOutputStream = function() {\n        var _bytes = [];\n        var _this = {};\n        _this.writeByte = function(b) {\n          _bytes.push(b & 255);\n        };\n        _this.writeShort = function(i2) {\n          _this.writeByte(i2);\n          _this.writeByte(i2 >>> 8);\n        };\n        _this.writeBytes = function(b, off, len) {\n          off = off || 0;\n          len = len || b.length;\n          for (var i2 = 0; i2 < len; i2 += 1) {\n            _this.writeByte(b[i2 + off]);\n          }\n        };\n        _this.writeString = function(s2) {\n          for (var i2 = 0; i2 < s2.length; i2 += 1) {\n            _this.writeByte(s2.charCodeAt(i2));\n          }\n        };\n        _this.toByteArray = function() {\n          return _bytes;\n        };\n        _this.toString = function() {\n          var s2 = \"\";\n          s2 += \"[\";\n          for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n            if (i2 > 0) {\n              s2 += \",\";\n            }\n            s2 += _bytes[i2];\n          }\n          s2 += \"]\";\n          return s2;\n        };\n        return _this;\n      };\n      var base64EncodeOutputStream = function() {\n        var _buffer = 0;\n        var _buflen = 0;\n        var _length = 0;\n        var _base64 = \"\";\n        var _this = {};\n        var writeEncoded = function(b) {\n          _base64 += String.fromCharCode(encode(b & 63));\n        };\n        var encode = function(n2) {\n          if (n2 < 0) ;\n          else if (n2 < 26) {\n            return 65 + n2;\n          } else if (n2 < 52) {\n            return 97 + (n2 - 26);\n          } else if (n2 < 62) {\n            return 48 + (n2 - 52);\n          } else if (n2 == 62) {\n            return 43;\n          } else if (n2 == 63) {\n            return 47;\n          }\n          throw \"n:\" + n2;\n        };\n        _this.writeByte = function(n2) {\n          _buffer = _buffer << 8 | n2 & 255;\n          _buflen += 8;\n          _length += 1;\n          while (_buflen >= 6) {\n            writeEncoded(_buffer >>> _buflen - 6);\n            _buflen -= 6;\n          }\n        };\n        _this.flush = function() {\n          if (_buflen > 0) {\n            writeEncoded(_buffer << 6 - _buflen);\n            _buffer = 0;\n            _buflen = 0;\n          }\n          if (_length % 3 != 0) {\n            var padlen = 3 - _length % 3;\n            for (var i2 = 0; i2 < padlen; i2 += 1) {\n              _base64 += \"=\";\n            }\n          }\n        };\n        _this.toString = function() {\n          return _base64;\n        };\n        return _this;\n      };\n      var base64DecodeInputStream = function(str) {\n        var _str = str;\n        var _pos = 0;\n        var _buffer = 0;\n        var _buflen = 0;\n        var _this = {};\n        _this.read = function() {\n          while (_buflen < 8) {\n            if (_pos >= _str.length) {\n              if (_buflen == 0) {\n                return -1;\n              }\n              throw \"unexpected end of file./\" + _buflen;\n            }\n            var c2 = _str.charAt(_pos);\n            _pos += 1;\n            if (c2 == \"=\") {\n              _buflen = 0;\n              return -1;\n            } else if (c2.match(/^\\s$/)) {\n              continue;\n            }\n            _buffer = _buffer << 6 | decode(c2.charCodeAt(0));\n            _buflen += 6;\n          }\n          var n2 = _buffer >>> _buflen - 8 & 255;\n          _buflen -= 8;\n          return n2;\n        };\n        var decode = function(c2) {\n          if (65 <= c2 && c2 <= 90) {\n            return c2 - 65;\n          } else if (97 <= c2 && c2 <= 122) {\n            return c2 - 97 + 26;\n          } else if (48 <= c2 && c2 <= 57) {\n            return c2 - 48 + 52;\n          } else if (c2 == 43) {\n            return 62;\n          } else if (c2 == 47) {\n            return 63;\n          } else {\n            throw \"c:\" + c2;\n          }\n        };\n        return _this;\n      };\n      var gifImage = function(width, height) {\n        var _width = width;\n        var _height = height;\n        var _data = new Array(width * height);\n        var _this = {};\n        _this.setPixel = function(x, y, pixel) {\n          _data[y * _width + x] = pixel;\n        };\n        _this.write = function(out) {\n          out.writeString(\"GIF87a\");\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(128);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(0);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeByte(255);\n          out.writeString(\",\");\n          out.writeShort(0);\n          out.writeShort(0);\n          out.writeShort(_width);\n          out.writeShort(_height);\n          out.writeByte(0);\n          var lzwMinCodeSize = 2;\n          var raster = getLZWRaster(lzwMinCodeSize);\n          out.writeByte(lzwMinCodeSize);\n          var offset = 0;\n          while (raster.length - offset > 255) {\n            out.writeByte(255);\n            out.writeBytes(raster, offset, 255);\n            offset += 255;\n          }\n          out.writeByte(raster.length - offset);\n          out.writeBytes(raster, offset, raster.length - offset);\n          out.writeByte(0);\n          out.writeString(\";\");\n        };\n        var bitOutputStream = function(out) {\n          var _out = out;\n          var _bitLength = 0;\n          var _bitBuffer = 0;\n          var _this2 = {};\n          _this2.write = function(data, length) {\n            if (data >>> length != 0) {\n              throw \"length over\";\n            }\n            while (_bitLength + length >= 8) {\n              _out.writeByte(255 & (data << _bitLength | _bitBuffer));\n              length -= 8 - _bitLength;\n              data >>>= 8 - _bitLength;\n              _bitBuffer = 0;\n              _bitLength = 0;\n            }\n            _bitBuffer = data << _bitLength | _bitBuffer;\n            _bitLength = _bitLength + length;\n          };\n          _this2.flush = function() {\n            if (_bitLength > 0) {\n              _out.writeByte(_bitBuffer);\n            }\n          };\n          return _this2;\n        };\n        var getLZWRaster = function(lzwMinCodeSize) {\n          var clearCode = 1 << lzwMinCodeSize;\n          var endCode = (1 << lzwMinCodeSize) + 1;\n          var bitLength = lzwMinCodeSize + 1;\n          var table = lzwTable();\n          for (var i2 = 0; i2 < clearCode; i2 += 1) {\n            table.add(String.fromCharCode(i2));\n          }\n          table.add(String.fromCharCode(clearCode));\n          table.add(String.fromCharCode(endCode));\n          var byteOut = byteArrayOutputStream();\n          var bitOut = bitOutputStream(byteOut);\n          bitOut.write(clearCode, bitLength);\n          var dataIndex = 0;\n          var s2 = String.fromCharCode(_data[dataIndex]);\n          dataIndex += 1;\n          while (dataIndex < _data.length) {\n            var c2 = String.fromCharCode(_data[dataIndex]);\n            dataIndex += 1;\n            if (table.contains(s2 + c2)) {\n              s2 = s2 + c2;\n            } else {\n              bitOut.write(table.indexOf(s2), bitLength);\n              if (table.size() < 4095) {\n                if (table.size() == 1 << bitLength) {\n                  bitLength += 1;\n                }\n                table.add(s2 + c2);\n              }\n              s2 = c2;\n            }\n          }\n          bitOut.write(table.indexOf(s2), bitLength);\n          bitOut.write(endCode, bitLength);\n          bitOut.flush();\n          return byteOut.toByteArray();\n        };\n        var lzwTable = function() {\n          var _map = {};\n          var _size = 0;\n          var _this2 = {};\n          _this2.add = function(key) {\n            if (_this2.contains(key)) {\n              throw \"dup key:\" + key;\n            }\n            _map[key] = _size;\n            _size += 1;\n          };\n          _this2.size = function() {\n            return _size;\n          };\n          _this2.indexOf = function(key) {\n            return _map[key];\n          };\n          _this2.contains = function(key) {\n            return typeof _map[key] != \"undefined\";\n          };\n          return _this2;\n        };\n        return _this;\n      };\n      var createDataURL = function(width, height, getPixel) {\n        var gif = gifImage(width, height);\n        for (var y = 0; y < height; y += 1) {\n          for (var x = 0; x < width; x += 1) {\n            gif.setPixel(x, y, getPixel(x, y));\n          }\n        }\n        var b = byteArrayOutputStream();\n        gif.write(b);\n        var base64 = base64EncodeOutputStream();\n        var bytes = b.toByteArray();\n        for (var i2 = 0; i2 < bytes.length; i2 += 1) {\n          base64.writeByte(bytes[i2]);\n        }\n        base64.flush();\n        return \"data:image/gif;base64,\" + base64;\n      };\n      return qrcode3;\n    }();\n    !function() {\n      qrcode2.stringToBytesFuncs[\"UTF-8\"] = function(s2) {\n        function toUTF8Array(str) {\n          var utf8 = [];\n          for (var i2 = 0; i2 < str.length; i2++) {\n            var charcode = str.charCodeAt(i2);\n            if (charcode < 128) utf8.push(charcode);\n            else if (charcode < 2048) {\n              utf8.push(\n                192 | charcode >> 6,\n                128 | charcode & 63\n              );\n            } else if (charcode < 55296 || charcode >= 57344) {\n              utf8.push(\n                224 | charcode >> 12,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            } else {\n              i2++;\n              charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);\n              utf8.push(\n                240 | charcode >> 18,\n                128 | charcode >> 12 & 63,\n                128 | charcode >> 6 & 63,\n                128 | charcode & 63\n              );\n            }\n          }\n          return utf8;\n        }\n        return toUTF8Array(s2);\n      };\n    }();\n    (function(factory) {\n      {\n        module.exports = factory();\n      }\n    })(function() {\n      return qrcode2;\n    });\n  })(qrcode$1);\n  return qrcode$1.exports;\n}\nvar qrcodeExports = requireQrcode();\nconst qrcode = /* @__PURE__ */ getDefaultExportFromCjs(qrcodeExports);\nfunction copyToClipboard(text) {\n  return __async(this, null, function* () {\n    try {\n      if (!(navigator == null ? void 0 : navigator.clipboard)) {\n        throw new TonConnectUIError(\"Clipboard API not available\");\n      }\n      return yield navigator.clipboard.writeText(text);\n    } catch (e2) {\n    }\n    fallbackCopyTextToClipboard(text);\n  });\n}\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\";\n  textArea.style.position = \"fixed\";\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand(\"copy\");\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\nvar _tmpl$$s = /* @__PURE__ */ template$1(`<div>`);\nconst QRCode = (props) => {\n  let qrCodeCanvasRef;\n  let qrCodeWrapperRef;\n  let imageRef;\n  const [copyButtonOpened, setCopyButtonOpened] = createSignal(false);\n  const [picSize, setPicSize] = createSignal(picSizeDefault);\n  createEffect(() => {\n    const errorCorrectionLevel = \"L\";\n    const cellSize = 4;\n    const qr = qrcode(0, errorCorrectionLevel);\n    qr.addData(props.sourceUrl);\n    qr.make();\n    qrCodeCanvasRef.innerHTML = qr.createSvgTag(cellSize, 0);\n    const qrSize = qrCodeCanvasRef.firstElementChild.clientWidth;\n    const scale = Math.round(qrNormalSize / qrSize * 1e5) / 1e5;\n    if (imageRef) {\n      const imgSize = Math.ceil(imgSizeDefault / (scale * cellSize)) * cellSize;\n      const imgOffset = toPx(Math.ceil((qrSize - imgSize) / (2 * cellSize)) * cellSize);\n      imageRef.style.top = imgOffset;\n      imageRef.style.left = imgOffset;\n      imageRef.style.height = toPx(imgSize);\n      imageRef.style.width = toPx(imgSize);\n      setPicSize(Math.round(picSizeDefault / scale));\n    }\n    qrCodeWrapperRef.style.transform = `scale(${scale})`;\n  });\n  let timeoutId = null;\n  const onCopyClick = () => {\n    setCopyButtonOpened(true);\n    copyToClipboard(props.sourceUrl);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setCopyButtonOpened(false), 1500);\n  };\n  return createComponent(QrCodeBackground, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: onCopyClick,\n    get children() {\n      return [createComponent(QrCodeWrapper$2, {\n        ref(r$) {\n          var _ref$ = qrCodeWrapperRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : qrCodeWrapperRef = r$;\n        },\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$s();\n            var _ref$2 = qrCodeCanvasRef;\n            typeof _ref$2 === \"function\" ? use(_ref$2, _el$) : qrCodeCanvasRef = _el$;\n            return _el$;\n          })(), createComponent(Show, {\n            get when() {\n              return props.imageUrl;\n            },\n            get children() {\n              return createComponent(ImageBackground, {\n                ref(r$) {\n                  var _ref$3 = imageRef;\n                  typeof _ref$3 === \"function\" ? _ref$3(r$) : imageRef = r$;\n                },\n                get children() {\n                  return createComponent(ImageStyled$3, {\n                    get src() {\n                      return props.imageUrl;\n                    },\n                    alt: \"\",\n                    get size() {\n                      return picSize();\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(Transition, {\n        onBeforeEnter: (el) => {\n          animate(el, [{\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }, {\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          });\n        },\n        onExit: (el, done) => {\n          animate(el, [{\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }, {\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }], {\n            duration: 150,\n            easing: \"ease-out\"\n          }).finished.then(() => {\n            done();\n          });\n        },\n        get children() {\n          return createComponent(Show, {\n            get when() {\n              return copyButtonOpened() && !props.disableCopy;\n            },\n            get children() {\n              return createComponent(CopiedBoxStyled, {\n                get children() {\n                  return [createComponent(SuccessIcon, {\n                    size: \"xs\"\n                  }), createComponent(Text, {\n                    translationKey: \"common.linkCopied\",\n                    children: \"Link Copied\"\n                  })];\n                }\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.disableCopy;\n        },\n        get children() {\n          return createComponent(CopyIconButton, {\n            get children() {\n              return createComponent(CopyLightIcon, {});\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nvar deepReadObject = (obj, path, defaultValue) => {\n  const value = path.trim().split(\".\").reduce((a2, b) => a2 ? a2[b] : void 0, obj);\n  return value !== void 0 ? value : defaultValue;\n};\nvar template = (str, params, reg = /{{(.*?)}}/g) => str.replace(reg, (_, key) => deepReadObject(params, key, \"\"));\nvar createI18nContext = (init = {}, lang = navigator.language in init ? navigator.language : Object.keys(init)[0]) => {\n  const [locale, setLocale] = createSignal(lang);\n  const [dict, setDict] = createStore(init);\n  const translate = (key, params, defaultValue) => {\n    const val = deepReadObject(dict[locale()], key, defaultValue || \"\");\n    if (typeof val === \"function\")\n      return val(params);\n    if (typeof val === \"string\")\n      return template(val, params || {});\n    return val;\n  };\n  const actions = {\n    add(lang2, table) {\n      setDict(lang2, (t2) => Object.assign(t2 || {}, table));\n    },\n    locale: (lang2) => lang2 ? setLocale(lang2) : locale(),\n    dict: (lang2) => deepReadObject(dict, lang2)\n  };\n  return [translate, actions];\n};\nvar I18nContext = createContext({});\nvar useI18n = () => useContext(I18nContext);\nconst TextStyled$4 = styled.div`\n    font-style: normal;\n    font-weight: ${(props) => props.fontWeight};\n    font-size: ${(props) => props.fontSize};\n    line-height: ${(props) => props.lineHeight};\n\n    color: ${(props) => props.color};\n`;\nconst Text = (inputs) => {\n  const theme = useTheme();\n  const [t2] = useI18n();\n  let textRef;\n  const color = () => inputs.color || theme.colors.text.primary;\n  const props = mergeProps({\n    fontSize: \"14px\",\n    fontWeight: \"510\",\n    lineHeight: \"130%\"\n  }, inputs);\n  createEffect(() => {\n    if (!textRef) {\n      return;\n    }\n    if (props.cursor === \"unset\") {\n      return;\n    }\n    if (getComputedStyle(textRef).cursor !== \"pointer\") {\n      textRef.style.cursor = \"default\";\n    }\n  });\n  return createComponent(TextStyled$4, {\n    get fontSize() {\n      return props.fontSize;\n    },\n    get fontWeight() {\n      return props.fontWeight;\n    },\n    get lineHeight() {\n      return props.lineHeight;\n    },\n    get color() {\n      return color();\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    ref(r$) {\n      var _ref$ = textRef;\n      typeof _ref$ === \"function\" ? _ref$(r$) : textRef = r$;\n    },\n    \"data-tc-text\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst ImageContainer = styled.div`\n    position: relative;\n\n    &::after {\n        content: '';\n        display: block;\n        position: absolute;\n        top: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border: 0.5px solid rgba(0, 0, 0, 0.08);\n        border-radius: inherit;\n    }\n`;\nconst ImageStyled$2 = styled(Image)`\n    width: 100%;\n    height: 100%;\n    border-radius: inherit;\n`;\nconst WalletImage = (props) => {\n  return createComponent(ImageContainer, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return [createComponent(ImageStyled$2, {\n        get src() {\n          return props.src;\n        }\n      }), memo(() => props.badge)];\n    }\n  });\n};\nconst borders$4 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst badgeBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst WalletUlContainer = styled.ul`\n    display: flex;\n    gap: 0;\n    width: 100%;\n    overflow-x: auto;\n    padding: 8px 12px 16px 12px;\n    margin: 0;\n    list-style: none;\n    flex-wrap: nowrap;\n\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n    -ms-overflow-style: none;\n    scrollbar-width: none;\n\n    > li {\n        display: flex;\n        flex: 1;\n        min-width: 78px;\n        height: fit-content;\n    }\n\n    > li > button {\n        width: 100%;\n    }\n`;\nconst WalletItemStyled = styled.button`\n    position: relative;\n    cursor: pointer;\n    border: none;\n    background-color: unset;\n    padding: 8px 4px;\n    min-width: 78px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst ImageStyled$1 = styled(WalletImage)`\n    width: 60px;\n    height: 60px;\n    border-radius: ${(props) => borders$4[props.theme.borderRadius]};\n    margin-bottom: 8px;\n    position: relative;\n`;\nconst BadgeStyled = styled(Image)`\n    position: absolute;\n    right: -6px;\n    bottom: -6px;\n    width: 24px;\n    height: 24px;\n    border-radius: ${(props) => badgeBorders[props.theme.borderRadius]};\n    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);\n`;\nconst StyledText = styled(Text)`\n    max-width: 90px;\n    font-weight: 510;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nconst StyledSecondLine = styled(Text)`\n    font-weight: ${(props) => props.colorPrimary ? \"510\" : \"400\"};\n    max-width: 90px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    color: ${(props) => props.colorPrimary ? props.theme.colors.text.primary : props.theme.colors.text.secondary};\n\n    ${media(\"mobile\")} {\n        max-width: 80px;\n    }\n`;\nvar _tmpl$$r = /* @__PURE__ */ template$1(`<div>`);\nconst WalletItem = (props) => {\n  let ctxRef = null;\n  const adjustLetterSpacing = () => {\n    const name = ctxRef == null ? void 0 : ctxRef.querySelector(\"div\");\n    if (name && name.scrollWidth > name.clientWidth) {\n      let spacing = 0;\n      const minSpacing = -0.4;\n      const step = 0.05;\n      while (name.scrollWidth > name.clientWidth && spacing >= minSpacing) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n      if (spacing !== 0) {\n        spacing -= step;\n        name.style.letterSpacing = `${spacing}px`;\n      }\n    }\n  };\n  onMount(() => adjustLetterSpacing());\n  createEffect(() => {\n    adjustLetterSpacing();\n  });\n  return createComponent(WalletItemStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-wallet-item\": \"true\",\n    get children() {\n      return [memo(() => memo(() => typeof props.icon === \"string\")() ? createComponent(ImageStyled$1, {\n        get src() {\n          return props.icon;\n        },\n        get badge() {\n          return memo(() => !!props.badgeUrl)() && createComponent(BadgeStyled, {\n            get src() {\n              return props.badgeUrl;\n            }\n          });\n        }\n      }) : props.icon), (() => {\n        var _el$ = _tmpl$$r();\n        use((el) => ctxRef = el, _el$);\n        insert(_el$, createComponent(StyledText, {\n          get children() {\n            return props.name;\n          }\n        }));\n        return _el$;\n      })(), memo(() => memo(() => !!props.secondLine)() && createComponent(StyledSecondLine, {\n        get colorPrimary() {\n          var _a2;\n          return (_a2 = props.secondLineColorPrimary) != null ? _a2 : true;\n        },\n        get children() {\n          return props.secondLine;\n        }\n      }))];\n    }\n  });\n};\nconst H1Styled$b = styled.h1`\n    font-style: normal;\n    font-weight: 590;\n    font-size: 20px;\n    line-height: 28px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H1 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H1Styled$b, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h1\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H2Styled$5 = styled.h2`\n    font-style: normal;\n    font-weight: 400;\n    font-size: 16px;\n    line-height: 22px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n\n    margin-top: 0;\n    margin-bottom: 32px;\n\n    cursor: default;\n`;\nconst H2 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H2Styled$5, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h2\": \"true\",\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nconst H3Styled$2 = styled.h3`\n    font-style: normal;\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H3 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H3Styled$2, {\n    \"data-tc-h3\": \"true\",\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      var _a2;\n      return memo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString()) : props.children;\n    }\n  });\n};\nvar _tmpl$$q = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z\">`);\nconst TonIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$q(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$p = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><g clip-path=url(#clip0_3783_2045)><circle cx=8 cy=8.00098 r=8></circle><path d=\"M4.75 8.50098L7 10.751L11.75 6.00098\"stroke-width=1.5 stroke-linecap=round stroke-linejoin=round></path></g><defs><clipPath id=clip0_3783_2045><rect width=16 height=16 fill=white transform=\"translate(0 0.000976562)\">`), _tmpl$2$4 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z\">`), _tmpl$3$2 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z\">`);\nconst SuccessIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.success;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$p(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$4, \"stroke\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$5 = _tmpl$2$4(), _el$6 = _el$5.firstChild, _el$7 = _el$6.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$6, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$7, \"fill\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$5;\n  })() : (() => {\n    var _el$8 = _tmpl$3$2(), _el$9 = _el$8.firstChild, _el$0 = _el$9.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$8, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$9, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$0, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$8;\n  })());\n};\nvar _tmpl$$o = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=36 cy=36 r=33></circle><path d=\"M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z\">`), _tmpl$2$3 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><circle cx=24 cy=24.001 r=22></circle><path d=\"M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501\"stroke-width=3 stroke-linecap=round stroke-linejoin=round>`), _tmpl$3$1 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><circle cx=12 cy=12 r=11></circle><path d=\"M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z\">`);\nconst ErrorIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"m\";\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"m\")() ? (() => {\n    var _el$ = _tmpl$$o(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$3, \"fill\", _p$.a = _v$3);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$4 = _tmpl$2$3(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n      _v$4 !== _p$.e && setAttribute(_el$4, \"class\", _p$.e = _v$4);\n      _v$5 !== _p$.t && setAttribute(_el$5, \"fill\", _p$.t = _v$5);\n      _v$6 !== _p$.a && setAttribute(_el$6, \"stroke\", _p$.a = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$4;\n  })() : (() => {\n    var _el$7 = _tmpl$3$1(), _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$7 = props.class, _v$8 = fill(), _v$9 = theme.colors.constant.white;\n      _v$7 !== _p$.e && setAttribute(_el$7, \"class\", _p$.e = _v$7);\n      _v$8 !== _p$.t && setAttribute(_el$8, \"fill\", _p$.t = _v$8);\n      _v$9 !== _p$.a && setAttribute(_el$9, \"fill\", _p$.a = _v$9);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    });\n    return _el$7;\n  })());\n};\nvar _tmpl$$n = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z\">`), _tmpl$2$2 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=44 height=44 viewBox=\"0 0 44 44\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z\">`), _tmpl$3 = /* @__PURE__ */ template$1(`<svg width=72 height=72 viewBox=\"0 0 72 72\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999\"stroke-width=4 stroke-linecap=round stroke-linejoin=round>`);\nconst LoaderIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"xs\";\n  const fill = () => props.fill || theme.colors.icon.tertiary;\n  const rotateAnimation = h`\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n    `;\n  const svgClass = u`\n        animation: ${rotateAnimation} 1s linear infinite;\n    `;\n  return memo(() => memo(() => size() === \"xs\")() ? (() => {\n    var _el$ = _tmpl$$n(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = cn(svgClass, props.class), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"s\")() ? (() => {\n    var _el$3 = _tmpl$2$2(), _el$4 = _el$3.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$3 = cn(svgClass, props.class), _v$4 = fill();\n      _v$3 !== _p$.e && setAttribute(_el$3, \"class\", _p$.e = _v$3);\n      _v$4 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$3;\n  })() : (() => {\n    var _el$5 = _tmpl$3(), _el$6 = _el$5.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$5 = cn(svgClass, props.class), _v$6 = fill();\n      _v$5 !== _p$.e && setAttribute(_el$5, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$6, \"stroke\", _p$.t = _v$6);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$5;\n  })());\n};\nvar _tmpl$$m = /* @__PURE__ */ template$1(`<svg width=158 height=28 viewBox=\"0 0 158 28\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z\"fill=#0098EA></path><path d=\"M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z\"fill=white></path><path fill-rule=evenodd clip-rule=evenodd d=\"M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z\">`);\nconst TonConnectBrand = () => {\n  const theme = useTheme();\n  const fill = () => theme.theme === THEME.DARK ? theme.colors.constant.white : theme.colors.constant.black;\n  return (() => {\n    var _el$ = _tmpl$$m(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.nextSibling;\n    createRenderEffect(() => setAttribute(_el$4, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$l = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z\">`);\nconst QuestionIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$l(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$k = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z\">`);\nconst BrowserIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$k(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$j = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z\">`);\nconst MobileIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$j(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$i = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z\">`);\nconst DesktopIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$i(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$h = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1603)><path fill-rule=evenodd clip-rule=evenodd d=\"M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z\"></path></g><defs><clipPath id=clip0_3676_1603><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000488281)\">`);\nconst RetryIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$h(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$g = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z\">`);\nconst LinkIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$g(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$f = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=17 height=16 viewBox=\"0 0 17 16\"fill=none><g clip-path=url(#clip0_3676_1274)><path fill-rule=evenodd clip-rule=evenodd d=\"M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z\"></path></g><defs><clipPath id=clip0_3676_1274><rect width=16 height=16 fill=white transform=\"translate(0.5 0.000976562)\">`);\nconst WalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.accent;\n  return (() => {\n    var _el$ = _tmpl$$f(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;\n    createRenderEffect(() => setAttribute(_el$3, \"fill\", fill()));\n    return _el$;\n  })();\n};\nvar _tmpl$$e = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z\">`);\nconst SecurityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$e(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$d = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z\">`);\nconst PersonalityIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$d(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$c = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=48 height=48 viewBox=\"0 0 48 48\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z\">`);\nconst SwapIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$c(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$b = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z\">`);\nconst AtWalletIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.constant.white;\n  return (() => {\n    var _el$ = _tmpl$$b(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$a = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"><path fill-rule=evenodd clip-rule=evenodd d=\"M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z\">`);\nconst CopyLightIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$a(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$9 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=16 height=17 viewBox=\"0 0 16 17\"fill=none><path fill-rule=evenodd clip-rule=evenodd d=\"M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z\">`);\nconst QRIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    var _el$ = _tmpl$$9(), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst containerBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst walletBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst FourWalletsCard = styled.div`\n    width: 60px;\n    height: 60px;\n    padding: 8px;\n    margin-bottom: 8px;\n    border-radius: ${(props) => containerBorders[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.tint};\n    display: grid;\n    grid-template: 1fr 1fr / 1fr 1fr;\n    gap: 4px;\n`;\nconst FourWalletsImage = styled(WalletImage)`\n    width: 20px;\n    height: 20px;\n    border-radius: ${(props) => walletBorders[props.theme.borderRadius]};\n`;\nconst FourWalletsItem = (props) => {\n  return createComponent(WalletItem, {\n    get name() {\n      return props.labelLine1;\n    },\n    get secondLine() {\n      return props.labelLine2;\n    },\n    get icon() {\n      return createComponent(FourWalletsCard, {\n        get children() {\n          return createComponent(For, {\n            each: [0, 1, 2, 3],\n            children: (index) => createComponent(FourWalletsImage, {\n              get src() {\n                return props.images[index];\n              }\n            })\n          });\n        }\n      });\n    },\n    onClick: () => props.onClick()\n  });\n};\nconst AT_WALLET_APP_NAME = \"telegram-wallet\";\nconst IMG = {\n  TON: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png\",\n  TG: \"https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png\"\n};\nconst WalletLabeledItem = (props) => {\n  const [t2] = useI18n();\n  const walletsSecondLine = () => {\n    if (props.wallet.appName === AT_WALLET_APP_NAME) {\n      return void 0;\n    }\n    if (\"isPreferred\" in props.wallet && props.wallet.isPreferred) {\n      return t2(\"walletItem.recent\", {}, \"Recent\");\n    }\n    if (isWalletInfoCurrentlyInjected(props.wallet)) {\n      return t2(\"walletItem.installed\", {}, \"Installed\");\n    }\n    if (props.wallet.name === \"Tonkeeper\") {\n      return t2(\"walletItem.popular\", {}, \"Popular\");\n    }\n    return void 0;\n  };\n  return memo(() => memo(() => props.wallet.appName === AT_WALLET_APP_NAME)() ? createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return t2(\"walletItem.walletOn\", {}, \"Wallet in\");\n    },\n    secondLine: \"Telegram\",\n    get badgeUrl() {\n      return IMG.TG;\n    },\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }) : createComponent(WalletItem, {\n    get icon() {\n      return props.wallet.imageUrl;\n    },\n    get name() {\n      return props.wallet.name;\n    },\n    get secondLine() {\n      return walletsSecondLine();\n    },\n    secondLineColorPrimary: false,\n    onClick: () => props.onClick(),\n    get [\"class\"]() {\n      return props.class;\n    }\n  }));\n};\nconst ScrollContainerStyled = styled.div`\n    width: 100%;\n    overflow-y: auto;\n    max-height: ${(props) => props.maxHeight};\n\n    scrollbar-width: none;\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n\n    &&::-webkit-scrollbar-track {\n        background: transparent;\n    }\n\n    &&::-webkit-scrollbar-thumb {\n        display: none;\n    }\n`;\nconst ScrollDivider = styled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.08;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n        margin: 0;\n    }\n`;\nconst [windowHeight, setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => setWindowHeight(window.innerHeight));\n}\nconst [isMobile, setIsMobile] = createSignal(isDevice(\"mobile\"));\nconst updateIsMobile = () => setIsMobile(isDevice(\"mobile\"));\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => updateIsMobile());\n  window.addEventListener(\"load\", () => updateIsMobile(), { once: true });\n}\nconst ScrollContainer = (props) => {\n  const [scrolled, setScrolled] = createSignal(false);\n  const onScroll = (e2) => {\n    setScrolled(e2.target.scrollTop > 0);\n  };\n  const offset = () => isMobile() ? 150 : 200;\n  const maxHeight = () => props.maxHeight !== void 0 ? `${props.maxHeight}px` : `${windowHeight() - offset()}px`;\n  return [createComponent(ScrollDivider, {\n    get isShown() {\n      return scrolled();\n    }\n  }), createComponent(ScrollContainerStyled, {\n    get maxHeight() {\n      return maxHeight();\n    },\n    onScroll,\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return props.children;\n    }\n  })];\n};\nconst AStyled = styled.a`\n    display: block;\n    text-decoration: unset;\n`;\nconst Link = (props) => {\n  const attributes = () => props.blank ? {\n    rel: \"noreferrer noopener\"\n  } : {};\n  return createComponent(AStyled, mergeProps({\n    get href() {\n      return props.href;\n    },\n    get target() {\n      return props.blank ? \"_blank\" : \"_self\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    }\n  }, attributes, {\n    get children() {\n      return props.children;\n    }\n  }));\n};\nconst TonConnectUiContext = createContext();\nvar _tmpl$$8 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path fill-rule=evenodd clip-rule=evenodd d=\"M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z\">`);\nconst CopyIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$8(), _el$2 = _el$.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = props.class, _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$, \"class\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$2, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nvar _tmpl$$7 = /* @__PURE__ */ template$1(`<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><path d=\"M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z\"></path><path d=\"M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z\">`);\nconst DisconnectIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    var _el$ = _tmpl$$7(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$.e && setAttribute(_el$2, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$3, \"fill\", _p$.t = _v$2);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0\n    });\n    return _el$;\n  })();\n};\nconst hoverBorders$1 = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst dropdownBorders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst AccountButtonDropdownStyled = styled.div`\n    width: 256px;\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => dropdownBorders[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.primary}\n           \n    color: ${(props) => props.theme.colors.text.primary}\n`;\nconst UlStyled = styled.ul`\n    background-color: ${(props) => props.theme.colors.background.primary};\n    padding: 8px;\n`;\nconst MenuButtonStyled = styled.button`\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    height: 40px;\n    padding-left: 8px;\n    width: 100%;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border: none;\n    border-radius: ${(props) => hoverBorders$1[props.theme.borderRadius]};\n    cursor: pointer;\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nvar _tmpl$$6 = /* @__PURE__ */ template$1(`<li>`);\nconst MenuItemText = (props) => createComponent(Text, {\n  get translationKey() {\n    return props.translationKey;\n  },\n  fontSize: \"15px\",\n  fontWeight: \"590\",\n  get children() {\n    return props.children;\n  }\n});\nconst AccountButtonDropdown = (props) => {\n  const tonConnectUi = useContext(TonConnectUiContext);\n  const [isCopiedShown, setIsCopiedShown] = createSignal(false);\n  const onCopy = () => __async(null, null, function* () {\n    const userFriendlyAddress = toUserFriendlyAddress(tonConnectUi.account.address, tonConnectUi.account.chain === CHAIN.TESTNET);\n    yield copyToClipboard(userFriendlyAddress);\n    setIsCopiedShown(true);\n    setTimeout(() => setIsCopiedShown(false), 1e3);\n  });\n  const onDisconnect = () => {\n    tonConnectUi.disconnect();\n    props.onClose();\n  };\n  return createComponent(AccountButtonDropdownStyled, {\n    ref(r$) {\n      var _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-dropdown\": \"true\",\n    get children() {\n      return createComponent(UlStyled, {\n        get children() {\n          return [(() => {\n            var _el$ = _tmpl$$6();\n            insert(_el$, createComponent(MenuButtonStyled, {\n              onClick: () => onCopy(),\n              get children() {\n                return [createComponent(CopyIcon, {}), createComponent(Show, {\n                  get when() {\n                    return !isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copy\",\n                      children: \"Copy address\"\n                    });\n                  }\n                }), createComponent(Show, {\n                  get when() {\n                    return isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copied\",\n                      children: \"Address copied!\"\n                    });\n                  }\n                })];\n              }\n            }));\n            return _el$;\n          })(), (() => {\n            var _el$2 = _tmpl$$6();\n            insert(_el$2, createComponent(MenuButtonStyled, {\n              onClick: () => onDisconnect(),\n              get children() {\n                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {\n                  translationKey: \"button.dropdown.disconnect\",\n                  children: \"Disconnect\"\n                })];\n              }\n            }));\n            return _el$2;\n          })()];\n        }\n      });\n    }\n  });\n};\nconst borders$3 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst NotificationStyled = styled.div`\n    width: 256px;\n    padding: 12px 16px;\n    display: flex;\n    gap: 9px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => borders$3[props.theme.borderRadius]};\n`;\nconst NotificationContentStyled = styled.div`\n    width: 192px;\n\n    > h3 {\n        font-size: 15px;\n    }\n`;\nconst TextStyled$3 = styled(Text)`\n    margin-top: 4px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst Notification = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(NotificationStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(NotificationContentStyled, {\n        get children() {\n          return [createComponent(H3, {\n            get translationKey() {\n              return props.header.translationKey;\n            },\n            get translationValues() {\n              return props.header.translationValues;\n            },\n            get children() {\n              return props.children;\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.text;\n            },\n            get children() {\n              return createComponent(TextStyled$3, {\n                get translationKey() {\n                  return props.text.translationKey;\n                },\n                get translationValues() {\n                  return props.text.translationValues;\n                }\n              });\n            }\n          })];\n        }\n      }), memo(() => props.icon)];\n    }\n  }));\n};\nconst LoaderIconStyled$2 = styled(LoaderIcon)`\n    align-self: center;\n`;\nconst ConfirmOperationNotification = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(Notification, {\n    get header() {\n      return {\n        translationKey: \"notifications.confirm.header\",\n        translationValues: {\n          name: name()\n        }\n      };\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    get icon() {\n      return createComponent(LoaderIconStyled$2, {});\n    },\n    \"data-tc-notification-confirm\": \"true\",\n    children: \"Confirm operation in your wallet\"\n  });\n};\nconst ErrorIconStyled$4 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionCanceled.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionCanceled.text\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$4, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-cancelled\": \"true\",\n    children: \"Transaction cancelled\"\n  });\n};\nconst SuccessIconStyled = styled(SuccessIcon)`\n    margin-top: 2px;\n`;\nconst SuccessTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionSent.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionSent.text\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-sent\": \"true\",\n    children: \"Transaction sent\"\n  });\n};\nconst NotificationClass = u`\n    transform: translateY(-8px);\n    margin-bottom: 12px;\n`;\nconst defaultConfig = {\n  timeout: 4500\n};\nconst [latestAction, setLatestAction] = createSignal(null);\nfunction useOpenedNotifications(config) {\n  const { timeout } = __spreadValues(__spreadValues({}, defaultConfig), config);\n  const [openedNotifications, setOpenedNotifications] = createSignal([]);\n  const [timeoutIds, setTimeoutIds] = createSignal([]);\n  createEffect(\n    on(action, (action2) => {\n      var _a2, _b2;\n      if (!action2 || !action2.showNotification) {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2.action !== \"confirm-transaction\")\n        );\n        return;\n      }\n      if (latestAction() === action2) {\n        return;\n      }\n      const isConfirmTransactionAction = ((_a2 = latestAction()) == null ? void 0 : _a2.name) === \"confirm-transaction\" && action2.name === \"confirm-transaction\";\n      const isConfirmSignDataAction = ((_b2 = latestAction()) == null ? void 0 : _b2.name) === \"confirm-sign-data\" && action2.name === \"confirm-sign-data\";\n      if (isConfirmTransactionAction || isConfirmSignDataAction) {\n        return;\n      }\n      setLatestAction(action2);\n      setOpenedNotifications(\n        (openedNotifications2) => openedNotifications2.filter(\n          (n2) => n2.action !== \"confirm-transaction\" && n2.action !== \"confirm-sign-data\"\n        )\n      );\n      const notification = { action: action2.name };\n      setOpenedNotifications((openedNotifications2) => [...openedNotifications2, notification]);\n      const timeoutId = setTimeout(() => {\n        setOpenedNotifications(\n          (openedNotifications2) => openedNotifications2.filter((n2) => n2 !== notification)\n        );\n        setTimeoutIds((timeoutIds2) => timeoutIds2.filter((id) => id !== timeoutId));\n      }, timeout);\n      setTimeoutIds((timeoutIds2) => [...timeoutIds2, timeoutId]);\n    })\n  );\n  onCleanup(() => {\n    timeoutIds().forEach((id) => clearTimeout(id));\n  });\n  return openedNotifications;\n}\nconst ErrorIconStyled$3 = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.signDataCanceled.header\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled$3, {\n        size: \"xs\"\n      });\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-sign-data-cancelled\": \"true\",\n    children: \"Sign data canceled\"\n  });\n};\nconst SuccessSignDataNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.dataSigned.header\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-data-signed\": \"true\",\n    children: \"Data signed\"\n  });\n};\nvar _tmpl$$5 = /* @__PURE__ */ template$1(`<div data-tc-list-notifications=true>`);\nconst Notifications = (props) => {\n  const openedNotifications = useOpenedNotifications();\n  return (() => {\n    var _el$ = _tmpl$$5();\n    insert(_el$, createComponent(TransitionGroup, {\n      onBeforeEnter: (el) => {\n        animate(el, [{\n          opacity: 0,\n          transform: \"translateY(0)\"\n        }, {\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }], {\n          duration: 200\n        });\n      },\n      onExit: (el, done) => {\n        const a2 = animate(el, [{\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }, {\n          opacity: 0,\n          transform: \"translateY(-30px)\"\n        }], {\n          duration: 200\n        });\n        a2.finished.then(done);\n      },\n      get children() {\n        return createComponent(For, {\n          get each() {\n            return openedNotifications();\n          },\n          children: (openedNotification) => createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-sent\";\n                },\n                get children() {\n                  return createComponent(SuccessTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"data-signed\";\n                },\n                get children() {\n                  return createComponent(SuccessSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"sign-data-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorSignDataNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"confirm-transaction\" || openedNotification.action === \"confirm-sign-data\";\n                },\n                get children() {\n                  return createComponent(ConfirmOperationNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              })];\n            }\n          })\n        });\n      }\n    }));\n    createRenderEffect(() => className(_el$, props.class));\n    return _el$;\n  })();\n};\nconst AccountButtonStyled = styled(Button)`\n    background-color: ${(props) => props.theme.colors.connectButton.background};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n    padding: 8px 16px 8px 12px;\n\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    height: 40px;\n`;\nconst DropdownButtonStyled = styled(AccountButtonStyled)`\n    padding: 12px 16px;\n    min-width: 148px;\n    justify-content: center;\n    background-color: ${(props) => props.theme.colors.background.primary};\n`;\nconst LoaderButtonStyled$1 = styled(Button)`\n    min-width: 148px;\n    height: 40px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst LoaderIconStyled$1 = styled(LoaderIcon)`\n    height: 18px;\n    width: 18px;\n`;\nconst DropdownContainerStyled = styled.div`\n    width: fit-content;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n`;\nconst DropdownStyled = styled(AccountButtonDropdown)`\n    box-sizing: border-box;\n    overflow: hidden;\n    margin-top: 12px;\n`;\nconst NotificationsStyled = styled(Notifications)`\n    > div:first-child {\n        margin-top: 20px;\n    }\n`;\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v) => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nconst yAxisSides = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = [\"left\", \"right\"];\nconst rlPlacement = [\"right\", \"left\"];\nconst tbPlacement = [\"top\", \"bottom\"];\nconst btPlacement = [\"bottom\", \"top\"];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case \"left\":\n    case \"right\":\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  if (alignment) {\n    list = list.map((side) => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return __spreadValues({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === \"y\";\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nconst computePosition$1 = (reference, floating, config) => __async(null, null, function* () {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);\n  let rects = yield platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i2 = 0; i2 < validMiddleware.length; i2++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i2];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = yield fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {\n      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? yield platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i2 = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n});\nfunction detectOverflow(state, options) {\n  return __async(this, null, function* () {\n    var _await$platform$isEle;\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      x,\n      y,\n      platform: platform2,\n      rects,\n      elements,\n      strategy\n    } = state;\n    const {\n      boundary = \"clippingAncestors\",\n      rootBoundary = \"viewport\",\n      elementContext = \"floating\",\n      altBoundary = false,\n      padding = 0\n    } = evaluate(options, state);\n    const paddingObject = getPaddingObject(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({\n      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n      boundary,\n      rootBoundary,\n      strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n      x,\n      y,\n      width: rects.floating.width,\n      height: rects.floating.height\n    } : rects.reference;\n    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);\n    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    };\n    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n      elements,\n      rect,\n      offsetParent,\n      strategy\n    }) : rect);\n    return {\n      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n  });\n}\nconst flip$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"flip\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        var _middlewareData$arrow, _middlewareData$flip;\n        const {\n          placement,\n          middlewareData,\n          rects,\n          initialPlacement,\n          platform: platform2,\n          elements\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = \"bestFit\",\n          fallbackAxisSideDirection = \"none\",\n          flipAlignment = true\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"fallbackPlacements\",\n          \"fallbackStrategy\",\n          \"fallbackAxisSideDirection\",\n          \"flipAlignment\"\n        ]);\n        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n          return {};\n        }\n        const side = getSide(placement);\n        const initialSideAxis = getSideAxis(initialPlacement);\n        const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);\n        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n        }\n        const placements = [initialPlacement, ...fallbackPlacements];\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const overflows = [];\n        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n        if (checkMainAxis) {\n          overflows.push(overflow[side]);\n        }\n        if (checkCrossAxis) {\n          const sides = getAlignmentSides(placement, rects, rtl);\n          overflows.push(overflow[sides[0]], overflow[sides[1]]);\n        }\n        overflowsData = [...overflowsData, {\n          placement,\n          overflows\n        }];\n        if (!overflows.every((side2) => side2 <= 0)) {\n          var _middlewareData$flip2, _overflowsData$filter;\n          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n          const nextPlacement = placements[nextIndex];\n          if (nextPlacement) {\n            const ignoreCrossAxisOverflow = checkCrossAxis === \"alignment\" ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis\n            // overflows the main axis.\n            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n              return {\n                data: {\n                  index: nextIndex,\n                  overflows: overflowsData\n                },\n                reset: {\n                  placement: nextPlacement\n                }\n              };\n            }\n          }\n          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n          if (!resetPlacement) {\n            switch (fallbackStrategy) {\n              case \"bestFit\": {\n                var _overflowsData$filter2;\n                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === \"y\";\n                  }\n                  return true;\n                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement2) {\n                  resetPlacement = placement2;\n                }\n                break;\n              }\n              case \"initialPlacement\":\n                resetPlacement = initialPlacement;\n                break;\n            }\n          }\n          if (placement !== resetPlacement) {\n            return {\n              reset: {\n                placement: resetPlacement\n              }\n            };\n          }\n        }\n        return {};\n      });\n    }\n  };\n};\nconst shift$1 = function(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: \"shift\",\n    options,\n    fn(state) {\n      return __async(this, null, function* () {\n        const {\n          x,\n          y,\n          placement\n        } = state;\n        const _a3 = evaluate(options, state), {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: (_ref) => {\n              let {\n                x: x2,\n                y: y2\n              } = _ref;\n              return {\n                x: x2,\n                y: y2\n              };\n            }\n          }\n        } = _a3, detectOverflowOptions = __objRest(_a3, [\n          \"mainAxis\",\n          \"crossAxis\",\n          \"limiter\"\n        ]);\n        const coords = {\n          x,\n          y\n        };\n        const overflow = yield detectOverflow(state, detectOverflowOptions);\n        const crossAxis = getSideAxis(getSide(placement));\n        const mainAxis = getOppositeAxis(crossAxis);\n        let mainAxisCoord = coords[mainAxis];\n        let crossAxisCoord = coords[crossAxis];\n        if (checkMainAxis) {\n          const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = mainAxisCoord + overflow[minSide];\n          const max2 = mainAxisCoord - overflow[maxSide];\n          mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n        }\n        if (checkCrossAxis) {\n          const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n          const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n          const min2 = crossAxisCoord + overflow[minSide];\n          const max2 = crossAxisCoord - overflow[maxSide];\n          crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n        }\n        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {\n          [mainAxis]: mainAxisCoord,\n          [crossAxis]: crossAxisCoord\n        }));\n        return __spreadProps(__spreadValues({}, limitedCoords), {\n          data: {\n            x: limitedCoords.x - x,\n            y: limitedCoords.y - y,\n            enabled: {\n              [mainAxis]: checkMainAxis,\n              [crossAxis]: checkCrossAxis\n            }\n          }\n        });\n      });\n    }\n  };\n};\nfunction hasWindow() {\n  return typeof window !== \"undefined\";\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || \"\").toLowerCase();\n  }\n  return \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch (_e2) {\n      return false;\n    }\n  });\n}\nconst transformProperties = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"];\nconst willChangeValues = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"];\nconst containValues = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;\n  return transformProperties.some((value) => css[value] ? css[value] !== \"none\" : false) || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || willChangeValues.some((value) => (css.willChange || \"\").includes(value)) || containValues.some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n  return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst lastTraversableNodeNames = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect)\n  ));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\";\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === \"rtl\") {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\") {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === \"document\") {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === \"fixed\";\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\") {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\nconst getElementRects = function(data) {\n  return __async(this, null, function* () {\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    const floatingDimensions = yield getDimensionsFn(data.floating);\n    return {\n      reference: getRectRelativeToOffsetParent(data.reference, yield getOffsetParentFn(data.floating), data.strategy),\n      floating: {\n        x: 0,\n        y: 0,\n        width: floatingDimensions.width,\n        height: floatingDimensions.height\n      }\n    };\n  });\n};\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === \"rtl\";\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction rectsAreEqual(a2, b) {\n  return a2.x === b.x && a2.y === b.y && a2.width === b.width && a2.height === b.height;\n}\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1e3);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (_e2) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === \"function\",\n    layoutShift = typeof IntersectionObserver === \"function\",\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver((_ref) => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nconst shift = shift$1;\nconst flip = flip$1;\nconst computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = __spreadValues({\n    platform\n  }, options);\n  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {\n    _c: cache\n  });\n  return computePosition$1(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {\n    platform: platformWithCache\n  }));\n};\nfunction C(l2, u2, e2) {\n  let c2 = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.placement) != null ? t2 : \"bottom\";\n  }, d = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.strategy) != null ? t2 : \"absolute\";\n  }, [n2, o2] = createSignal({ x: null, y: null, placement: c2(), strategy: d(), middlewareData: {} }), [x, F] = createSignal();\n  createEffect(() => {\n    let t2 = x();\n    if (t2) throw t2.value;\n  });\n  let s2 = createMemo(() => (l2(), u2(), {}));\n  function m() {\n    let t2 = l2(), r = u2();\n    if (t2 && r) {\n      let a2 = s2();\n      computePosition(t2, r, { middleware: e2 == null ? void 0 : e2.middleware, placement: c2(), strategy: d() }).then((i2) => {\n        a2 === s2() && o2(i2);\n      }, (i2) => {\n        F(i2);\n      });\n    }\n  }\n  return createEffect(() => {\n    let t2 = l2(), r = u2();\n    if (c2(), d(), t2 && r) if (e2 != null && e2.whileElementsMounted) {\n      let a2 = e2.whileElementsMounted(t2, r, m);\n      a2 && onCleanup(a2);\n    } else m();\n  }), { get x() {\n    return n2().x;\n  }, get y() {\n    return n2().y;\n  }, get placement() {\n    return n2().placement;\n  }, get strategy() {\n    return n2().strategy;\n  }, get middlewareData() {\n    return n2().middlewareData;\n  }, update: m };\n}\nvar _tmpl$$4 = /* @__PURE__ */ template$1(`<tc-root data-tc-dropdown-container=true>`, true, false, false);\nconst AccountButton = () => {\n  const theme = useTheme();\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [isOpened, setIsOpened] = createSignal(false);\n  const [account, setAccount] = createSignal(connector.account);\n  const [restoringProcess, setRestoringProcess] = createSignal(!connector.account);\n  let dropDownRef;\n  const [floating, setFloating] = createSignal();\n  const [anchor, setAnchor] = createSignal();\n  const position = C(anchor, floating, {\n    whileElementsMounted: autoUpdate,\n    placement: \"bottom-end\",\n    middleware: [flip(), shift()]\n  });\n  const normalizedAddress = () => {\n    const acc = account();\n    if (acc) {\n      const userFriendlyAddress = toUserFriendlyAddress(acc.address, acc.chain === CHAIN.TESTNET);\n      return userFriendlyAddress.slice(0, 4) + \"\" + userFriendlyAddress.slice(-4);\n    }\n    return \"\";\n  };\n  tonConnectUI.connectionRestored.then(() => setRestoringProcess(false));\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (!wallet) {\n      setIsOpened(false);\n      setAccount(null);\n      setRestoringProcess(false);\n      return;\n    }\n    setAccount(wallet.account);\n    setRestoringProcess(false);\n  });\n  const onClick = (e2) => {\n    if (!account() || !isOpened()) {\n      return;\n    }\n    const clickToButton = anchor().contains(e2.target);\n    const clickToDropdown = dropDownRef.contains(e2.target);\n    if (!clickToButton && !clickToDropdown) {\n      setIsOpened(false);\n    }\n  };\n  onMount(() => {\n    document.body.addEventListener(\"click\", onClick);\n  });\n  onCleanup(() => {\n    document.body.removeEventListener(\"click\", onClick);\n    unsubscribe();\n  });\n  return createComponent(Dynamic, {\n    component: globalStylesTag,\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return restoringProcess();\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled$1, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled$1, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !restoringProcess();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return !account();\n            },\n            get children() {\n              return createComponent(AccountButtonStyled, {\n                onClick: () => tonConnectUI.openModal(),\n                \"data-tc-connect-button\": \"true\",\n                scale: \"s\",\n                get children() {\n                  return [createComponent(TonIcon, {\n                    get fill() {\n                      return theme.colors.connectButton.foreground;\n                    }\n                  }), createComponent(Text, {\n                    translationKey: \"button.connectWallet\",\n                    fontSize: \"15px\",\n                    lineHeight: \"18px\",\n                    fontWeight: \"590\",\n                    get color() {\n                      return theme.colors.connectButton.foreground;\n                    },\n                    children: \"Connect wallet\"\n                  })];\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return account();\n            },\n            get children() {\n              return createComponent(DropdownContainerStyled, {\n                get children() {\n                  return [createComponent(DropdownButtonStyled, {\n                    onClick: () => setIsOpened((v) => !v),\n                    ref: setAnchor,\n                    \"data-tc-dropdown-button\": \"true\",\n                    scale: \"s\",\n                    get children() {\n                      return [createComponent(Text, {\n                        fontSize: \"15px\",\n                        fontWeight: \"590\",\n                        lineHeight: \"18px\",\n                        get children() {\n                          return normalizedAddress();\n                        }\n                      }), createComponent(ArrowIcon, {\n                        direction: \"bottom\"\n                      })];\n                    }\n                  }), createComponent(Portal, {\n                    get children() {\n                      var _el$ = _tmpl$$4();\n                      use(setFloating, _el$);\n                      _el$.style.setProperty(\"z-index\", \"999\");\n                      _el$._$owner = getOwner();\n                      insert(_el$, createComponent(Transition, {\n                        onBeforeEnter: (el) => {\n                          animate(el, [{\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }, {\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }], {\n                            duration: 150\n                          });\n                        },\n                        onExit: (el, done) => {\n                          const a2 = animate(el, [{\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }, {\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }], {\n                            duration: 150\n                          });\n                          a2.finished.then(done);\n                        },\n                        get children() {\n                          return createComponent(Show, {\n                            get when() {\n                              return isOpened();\n                            },\n                            get children() {\n                              return createComponent(DropdownStyled, {\n                                get hidden() {\n                                  return !isOpened();\n                                },\n                                onClose: () => setIsOpened(false),\n                                ref(r$) {\n                                  var _ref$ = dropDownRef;\n                                  typeof _ref$ === \"function\" ? _ref$(r$) : dropDownRef = r$;\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), null);\n                      insert(_el$, createComponent(NotificationsStyled, {}), null);\n                      createRenderEffect((_p$) => {\n                        var _a2, _b2;\n                        var _v$ = position.strategy, _v$2 = `${(_a2 = position.y) != null ? _a2 : 0}px`, _v$3 = `${(_b2 = position.x) != null ? _b2 : 0}px`;\n                        _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$.style.setProperty(\"position\", _v$) : _el$.style.removeProperty(\"position\"));\n                        _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty(\"top\", _v$2) : _el$.style.removeProperty(\"top\"));\n                        _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$.style.setProperty(\"left\", _v$3) : _el$.style.removeProperty(\"left\"));\n                        return _p$;\n                      }, {\n                        e: void 0,\n                        t: void 0,\n                        a: void 0\n                      });\n                      return _el$;\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst StyledModal = styled(Modal)`\n    padding-left: 24px;\n    padding-right: 24px;\n    padding-top: 18px;\n    padding-bottom: 0;\n\n    ${media(\"mobile\")} {\n        padding-left: 0;\n        padding-right: 0;\n    }\n`;\nconst H1Styled$a = styled(H1)`\n    margin-top: 12px;\n\n    ${media(\"mobile\")} {\n        padding: 0 10px;\n    }\n`;\nconst LoaderContainerStyled = styled.div`\n    margin: 30px 0;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n\n    ${media(\"mobile\")} {\n        height: 160px;\n        align-items: center;\n    }\n`;\nstyled(Text)`\n    min-width: 84px;\n    text-align: center;\n    font-weight: 590;\n`;\nstyled(TabBar)`\n    margin: 0 auto 22px;\n`;\nconst [appState, setAppState] = createStore({\n  buttonRootId: null,\n  language: \"en\",\n  returnStrategy: \"back\",\n  twaReturnUrl: void 0,\n  walletsListConfiguration: {},\n  enableAndroidBackHandler: true\n});\nfunction uniq(array) {\n  return [...new Set(array)];\n}\nfunction mergeConcat(idKey, array1, array2) {\n  return array1.map((item1) => {\n    const item2 = array2.find((elem) => elem[idKey] === item1[idKey]);\n    array2 = array2.filter((elem) => elem[idKey] !== item1[idKey]);\n    return item2 === void 0 ? item1 : item2;\n  }).concat(array2);\n}\nfunction uiWalletToWalletInfo(uiWallet) {\n  if (\"jsBridgeKey\" in uiWallet) {\n    return __spreadProps(__spreadValues({}, uiWallet), {\n      injected: TonConnect.isWalletInjected(uiWallet.jsBridgeKey),\n      embedded: TonConnect.isInsideWalletBrowser(uiWallet.jsBridgeKey)\n    });\n  }\n  return uiWallet;\n}\nfunction applyWalletsListConfiguration(walletsList, configuration) {\n  var _a2;\n  if (!configuration) {\n    return walletsList;\n  }\n  if ((_a2 = configuration.includeWallets) == null ? void 0 : _a2.length) {\n    walletsList = mergeConcat(\n      \"name\",\n      walletsList,\n      configuration.includeWallets.map(uiWalletToWalletInfo)\n    );\n  }\n  return walletsList;\n}\nfunction supportsDesktop(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"macos\", \"linux\", \"windows\"].includes(w));\n}\nfunction supportsMobile(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"ios\", \"android\"].includes(w));\n}\nfunction supportsExtension(walletInfo) {\n  return walletInfo.platforms.some((w) => [\"chrome\", \"firefox\", \"safari\"].includes(w));\n}\nfunction eqWalletName(wallet1, name) {\n  if (!name) {\n    return false;\n  }\n  return wallet1.name.toLowerCase() === name.toLowerCase() || wallet1.appName.toLowerCase() === name.toLowerCase();\n}\nconst DesktopSelectWalletModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst H1Styled$9 = styled(H1)`\n    margin-bottom: 18px;\n`;\nstyled.div`\n    height: 1px;\n    margin: 0 -24px;\n    width: calc(100% + 48px);\n    opacity: 0.12;\n    background: ${(props) => props.isShown ? props.theme.colors.icon.secondary : \"transparent\"};\n    transition: background 0.15s ease-in-out;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst WalletsUl = styled.ul`\n    display: grid;\n    grid-template-columns: repeat(auto-fit, 92px);\n    grid-template-rows: auto;\n    align-content: flex-start;\n    row-gap: 8px;\n    width: 100%;\n    padding: 0 0 16px;\n    align-self: flex-start;\n    max-width: 400px;\n    margin: 0 auto;\n    list-style: none;\n\n    > li {\n        display: block;\n        height: fit-content;\n    }\n\n    ${media(\"mobile\")} {\n        display: grid;\n        grid-template-columns: repeat(4, 1fr);\n        gap: 0;\n        padding: 8px 12px 16px;\n        max-width: none;\n\n        > li {\n            min-width: 78px;\n            display: flex;\n        }\n\n        > li > * {\n            width: 100%;\n        }\n    }\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto 1px;\n    font-size: 15px;\n`;\nconst StyledIconButton$5 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst WalletLabeledItemStyled = styled(WalletLabeledItem)`\n    opacity: ${(props) => props.withOpacity ? \"0.4\" : \"1\"};\n`;\nconst WalletsNotSupportedNotifier = styled.div`\n    display: grid;\n    grid-template-columns: auto 28px;\n    gap: 16px;\n    padding: 16px;\n    margin-bottom: 16px;\n    border-radius: 16px;\n    color: ${(props) => props.theme.colors.text.secondary};\n    background: ${(props) => props.theme.colors.background.tint};\n\n    ${media(\"mobile\")} {\n        margin-left: 16px;\n        margin-right: 16px;\n    }\n`;\nconst WalletsNotSupportedNotifierText = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: left;\n    margin: 0;\n`;\nconst ErrorBoxStyled = styled.div`\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n    transform: translate(-50%, 0);\n\n    text-wrap: nowrap;\n    display: flex;\n    gap: 6px;\n    align-items: center;\n    border-radius: 18px;\n    min-width: 126px;\n    padding: 9px 16px 9px 10px;\n\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    background-color: ${(props) => props.theme.colors.background.segment};\n`;\nvar _tmpl$$3 = /* @__PURE__ */ template$1(`<svg width=16 height=16 viewBox=\"0 0 16 16\"fill=none xmlns=http://www.w3.org/2000/svg><g clip-path=url(#clip0_5122_10355)><circle cx=8 cy=8 r=8></circle><circle cx=8 cy=11 r=1></circle><path d=\"M7.04994 4.99875C7.02277 4.45542 7.45598 4 8 4C8.54402 4 8.97723 4.45541 8.95006 4.99875L8.78745 8.25094C8.76647 8.67055 8.42014 9 8 9C7.57986 9 7.23353 8.67055 7.21255 8.25094L7.04994 4.99875Z\"></path></g><defs><clipPath id=clip0_5122_10355><rect width=16 height=16>`), _tmpl$2$1 = /* @__PURE__ */ template$1(`<svg xmlns=http://www.w3.org/2000/svg width=28 height=28 viewBox=\"0 0 28 28\"fill=none><circle cx=14 cy=14 r=12></circle><circle cx=14 cy=18.9 r=1.4></circle><path d=\"M12.6658 8.89845C12.63 8.13698 13.2377 7.5 14 7.5C14.7623 7.5 15.37 8.13698 15.3342 8.89845L15.047 15.0013C15.0207 15.5604 14.5597 16.0002 14 16.0002C13.4403 16.0002 12.9793 15.5604 12.953 15.0013L12.6658 8.89845Z\">`);\nconst ExclamationIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size;\n  const fill = () => props.fill || theme.colors.icon.error;\n  return memo(() => memo(() => size() === \"16\")() ? (() => {\n    var _el$ = _tmpl$$3(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling, _el$6 = _el$2.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild;\n    createRenderEffect((_p$) => {\n      var _v$ = fill(), _v$2 = theme.colors.constant.white, _v$3 = theme.colors.constant.white, _v$4 = theme.colors.constant.white;\n      _v$ !== _p$.e && setAttribute(_el$3, \"fill\", _p$.e = _v$);\n      _v$2 !== _p$.t && setAttribute(_el$4, \"fill\", _p$.t = _v$2);\n      _v$3 !== _p$.a && setAttribute(_el$5, \"fill\", _p$.a = _v$3);\n      _v$4 !== _p$.o && setAttribute(_el$8, \"fill\", _p$.o = _v$4);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$;\n  })() : memo(() => size() === \"28\")() ? (() => {\n    var _el$9 = _tmpl$2$1(), _el$0 = _el$9.firstChild, _el$1 = _el$0.nextSibling, _el$10 = _el$1.nextSibling;\n    createRenderEffect((_p$) => {\n      var _v$5 = props.class, _v$6 = fill(), _v$7 = theme.colors.constant.white, _v$8 = theme.colors.constant.white;\n      _v$5 !== _p$.e && setAttribute(_el$9, \"class\", _p$.e = _v$5);\n      _v$6 !== _p$.t && setAttribute(_el$0, \"fill\", _p$.t = _v$6);\n      _v$7 !== _p$.a && setAttribute(_el$1, \"fill\", _p$.a = _v$7);\n      _v$8 !== _p$.o && setAttribute(_el$10, \"fill\", _p$.o = _v$8);\n      return _p$;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    });\n    return _el$9;\n  })() : null);\n};\nvar _tmpl$$2 = /* @__PURE__ */ template$1(`<li>`);\nconst AllWalletsListModal = (props) => {\n  const maxHeight = () => isMobile() ? void 0 : 510;\n  const [errorSupportOpened, setErrorSupportOpened] = createSignal(null);\n  let timeoutId = null;\n  const onErrorClick = (wallet) => {\n    setErrorSupportOpened(wallet);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setErrorSupportOpened(null), 1500);\n  };\n  const handleSelectWallet = (wallet) => {\n    if (!wallet.isSupportRequiredFeatures && props.featureCheckMode === \"strict\") {\n      onErrorClick(wallet);\n      return;\n    }\n    props.onSelect(wallet);\n  };\n  const walletsList = () => isMobile() ? props.walletsList.filter(supportsMobile) : props.walletsList;\n  const supportedWallets = () => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures);\n  const unsupportedWallets = () => walletsList().filter((wallet) => !wallet.isSupportRequiredFeatures);\n  return createComponent(DesktopSelectWalletModalStyled, {\n    \"data-tc-wallets-modal-list\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$5, {\n        icon: \"arrow\",\n        onClick: () => props.onBack()\n      }), createComponent(H1Styled$9, {\n        translationKey: \"walletModal.wallets\",\n        children: \"Wallets\"\n      }), createComponent(ScrollContainer, {\n        get maxHeight() {\n          return maxHeight();\n        },\n        get children() {\n          return [createComponent(WalletsUl, {\n            get children() {\n              return createComponent(For, {\n                get each() {\n                  return supportedWallets();\n                },\n                children: (wallet) => (() => {\n                  var _el$ = _tmpl$$2();\n                  insert(_el$, createComponent(WalletLabeledItemStyled, {\n                    wallet,\n                    onClick: () => props.onSelect(wallet)\n                  }));\n                  return _el$;\n                })()\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return unsupportedWallets().length > 0 && props.featureCheckMode !== \"hide\";\n            },\n            get children() {\n              return [createComponent(WalletsNotSupportedNotifier, {\n                get children() {\n                  return [createComponent(WalletsNotSupportedNotifierText, {\n                    translationKey: \"walletModal.allWallets.walletsBelowNotSupported\",\n                    children: \"The wallets below dont support all features of the connected service. You can use your recovery phrase in one of the supported wallets above.\"\n                  }), createComponent(ExclamationIcon, {\n                    size: \"28\"\n                  })];\n                }\n              }), createComponent(WalletsUl, {\n                get children() {\n                  return createComponent(For, {\n                    get each() {\n                      return unsupportedWallets();\n                    },\n                    children: (wallet) => (() => {\n                      var _el$2 = _tmpl$$2();\n                      insert(_el$2, createComponent(WalletLabeledItemStyled, {\n                        wallet,\n                        onClick: () => handleSelectWallet(wallet),\n                        get withOpacity() {\n                          return props.featureCheckMode === \"strict\";\n                        }\n                      }));\n                      return _el$2;\n                    })()\n                  });\n                }\n              }), createComponent(Transition, {\n                onBeforeEnter: (el) => {\n                  animate(el, [{\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }, {\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  });\n                },\n                onExit: (el, done) => {\n                  animate(el, [{\n                    opacity: 1,\n                    transform: \"translate(-50%, 0)\"\n                  }, {\n                    opacity: 0,\n                    transform: \"translate(-50%, 44px)\"\n                  }], {\n                    duration: 150,\n                    easing: \"ease-out\"\n                  }).finished.then(() => {\n                    done();\n                  });\n                },\n                get children() {\n                  return createComponent(Show, {\n                    get when() {\n                      return errorSupportOpened();\n                    },\n                    get children() {\n                      return createComponent(ErrorBoxStyled, {\n                        get children() {\n                          return [createComponent(ErrorIcon, {\n                            size: \"xs\"\n                          }), createComponent(Text, {\n                            translationKey: \"walletModal.allWallets.walletNotSupportService\",\n                            get translationValues() {\n                              return {\n                                name: errorSupportOpened().name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => errorSupportOpened().name), \" doesnt support connected service\"];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst tgButtonBorders = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgIconBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nconst DesktopConnectionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n`;\nconst BodyStyled$1 = styled.div`\n    flex: 1;\n    margin-top: ${(props) => props.qr ? \"0\" : \"18px\"};\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst QRCodeStyled$1 = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst H1Styled$8 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 2px;\n`;\nconst H2Styled$4 = styled(H2)`\n    max-width: 288px;\n    text-align: center;\n    margin: 0 auto 20px;\n`;\nconst StyledIconButton$4 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst ButtonsContainerStyled$2 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst BottomButtonsContainerStyled = styled(ButtonsContainerStyled$2)`\n    padding-bottom: 0;\n`;\nconst FooterButton$1 = styled(Button)`\n    margin-bottom: 24px;\n`;\nconst LoaderStyled$1 = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$2 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$2 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst TgButtonStyled = styled(Button)`\n    margin-top: -8px;\n    margin-bottom: 24px;\n    width: 100%;\n    padding: 12px 12px 12px 20px;\n    border-radius: ${(props) => tgButtonBorders[props.theme.borderRadius]};\n    font-size: 16px;\n    line-height: 20px;\n`;\nconst TgImageStyled = styled(Image)`\n    width: 32px;\n    height: 32px;\n    border-radius: ${(props) => tgIconBorders[props.theme.borderRadius]};\n`;\nconst Translation = (props) => {\n  const [t2] = useI18n();\n  return memo(() => {\n    var _a2;\n    return t2(props.translationKey, props.translationValues, (_a2 = props.children) == null ? void 0 : _a2.toString());\n  });\n};\nfunction addReturnStrategy(url, strategy) {\n  let returnStrategy;\n  if (typeof strategy === \"string\") {\n    returnStrategy = strategy;\n  } else {\n    returnStrategy = isInTMA() ? strategy.twaReturnUrl || strategy.returnStrategy : \"none\";\n  }\n  const newUrl = addQueryParameter(url, \"ret\", returnStrategy);\n  if (!isTelegramUrl(url)) {\n    return newUrl;\n  }\n  const lastParam = newUrl.slice(newUrl.lastIndexOf(\"&\") + 1);\n  return newUrl.slice(0, newUrl.lastIndexOf(\"&\")) + \"-\" + encodeTelegramUrlParameters(lastParam);\n}\nfunction redirectToTelegram(universalLink, options) {\n  options = __spreadValues({}, options);\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  if (!directLinkUrl.searchParams.has(\"startapp\")) {\n    directLinkUrl.searchParams.append(\"startapp\", \"tonconnect\");\n  }\n  if (isInTelegramBrowser()) {\n    options.returnStrategy = \"back\";\n    const linkWithStrategy = addReturnStrategy(\n      directLinkUrl.toString(),\n      options.returnStrategy\n    );\n    openLinkBlank(linkWithStrategy);\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\", \"macos\", \"tdesktop\", \"web\")) {\n      options.returnStrategy = \"back\";\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      sendOpenTelegramLink(linkWithStrategy);\n    } else if (isTmaPlatform(\"weba\")) {\n      sendOpenTelegramLink(addReturnStrategy(directLinkUrl.toString(), options));\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"android\")) {\n      options.returnStrategy = \"back\";\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      if (useDeepLink) {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        const linkWithStrategy = addReturnStrategy(\n          directLinkUrl.toString(),\n          options.returnStrategy\n        );\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"back\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const isChrome = isBrowser(\"chrome\");\n      const isFirefox = isBrowser(\"firefox\");\n      const useDeepLink = (isChrome || isFirefox) && !options.forceRedirect;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (useDeepLink) {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      } else {\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      options.returnStrategy = \"back\";\n      options.twaReturnUrl = void 0;\n      const linkWithStrategy = addReturnStrategy(\n        directLinkUrl.toString(),\n        options.returnStrategy\n      );\n      if (options.forceRedirect) {\n        openLinkBlank(linkWithStrategy);\n      } else {\n        const deepLink = convertToTGDeepLink(linkWithStrategy);\n        openDeeplinkWithFallback(deepLink, () => openLinkBlank(linkWithStrategy));\n      }\n    } else {\n      openLinkBlank(addReturnStrategy(directLinkUrl.toString(), options));\n    }\n  }\n}\nfunction redirectToWallet(universalLink, deepLink, options, setOpenMethod) {\n  options = __spreadValues({}, options);\n  if (isInTelegramBrowser()) {\n    if (isOS(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else if (isInTMA()) {\n    if (isTmaPlatform(\"ios\", \"android\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      sendOpenTelegramLink(linkWithStrategy, () => {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      });\n    } else if (isTmaPlatform(\"macos\", \"tdesktop\")) {\n      if (options.returnStrategy === \"back\") {\n        options.returnStrategy = \"tg://resolve\";\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"weba\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else if (isTmaPlatform(\"web\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = location.href;\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      openLinkBlank(linkWithStrategy);\n    }\n  } else {\n    if (isOS(\"ios\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"android\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    } else if (isOS(\"ipad\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = location.href;\n        }\n      }\n      if (isBrowser(\"chrome\")) {\n        setOpenMethod(\"universal-link\");\n        openLink(addReturnStrategy(universalLink, options.returnStrategy), \"_self\");\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n      }\n    } else if (isOS(\"macos\", \"windows\", \"linux\")) {\n      if (options.returnStrategy === \"back\") {\n        if (isBrowser(\"safari\")) {\n          options.returnStrategy = \"none\";\n        } else if (isBrowser(\"chrome\")) {\n          options.returnStrategy = \"googlechrome://\";\n        } else if (isBrowser(\"firefox\")) {\n          options.returnStrategy = \"firefox://\";\n        } else if (isBrowser(\"opera\")) {\n          options.returnStrategy = \"opera-http://\";\n        } else {\n          options.returnStrategy = \"none\";\n        }\n      }\n      const linkWithStrategy = addReturnStrategy(universalLink, options.returnStrategy);\n      const useDeepLink = !!deepLink && !options.forceRedirect;\n      if (useDeepLink) {\n        setOpenMethod(\"custom-deeplink\");\n        openDeeplinkWithFallback(toDeeplink(linkWithStrategy, deepLink), () => {\n          setOpenMethod(\"universal-link\");\n          openLinkBlank(linkWithStrategy);\n        });\n      } else {\n        setOpenMethod(\"universal-link\");\n        openLinkBlank(linkWithStrategy);\n      }\n    } else {\n      setOpenMethod(\"universal-link\");\n      openLinkBlank(addReturnStrategy(universalLink, options.returnStrategy));\n    }\n  }\n}\nfunction addSessionIdToUniversalLink(universalLink, sessionId) {\n  if (!sessionId) {\n    return universalLink;\n  }\n  if (!isTelegramUrl(universalLink)) {\n    const newUrl2 = addQueryParameter(universalLink, \"id\", sessionId);\n    return newUrl2;\n  }\n  const directLink = convertToTGDirectLink(universalLink);\n  const directLinkUrl = new URL(directLink);\n  if (!directLinkUrl.searchParams.has(\"startapp\")) {\n    directLinkUrl.searchParams.append(\"startapp\", \"tonconnect\");\n  }\n  const newUrl = addQueryParameter(directLinkUrl.toString(), \"id\", sessionId);\n  const lastParam = newUrl.slice(newUrl.lastIndexOf(\"&\") + 1);\n  return newUrl.slice(0, newUrl.lastIndexOf(\"&\")) + \"-v__2-\" + encodeTelegramUrlParameters(lastParam);\n}\nfunction addQueryParameter(url, key, value) {\n  const parsed = new URL(url);\n  parsed.searchParams.append(key, value);\n  return parsed.toString();\n}\nfunction convertToTGDirectLink(universalLink) {\n  const url = new URL(universalLink);\n  if (url.searchParams.has(\"attach\")) {\n    url.searchParams.delete(\"attach\");\n    url.pathname += \"/start\";\n  }\n  return url.toString();\n}\nfunction convertToTGDeepLink(directLink) {\n  const parsed = new URL(directLink);\n  const [, domain, appname] = parsed.pathname.split(\"/\");\n  const startapp = parsed.searchParams.get(\"startapp\");\n  return `tg://resolve?domain=${domain}&appname=${appname}&startapp=${startapp}`;\n}\nconst DesktopConnectionModal = (props) => {\n  const [mode, setMode] = createSignal(\"mobile\");\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const [universalLink, setUniversalLink] = createSignal();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, (error) => {\n    if (error instanceof WalletMissingRequiredFeaturesError) {\n      setConnectionErrored(\"missing-features\");\n      return;\n    }\n    if (props.wallet.appName !== AT_WALLET_APP_NAME) {\n      setConnectionErrored(\"connection-declined\");\n    }\n  });\n  onCleanup(unsubscribe);\n  const generateUniversalLink = () => {\n    try {\n      const universalLink2 = connector.connect({\n        universalLink: props.wallet.universalLink,\n        bridgeUrl: props.wallet.bridgeUrl\n      }, props.additionalRequest);\n      setUniversalLink(universalLink2);\n    } catch (e2) {\n    }\n  };\n  createEffect(() => {\n    if (untrack(mode) !== \"extension\" && (supportsMobile(props.wallet) || supportsDesktop(props.wallet))) {\n      generateUniversalLink();\n    }\n  });\n  const onClickMobile = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"mobile\");\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onClickDesktop = () => {\n    setConnectionErrored(null);\n    if (mode() === \"extension\") {\n      generateUniversalLink();\n    }\n    setMode(\"desktop\");\n    if (isTelegramUrl(universalLink())) {\n      onClickTelegram();\n    } else {\n      const forceRedirect = !firstClick();\n      setFirstClick(false);\n      redirectToWallet(universalLink(), props.wallet.deepLink, {\n        returnStrategy: appState.returnStrategy,\n        forceRedirect\n      }, (method) => {\n        setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n          openMethod: method\n        }));\n      });\n    }\n  };\n  const onClickTelegram = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onClickExtension = () => {\n    setConnectionErrored(null);\n    setMode(\"extension\");\n    if (isWalletInfoCurrentlyInjected(props.wallet)) {\n      setLastSelectedWalletInfo(props.wallet);\n      connector.connect({\n        jsBridgeKey: props.wallet.jsBridgeKey\n      }, props.additionalRequest);\n    }\n  };\n  if (supportsMobile(props.wallet)) {\n    onClickMobile();\n  } else if (supportsExtension(props.wallet)) {\n    onClickExtension();\n  } else {\n    onClickDesktop();\n  }\n  return createComponent(DesktopConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-desktop\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled;\n        },\n        get children() {\n          return createComponent(StyledIconButton$4, {\n            icon: \"arrow\",\n            onClick: () => props.onBackClick()\n          });\n        }\n      }), createComponent(H1Styled$8, {\n        get children() {\n          return props.wallet.name;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return memo(() => mode() === \"mobile\")() && !connectionErrored();\n        },\n        get children() {\n          return createComponent(H2Styled$4, {\n            translationKey: \"walletModal.desktopConnectionModal.scanQR\",\n            get translationValues() {\n              return {\n                name: props.wallet.name\n              };\n            },\n            get children() {\n              return [\"Scan the QR code below with your phones or \", memo(() => props.wallet.name), \"s camera\"];\n            }\n          });\n        }\n      }), createComponent(BodyStyled$1, {\n        get qr() {\n          return mode() === \"mobile\";\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$2, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$2, {\n                            translationKey: \"walletModal.desktopConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesnt support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Show, {\n                        get when() {\n                          return connectionErrored() !== \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            get onClick() {\n                              return mode() === \"extension\" ? onClickExtension : onClickDesktop;\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.updateWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Update \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), createComponent(Show, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(Button, {\n                            onClick: () => props.onBackClick(),\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.chooseAnotherWallet\",\n                                children: \"Choose Another Wallet\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"mobile\";\n                },\n                get children() {\n                  return createComponent(QRCodeStyled$1, {\n                    disableCopy: false,\n                    get sourceUrl() {\n                      return addReturnStrategy(universalLink(), \"none\");\n                    },\n                    get imageUrl() {\n                      return props.wallet.imageUrl;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"extension\";\n                },\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return isWalletInfoCurrentlyInjected(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(LoaderStyled$1, {\n                        size: \"s\"\n                      }), createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.continueInExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Continue in \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Button, {\n                            get leftIcon() {\n                              return createComponent(RetryIcon, {});\n                            },\n                            onClick: onClickExtension,\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"common.retry\",\n                                children: \"Retry\"\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(Show, {\n                    get when() {\n                      return !isWalletInfoCurrentlyInjected(props.wallet);\n                    },\n                    get children() {\n                      return [createComponent(BodyTextStyled$2, {\n                        translationKey: \"walletModal.desktopConnectionModal.dontHaveExtension\",\n                        get translationValues() {\n                          return {\n                            name: props.wallet.name\n                          };\n                        },\n                        get children() {\n                          return [\"Seems you don't have installed \", memo(() => props.wallet.name), \" browser extension\"];\n                        }\n                      }), createComponent(ButtonsContainerStyled$2, {\n                        get children() {\n                          return createComponent(Link, {\n                            get href() {\n                              return props.wallet.aboutUrl;\n                            },\n                            blank: true,\n                            get children() {\n                              return createComponent(Button, {\n                                get rightIcon() {\n                                  return createComponent(LinkIcon, {});\n                                },\n                                onClick: onClickExtension,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                    get translationValues() {\n                                      return {\n                                        name: props.wallet.name\n                                      };\n                                    },\n                                    get children() {\n                                      return [\"Get \", memo(() => props.wallet.name)];\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return mode() === \"desktop\";\n                },\n                get children() {\n                  return [createComponent(LoaderIcon, {\n                    size: \"m\"\n                  }), createComponent(BodyTextStyled$2, {\n                    translationKey: \"walletModal.desktopConnectionModal.continueOnDesktop\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \" on desktop\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$2, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onClickDesktop,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Link, {\n                        get href() {\n                          return props.wallet.aboutUrl;\n                        },\n                        blank: true,\n                        get children() {\n                          return createComponent(Button, {\n                            get rightIcon() {\n                              return createComponent(LinkIcon, {});\n                            },\n                            get children() {\n                              return createComponent(Translation, {\n                                translationKey: \"walletModal.desktopConnectionModal.getWallet\",\n                                get translationValues() {\n                                  return {\n                                    name: props.wallet.name\n                                  };\n                                },\n                                get children() {\n                                  return [\"Get \", memo(() => props.wallet.name)];\n                                }\n                              });\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName === AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(TgButtonStyled, {\n            get rightIcon() {\n              return createComponent(TgImageStyled, {\n                get src() {\n                  return IMG.TG;\n                }\n              });\n            },\n            scale: \"s\",\n            onClick: onClickTelegram,\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"walletModal.desktopConnectionModal.openWalletOnTelegram\",\n                children: \"Open Wallet in Telegram on desktop\"\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.wallet.appName !== AT_WALLET_APP_NAME;\n        },\n        get children() {\n          return createComponent(BottomButtonsContainerStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"mobile\")() && supportsMobile(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(MobileIcon, {});\n                    },\n                    onClick: onClickMobile,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.mobile\",\n                        children: \"Mobile\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"extension\")() && supportsExtension(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(BrowserIcon, {});\n                    },\n                    onClick: onClickExtension,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.browserExtension\",\n                        children: \"Browser Extension\"\n                      });\n                    }\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return memo(() => mode() !== \"desktop\")() && supportsDesktop(props.wallet);\n                },\n                get children() {\n                  return createComponent(FooterButton$1, {\n                    appearance: \"secondary\",\n                    get leftIcon() {\n                      return createComponent(DesktopIcon, {});\n                    },\n                    onClick: onClickDesktop,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.desktop\",\n                        children: \"Desktop\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst InfoModalStyled = styled.div``;\nconst StyledIconButton$3 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$7 = styled(H1)`\n    margin-bottom: 18px;\n`;\nconst InfoBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst InfoBlockIconClass = u`\n    margin-bottom: 12px;\n`;\nconst H3Styled$1 = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$2 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst ButtonsBlock = styled.div`\n    padding: 16px 24px 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n`;\nconst LINKS = {\n  GET_A_WALLET: \"https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1\"\n};\nconst InfoModal = (props) => {\n  return createComponent(InfoModalStyled, {\n    \"data-tc-wallets-modal-info\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton$3, {\n        icon: \"arrow\",\n        onClick: () => props.onBackClick()\n      }), createComponent(H1Styled$7, {\n        translationKey: \"walletModal.infoModal.whatIsAWallet\",\n        children: \"What is a wallet\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SecurityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.secureDigitalAssets\",\n                children: \"Secure digital assets storage\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.walletProtects\",\n                children: \"A wallet protects and manages your digital assets including TON, tokens and collectables.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(PersonalityIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.controlIdentity\",\n                children: \"Control your Web3 identity\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.manageIdentity\",\n                children: \"Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem.\"\n              })];\n            }\n          }), createComponent(InfoBlock, {\n            get children() {\n              return [createComponent(SwapIcon, {\n                \"class\": InfoBlockIconClass\n              }), createComponent(H3Styled$1, {\n                translationKey: \"walletModal.infoModal.effortlessCryptoTransactions\",\n                children: \"Effortless crypto transactions\"\n              }), createComponent(TextStyled$2, {\n                translationKey: \"walletModal.infoModal.easilySend\",\n                children: \"Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications.\"\n              })];\n            }\n          }), createComponent(ButtonsBlock, {\n            get children() {\n              return createComponent(Link, {\n                get href() {\n                  return LINKS.GET_A_WALLET;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get rightIcon() {\n                      return createComponent(WalletIcon, {});\n                    },\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.infoModal.getAWallet\",\n                        children: \"Get a Wallet\"\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst MobileConnectionModalStyled = styled.div``;\nconst BodyStyled = styled.div`\n    flex: 1;\n    margin-top: 18px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    min-height: 232px;\n`;\nconst H1Styled$6 = styled(H1)`\n    max-width: 262px;\n    margin: 0 auto 8px;\n`;\nconst StyledIconButton$2 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst FooterStyled = styled.div`\n    padding: 16px;\n    display: flex;\n    align-items: center;\n    gap: 12px;\n    border-top: 0.5px solid ${(props) => rgba(props.theme.colors.icon.secondary, 0.2)};\n`;\nconst ImageStyled = styled(Image)`\n    width: 36px;\n    height: 36px;\n    border-radius: 10px;\n`;\nconst FooterButton = styled(Link)`\n    margin-left: auto;\n`;\nconst LoaderStyled = styled(LoaderIcon)`\n    margin-bottom: 18px;\n    margin-top: 2px;\n`;\nconst ErrorIconStyled$1 = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nconst BodyTextStyled$1 = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled$1 = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 16px;\n`;\nconst actionButtonBorderRadius$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$5 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$3 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper$1 = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper$1 = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton$1 = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius$1[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileConnectionQR = (props) => {\n  return [createComponent(H1Styled$5, {\n    get children() {\n      return props.walletInfo.name;\n    }\n  }), createComponent(H2Styled$3, {\n    translationKey: \"walletModal.mobileConnectionModal.scanQR\",\n    get translationValues() {\n      return {\n        name: props.walletInfo.name\n      };\n    },\n    get children() {\n      return [\"Scan the QR code below with your phones or \", memo(() => props.walletInfo.name), \"s camera\"];\n    }\n  }), createComponent(QrCodeWrapper$1, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return props.walletInfo.imageUrl;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper$1, {\n    get children() {\n      return [createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onOpenLink) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton$1, {\n        appearance: \"secondary\",\n        onClick: () => {\n          var _a2;\n          return (_a2 = props.onCopy) == null ? void 0 : _a2.call(props);\n        },\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nconst MobileConnectionModal = (props) => {\n  const theme = useTheme();\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [showQR, setShowQR] = createSignal(false);\n  const [connectionErrored, setConnectionErrored] = createSignal(null);\n  createEffect(() => {\n    var _a2;\n    setConnectionErrored((_a2 = props.defaultError) != null ? _a2 : null);\n  });\n  const connector = useContext(ConnectorContext);\n  const unsubscribe = connector.onStatusChange(() => {\n  }, () => {\n    setConnectionErrored(null);\n  });\n  const universalLink = createMemo(() => connector.connect({\n    universalLink: props.wallet.universalLink,\n    bridgeUrl: props.wallet.bridgeUrl\n  }, props.additionalRequest));\n  const onClickTelegram = () => {\n    const alwaysForceRedirect = true;\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n    redirectToTelegram(universalLink(), {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect: alwaysForceRedirect\n    });\n  };\n  const onRetry = () => {\n    const currentUniversalLink = universalLink();\n    if (isTelegramUrl(currentUniversalLink)) {\n      return onClickTelegram();\n    }\n    setConnectionErrored(null);\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(universalLink(), props.wallet.deepLink, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n        openMethod: method\n      }));\n    });\n  };\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(universalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onOpenQR = () => {\n    setConnectionErrored(null);\n    setShowQR(true);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"qrcode\"\n    }));\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n      openMethod: \"universal-link\"\n    }));\n  };\n  const onBack = () => {\n    if (showQR()) {\n      onCloseQR();\n    } else {\n      props.onBackClick();\n    }\n  };\n  onCleanup(unsubscribe);\n  onRetry();\n  return createComponent(MobileConnectionModalStyled, {\n    \"data-tc-wallets-modal-connection-mobile\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !props.backDisabled || showQR();\n        },\n        get children() {\n          return createComponent(StyledIconButton$2, {\n            icon: \"arrow\",\n            onClick: onBack\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return showQR();\n        },\n        get children() {\n          return createComponent(MobileConnectionQR, {\n            get universalLink() {\n              return universalLink();\n            },\n            get walletInfo() {\n              return props.wallet;\n            },\n            onOpenLink: onRetry,\n            onCopy,\n            get isCopiedShown() {\n              return isCopiedShown();\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !showQR();\n        },\n        get children() {\n          return [createComponent(H1Styled$6, {\n            get children() {\n              return props.wallet.name;\n            }\n          }), createComponent(BodyStyled, {\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return connectionErrored();\n                },\n                get children() {\n                  return [createComponent(ErrorIconStyled$1, {\n                    size: \"s\"\n                  }), createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"missing-features\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.missingFeatures\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            children: \"Please update Wallet, your version does not support required features for this dApp\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"connection-declined\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.connectionDeclined\",\n                            children: \"Connection declined\"\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return connectionErrored() === \"not-supported\";\n                        },\n                        get children() {\n                          return createComponent(BodyTextStyled$1, {\n                            translationKey: \"walletModal.mobileConnectionModal.notSupportedWallet\",\n                            get translationValues() {\n                              return {\n                                name: props.wallet.name\n                              };\n                            },\n                            get children() {\n                              return [memo(() => props.wallet.name), \" doesnt support the requested action. Please connect another wallet that supports it.\"];\n                            }\n                          });\n                        }\n                      })];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return createComponent(Switch, {\n                        get children() {\n                          return [createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"missing-features\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Link, {\n                                get href() {\n                                  return props.wallet.aboutUrl;\n                                },\n                                blank: true,\n                                get children() {\n                                  return createComponent(Button, {\n                                    get leftIcon() {\n                                      return createComponent(LinkIcon, {});\n                                    },\n                                    get children() {\n                                      return createComponent(Translation, {\n                                        translationKey: \"walletModal.mobileConnectionModal.updateWallet\",\n                                        get translationValues() {\n                                          return {\n                                            name: props.wallet.name\n                                          };\n                                        },\n                                        get children() {\n                                          return [\"Update \", memo(() => props.wallet.name)];\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              })];\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"not-supported\";\n                            },\n                            get children() {\n                              return createComponent(Button, {\n                                onClick: () => props.onBackClick(),\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.chooseAnotherWallet\",\n                                    children: \"Choose Another Wallet\"\n                                  });\n                                }\n                              });\n                            }\n                          }), createComponent(Match, {\n                            get when() {\n                              return connectionErrored() === \"connection-declined\";\n                            },\n                            get children() {\n                              return [createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(RetryIcon, {});\n                                },\n                                onClick: onRetry,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"common.retry\",\n                                    children: \"Retry\"\n                                  });\n                                }\n                              }), createComponent(Button, {\n                                get leftIcon() {\n                                  return createComponent(QRIcon, {\n                                    get fill() {\n                                      return theme.colors.accent;\n                                    }\n                                  });\n                                },\n                                onClick: onOpenQR,\n                                get children() {\n                                  return createComponent(Translation, {\n                                    translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                                    children: \"Show QR Code\"\n                                  });\n                                }\n                              })];\n                            }\n                          })];\n                        }\n                      });\n                    }\n                  })];\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return !connectionErrored();\n                },\n                get children() {\n                  return [createComponent(LoaderStyled, {\n                    size: \"s\"\n                  }), createComponent(BodyTextStyled$1, {\n                    translationKey: \"walletModal.mobileConnectionModal.continueIn\",\n                    get translationValues() {\n                      return {\n                        name: props.wallet.name\n                      };\n                    },\n                    get children() {\n                      return [\"Continue in \", memo(() => props.wallet.name), \"\"];\n                    }\n                  }), createComponent(ButtonsContainerStyled$1, {\n                    get children() {\n                      return [createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(RetryIcon, {});\n                        },\n                        onClick: onRetry,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"common.retry\",\n                            children: \"Retry\"\n                          });\n                        }\n                      }), createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(QRIcon, {\n                            get fill() {\n                              return theme.colors.accent;\n                            }\n                          });\n                        },\n                        onClick: onOpenQR,\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.mobileConnectionModal.showQR\",\n                            children: \"Show QR Code\"\n                          });\n                        }\n                      })];\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(FooterStyled, {\n            get children() {\n              return [createComponent(ImageStyled, {\n                get src() {\n                  return props.wallet.imageUrl;\n                }\n              }), createComponent(H3, {\n                get children() {\n                  return props.wallet.name;\n                }\n              }), createComponent(FooterButton, {\n                get href() {\n                  return props.wallet.aboutUrl;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.get\",\n                        children: \"GET\"\n                      });\n                    }\n                  });\n                }\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders$2 = {\n  m: \"16px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst tgBorders = {\n  m: \"6px\",\n  s: \"6px\",\n  none: \"0\"\n};\nstyled.li`\n    width: 82px;\n    min-width: 82px;\n    height: 124px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 8px 4px;\n\n    text-align: center;\n    cursor: pointer;\n\n    transition: transform 0.1s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst H1Styled$4 = styled(H1)`\n    margin-top: 38px;\n    margin-bottom: 4px;\n    padding: 0 24px;\n`;\nconst H2Styled$2 = styled(H2)`\n    margin: ${(props) => {\n  var _a2;\n  return (_a2 = props.margin) != null ? _a2 : \"0 0 28px 0\";\n}};\n    padding: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"0 24px\";\n}};\n    min-height: ${(props) => {\n  var _a2;\n  return (_a2 = props.padding) != null ? _a2 : \"44px\";\n}};\n    max-width: ${(props) => props.maxWidth}px;\n    margin-left: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n    margin-right: ${(props) => props.maxWidth ? \"auto\" : \"0px\"};\n`;\nstyled(Button)`\n    display: block;\n    margin: 0 auto;\n`;\nconst TelegramButtonStyled = styled(Button)`\n    margin: 0 28px 24px;\n    width: calc(100% - 56px);\n    border-radius: ${(props) => borders$2[props.theme.borderRadius]};\n    padding: 14px 16px 14px 14px;\n    background-color: ${(props) => props.theme.colors.telegramButton};\n\n    color: ${(props) => props.theme.colors.constant.white};\n    font-weight: 500;\n    font-size: 16px;\n    line-height: 20px;\n\n    @media (max-width: 375px) {\n        margin: 0 16px 24px;\n        width: calc(100% - 32px);\n    }\n`;\nconst TGImageStyled = styled(Image)`\n    background-color: transparent;\n    border-radius: ${(props) => tgBorders[props.theme.borderRadius]};\n    width: 24px;\n    height: 24px;\n`;\nconst StyledLeftActionButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst actionButtonBorderRadius = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$3 = styled(H1)`\n    margin-bottom: 2px;\n    padding: 0 52px;\n`;\nconst H2Styled$1 = styled(H2)`\n    margin-bottom: 20px;\n    padding: 0 64px;\n`;\nconst QrCodeWrapper = styled.div`\n    padding: 0 24px 16px;\n`;\nconst ButtonsWrapper = styled.div`\n    display: flex;\n    flex-direction: row;\n    gap: 16px;\n    padding: 0 24px 24px;\n    margin-top: 0;\n`;\nconst ActionButton = styled(Button)`\n    width: 100%;\n    height: 56px;\n    border-radius: ${(props) => actionButtonBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: 500;\n    padding: 17px 20px 19px 20px;\n`;\nconst MobileUniversalQR = (props) => {\n  return [createComponent(H1Styled$3, {\n    translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n    children: \"Connect your TON wallet\"\n  }), createComponent(H2Styled$1, {\n    translationKey: \"walletModal.mobileUniversalModal.scan\",\n    children: \"Scan with your mobile wallet\"\n  }), createComponent(QrCodeWrapper, {\n    get children() {\n      return createComponent(QRCode, {\n        get imageUrl() {\n          return IMG.TON;\n        },\n        get sourceUrl() {\n          return addReturnStrategy(props.universalLink, \"none\");\n        },\n        disableCopy: true\n      });\n    }\n  }), createComponent(ButtonsWrapper, {\n    get children() {\n      return [createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onOpenLink(),\n        get children() {\n          return createComponent(Translation, {\n            translationKey: \"walletModal.mobileUniversalModal.openLink\",\n            children: \"Open Link\"\n          });\n        }\n      }), createComponent(ActionButton, {\n        appearance: \"secondary\",\n        onClick: () => props.onCopy(),\n        get children() {\n          return createComponent(Translation, {\n            get translationKey() {\n              return props.isCopiedShown !== void 0 ? \"common.copied\" : \"common.copyLink\";\n            },\n            get children() {\n              return props.isCopiedShown !== void 0 ? \"Copied\" : \"Copy Link\";\n            }\n          });\n        }\n      })];\n    }\n  })];\n};\nfunction getUniqueBridges(walletsList) {\n  const uniqueBridges = new Set(\n    walletsList.filter(isWalletInfoRemote).map((item) => item.bridgeUrl)\n  );\n  return Array.from(uniqueBridges).map((bridgeUrl) => ({ bridgeUrl }));\n}\nfunction bridgesIsEqual(left, right) {\n  const leftSet = new Set(left == null ? void 0 : left.map((i2) => i2.bridgeUrl));\n  const rightSet = new Set(right == null ? void 0 : right.map((i2) => i2.bridgeUrl));\n  return leftSet.size === rightSet.size && [...leftSet].every((value) => rightSet.has(value));\n}\nvar _tmpl$$1 = /* @__PURE__ */ template$1(`<li>`), _tmpl$2 = /* @__PURE__ */ template$1(`<div data-tc-wallets-modal-universal-mobile=true>`);\nconst MobileUniversalModal = (props) => {\n  const [showQR, setShowQR] = createSignal(false);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [universalLink, setUniversalLink] = createSignal(null);\n  const connector = appState.connector;\n  const walletsList = () => props.walletsList.filter((w) => supportsMobile(w) && w.appName !== AT_WALLET_APP_NAME);\n  const shouldShowMoreButton = () => walletsList().length > 7;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  const atWalletSupportFeatures = createMemo(() => {\n    var _a2, _b2;\n    return (_b2 = (_a2 = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME)) == null ? void 0 : _a2.isSupportRequiredFeatures) != null ? _b2 : false;\n  }, null);\n  const getUniversalLink = () => {\n    if (!universalLink()) {\n      setUniversalLink(connector.connect(walletsBridges(), props.additionalRequest));\n    }\n    return universalLink();\n  };\n  setLastSelectedWalletInfo({\n    openMethod: \"universal-link\"\n  });\n  const [isCopiedShown, setIsCopiedShown] = createSignal(void 0);\n  const onCopy = () => __async(null, null, function* () {\n    if (isCopiedShown() !== void 0) {\n      clearTimeout(isCopiedShown());\n    }\n    yield copyToClipboard(getUniversalLink());\n    const timeoutId = setTimeout(() => setIsCopiedShown(void 0), 1500);\n    setIsCopiedShown(timeoutId);\n  });\n  const onSelectUniversal = () => {\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToWallet(getUniversalLink(), void 0, {\n      returnStrategy: appState.returnStrategy,\n      forceRedirect\n    }, (method) => {\n      setLastSelectedWalletInfo({\n        openMethod: method\n      });\n    });\n  };\n  const onSelectTelegram = () => {\n    setUniversalLink(null);\n    const atWallet = props.walletsList.find((wallet) => wallet.appName === AT_WALLET_APP_NAME);\n    if (!atWallet || !isWalletInfoRemote(atWallet)) {\n      throw new TonConnectUIError(\"@wallet bot not found in the wallets list\");\n    }\n    const walletLink = connector.connect({\n      bridgeUrl: atWallet.bridgeUrl,\n      universalLink: atWallet.universalLink\n    }, props.additionalRequest);\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    redirectToTelegram(walletLink, {\n      returnStrategy: appState.returnStrategy,\n      twaReturnUrl: appState.twaReturnUrl,\n      forceRedirect\n    });\n  };\n  const onOpenQR = () => {\n    setShowQR(true);\n    setLastSelectedWalletInfo({\n      openMethod: \"qrcode\"\n    });\n  };\n  const onCloseQR = () => {\n    setShowQR(false);\n    setLastSelectedWalletInfo({\n      openMethod: \"universal-link\"\n    });\n  };\n  const supportedWallets = createMemo(() => walletsList().filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  const fourWalletsItem = createMemo(() => walletsList().filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return (() => {\n    var _el$ = _tmpl$2();\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          icon: \"arrow\",\n          onClick: onCloseQR\n        }), createComponent(MobileUniversalQR, {\n          get universalLink() {\n            return getUniversalLink();\n          },\n          get isCopiedShown() {\n            return isCopiedShown();\n          },\n          onOpenLink: onSelectUniversal,\n          onCopy\n        })];\n      }\n    }), null);\n    insert(_el$, createComponent(Show, {\n      get when() {\n        return !showQR();\n      },\n      get children() {\n        return [createComponent(StyledLeftActionButton, {\n          get icon() {\n            return createComponent(QRIcon, {});\n          },\n          onClick: onOpenQR\n        }), createComponent(H1Styled$4, {\n          translationKey: \"walletModal.mobileUniversalModal.connectYourWallet\",\n          children: \"Connect your TON wallet\"\n        }), createComponent(Show, {\n          get when() {\n            return atWalletSupportFeatures();\n          },\n          get children() {\n            return [createComponent(H2Styled$2, {\n              translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect\",\n              maxWidth: 320,\n              children: \"Use Wallet in Telegram or choose other application\"\n            }), createComponent(TelegramButtonStyled, {\n              get leftIcon() {\n                return createComponent(AtWalletIcon, {});\n              },\n              get rightIcon() {\n                return createComponent(TGImageStyled, {\n                  get src() {\n                    return IMG.TG;\n                  }\n                });\n              },\n              onClick: onSelectTelegram,\n              scale: \"s\",\n              get children() {\n                return createComponent(Translation, {\n                  translationKey: \"walletModal.mobileUniversalModal.openWalletOnTelegram\",\n                  children: \"Connect Wallet in Telegram\"\n                });\n              }\n            })];\n          }\n        }), createComponent(H2Styled$2, {\n          translationKey: \"walletModal.mobileUniversalModal.chooseOtherApplication\",\n          maxWidth: 342,\n          padding: \"0 24px 8px 24px\",\n          margin: \"0\",\n          children: \"Choose other application\"\n        }), createComponent(WalletUlContainer, {\n          get children() {\n            return [createComponent(For, {\n              get each() {\n                return memo(() => !!shouldShowMoreButton())() ? visibleWallets() : supportedWallets();\n              },\n              children: (wallet) => (() => {\n                var _el$3 = _tmpl$$1();\n                insert(_el$3, createComponent(WalletItem, {\n                  get icon() {\n                    return wallet.imageUrl;\n                  },\n                  get name() {\n                    return wallet.name;\n                  },\n                  onClick: () => props.onSelect(wallet)\n                }));\n                return _el$3;\n              })()\n            }), createComponent(Show, {\n              get when() {\n                return shouldShowMoreButton();\n              },\n              get children() {\n                var _el$2 = _tmpl$$1();\n                insert(_el$2, createComponent(FourWalletsItem, {\n                  labelLine1: \"View all\",\n                  labelLine2: \"wallets\",\n                  get images() {\n                    return fourWalletsItem().map((i2) => i2.imageUrl);\n                  },\n                  onClick: () => props.onSelectAllWallets()\n                }));\n                return _el$2;\n              }\n            })];\n          }\n        })];\n      }\n    }), null);\n    return _el$;\n  })();\n};\nconst borders$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst hoverBorders = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst DesktopUniversalModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 16px;\n`;\nconst H2Styled = styled(H2)`\n    max-width: 320px;\n    margin-top: 2px;\n    margin-bottom: 20px;\n`;\nconst H2AvailableWalletsStyled = styled(H2)`\n    margin-bottom: 16px;\n`;\nconst QRCodeStyled = styled(QRCode)`\n    margin-bottom: 24px;\n`;\nconst WalletsContainerStyled = styled.ul`\n    display: flex;\n`;\nstyled.div`\n    display: flex;\n    gap: 16px;\n    width: 100%;\n`;\nstyled(Button)`\n    position: relative;\n    font-size: 16px;\n    line-height: 20px;\n    width: 100%;\n    padding: 0 16px;\n    height: 56px;\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n\n    &:hover {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n\n    &:active {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n`;\nstyled.ul`\n    position: absolute;\n    bottom: 100%;\n    left: 0;\n    margin: 0;\n    padding: 8px;\n    width: 188px;\n    transform: translateY(-16px);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n`;\nstyled.li`\n    padding: 8px;\n\n    display: flex;\n    align-items: center;\n    gap: 8px;\n\n    cursor: pointer;\n    border-radius: ${(props) => hoverBorders[props.theme.borderRadius]};\n\n    transition:\n        background-color,\n        transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nstyled(Image)`\n    width: 24px;\n    height: 24px;\n\n    border-radius: 6px;\n`;\nstyled.div`\n    margin-top: 23px;\n    margin-bottom: 1px;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\nstyled(Text)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    font-size: 16px;\n`;\nvar _tmpl$ = /* @__PURE__ */ template$1(`<li>`);\nconst DesktopUniversalModal = (props) => {\n  const [popupOpened, setPopupOpened] = createSignal(false);\n  const connector = appState.connector;\n  const walletsBridges = createMemo(() => getUniqueBridges(props.walletsList), null, {\n    equals: bridgesIsEqual\n  });\n  setLastSelectedWalletInfo({\n    openMethod: \"qrcode\"\n  });\n  const request = createMemo(() => connector.connect(walletsBridges(), props.additionalRequest));\n  const supportedWallets = createMemo(() => props.walletsList.filter((wallet) => wallet.isSupportRequiredFeatures), null);\n  const visibleWallets = createMemo(() => supportedWallets().slice(0, 3), null);\n  const fourWalletsItem = createMemo(() => props.walletsList.filter((wallet) => !visibleWallets().find((w) => w.appName === wallet.appName)).slice(0, 4), null);\n  return createComponent(DesktopUniversalModalStyled, {\n    onClick: () => setPopupOpened(false),\n    \"data-tc-wallets-modal-universal-desktop\": \"true\",\n    get children() {\n      return [createComponent(H1, {\n        translationKey: \"walletModal.desktopUniversalModal.connectYourWallet\",\n        children: \"Connect your wallet\"\n      }), createComponent(H2Styled, {\n        translationKey: \"walletModal.desktopUniversalModal.scan\",\n        children: \"Scan with your mobile wallet\"\n      }), createComponent(QRCodeStyled, {\n        get sourceUrl() {\n          return addReturnStrategy(request(), \"none\");\n        },\n        get disableCopy() {\n          return popupOpened();\n        },\n        get imageUrl() {\n          return IMG.TON;\n        }\n      }), createComponent(H2AvailableWalletsStyled, {\n        translationKey: \"walletModal.desktopUniversalModal.availableWallets\",\n        children: \"Available wallets\"\n      }), createComponent(WalletsContainerStyled, {\n        get children() {\n          return [createComponent(For, {\n            get each() {\n              return visibleWallets();\n            },\n            children: (wallet) => (() => {\n              var _el$ = _tmpl$();\n              insert(_el$, createComponent(WalletLabeledItem, {\n                wallet,\n                onClick: () => props.onSelect(wallet)\n              }));\n              return _el$;\n            })()\n          }), createComponent(FourWalletsItem, {\n            labelLine1: \"View all\",\n            labelLine2: \"wallets\",\n            get images() {\n              return fourWalletsItem().map((i2) => i2.imageUrl);\n            },\n            onClick: () => props.onSelectAllWallets()\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst H1Styled$2 = styled(H1)`\n    max-width: 288px;\n    margin: 0 auto 38px;\n`;\nconst DesktopFeatureNotSupportModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst StyledIconButton$1 = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst TitleStyled = styled(H1)`\n    text-align: center;\n    font-size: 20px;\n    line-height: 28px;\n`;\nconst DescriptionStyled = styled(Text)`\n    margin-top: 12px;\n    margin-bottom: 24px;\n    text-align: center;\n    max-width: 360px;\n    font-weight: 400;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nstyled.button`\n    background: transparent;\n    border: none;\n    padding: 0;\n    margin: 0;\n    color: ${(props) => props.theme.colors.accent};\n    text-decoration: underline;\n    cursor: pointer;\n    font: inherit;\n`;\nconst Spacer = styled.div`\n    margin-bottom: 46px;\n`;\nconst ErrorIconStyled = styled(ErrorIcon)`\n    margin-bottom: 16px;\n`;\nstyled.ul`\n    display: flex;\n    gap: 8px;\n    margin-bottom: 24px;\n    list-style: none;\n    padding: 0;\n`;\nconst DisconnectButtonStyled = styled(Button)`\n    max-width: 320px;\n    width: 100%;\n    height: 48px;\n    font-size: 16px;\n    line-height: 20px;\n    border-radius: ${(props) => borders[props.theme.borderRadius]};\n    margin-bottom: 28px;\n`;\nconst BodyTextStyled = styled(H2)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    text-align: center;\n    margin-bottom: 20px;\n`;\nconst ButtonsContainerStyled = styled.div`\n    display: flex;\n    justify-content: center;\n    gap: 8px;\n    padding-bottom: 31px;\n`;\nconst RestoreInfoModalStyled = styled.div`\n    margin: 0 8px 16px 8px;\n`;\nconst StyledIconButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst H1Styled$1 = styled(H1)`\n    margin-bottom: 18px;\n    text-align: center;\n`;\nconst StepBlock = styled.div`\n    padding: 16px 0;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nstyled.div`\n    margin-bottom: 12px;\n`;\nconst H3Styled = styled(H3)`\n    text-align: center;\n    margin-bottom: 4px;\n`;\nconst TextStyled$1 = styled(Text)`\n    text-align: center;\n    max-width: 352px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst CircleNumber = styled.div`\n    width: 44px;\n    height: 44px;\n    border-radius: 20px;\n    background-color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.icon.secondary;\n}};\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin-bottom: 12px;\n    font-weight: 700;\n    font-size: 22px;\n    color: ${(props) => {\n  var _a2;\n  return (_a2 = props.theme) == null ? void 0 : _a2.colors.text.primary;\n}};\n`;\nconst RestoreInfoModal = (props) => {\n  return createComponent(RestoreInfoModalStyled, {\n    \"data-tc-wallets-modal-restore\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton, {\n        icon: \"arrow\",\n        get onClick() {\n          return props.onBackClick;\n        }\n      }), createComponent(H1Styled$1, {\n        translationKey: \"walletModal.restoreInfoModal.title\",\n        children: \"Restore\"\n      }), createComponent(ScrollContainer, {\n        get children() {\n          return [createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"1\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step1.title\",\n                children: \"Find your current recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step1.text\",\n                children: \"Open your wallet settings and locate therecoveryphrase\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"2\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step2.title\",\n                children: \"Copy your recovery phrase\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step2.text\",\n                children: \"Write it down or copy it to a safe place\"\n              })];\n            }\n          }), createComponent(StepBlock, {\n            get children() {\n              return [createComponent(CircleNumber, {\n                children: \"3\"\n              }), createComponent(H3Styled, {\n                translationKey: \"walletModal.restoreModal.step3.title\",\n                children: \"Restore in a supported wallet fromthelistbelow\"\n              }), createComponent(TextStyled$1, {\n                translationKey: \"walletModal.restoreModal.step3.text\",\n                children: \"Enter the recovery phrase to access your wallet\"\n              })];\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst DesktopFeatureNotSupportModal = (props) => {\n  const [selectedWallet, setSelectedWallet] = createSignal(null);\n  const [infoModalOpen, setInfoModalOpen] = createSignal(false);\n  const currentWalletUI = createMemo(() => props.walletsList.find((wallet) => wallet.appName === props.currentWallet.device.appName || wallet.name === props.currentWallet.device.appName));\n  const currentWalletName = createMemo(() => {\n    var _a2, _b2, _c2, _d2;\n    const appName = (_b2 = (_a2 = currentWalletUI()) == null ? void 0 : _a2.appName) != null ? _b2 : props.currentWallet.device.appName;\n    if (appName === AT_WALLET_APP_NAME) {\n      return \"Wallet in Telegram\";\n    }\n    return (_d2 = (_c2 = currentWalletUI()) == null ? void 0 : _c2.name) != null ? _d2 : props.currentWallet.device.appName;\n  });\n  const currentWalletVersionNotSupported = createMemo(() => {\n    const currentWalletUIVar = currentWalletUI();\n    if (!(currentWalletUIVar == null ? void 0 : currentWalletUIVar.features)) {\n      return false;\n    }\n    const requiredFeature = props.walletsModalState.requiredFeature;\n    const requiredFeatures = requiredFeature ? {\n      [requiredFeature.featureName]: requiredFeature.value\n    } : {};\n    const validInList = checkRequiredWalletFeatures(currentWalletUIVar.features, requiredFeatures);\n    const validCurrentWallet = checkRequiredWalletFeatures(props.currentWallet.device.features, requiredFeatures);\n    return validInList && !validCurrentWallet;\n  });\n  const handleDisconnect = () => __async(null, null, function* () {\n    yield props.onDisconnect();\n    props.onSelect(selectedWallet());\n  });\n  return createComponent(DesktopFeatureNotSupportModalStyled, {\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return infoModalOpen();\n            },\n            get children() {\n              return createComponent(RestoreInfoModal, {\n                onBackClick: () => setInfoModalOpen(false)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return selectedWallet();\n            },\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(DesktopFeatureNotSupportModalStyled, {\n                get children() {\n                  return [createComponent(StyledIconButton$1, {\n                    icon: \"arrow\",\n                    onClick: () => setSelectedWallet(null)\n                  }), createComponent(TitleStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.title\",\n                    children: \"Confirm Disconnect\"\n                  }), createComponent(DescriptionStyled, {\n                    translationKey: \"walletModal.featureNotSupported.disconnect.description\",\n                    get translationValues() {\n                      return {\n                        name: selectedWallet().name\n                      };\n                    },\n                    get children() {\n                      return [\"You will be disconnected from your current wallet and redirected to connect \", memo(() => {\n                        var _a2;\n                        return (_a2 = selectedWallet()) == null ? void 0 : _a2.name;\n                      }), \".\"];\n                    }\n                  }), createComponent(DisconnectButtonStyled, {\n                    onClick: () => handleDisconnect(),\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"walletModal.featureNotSupported.disconnect.button\",\n                        children: \"Disconnect\"\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            get when() {\n              return currentWalletVersionNotSupported();\n            },\n            get children() {\n              return [createComponent(H1Styled$2, {\n                get children() {\n                  return currentWalletName();\n                }\n              }), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(BodyTextStyled, {\n                translationKey: \"walletModal.featureNotSupported.version.description\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [\"Your current version of \", memo(() => currentWalletName()), \" or wallet contract type doesn't support the required features. Please update it to continue.\"];\n                }\n              }), createComponent(ButtonsContainerStyled, {\n                get children() {\n                  return [createComponent(Link, {\n                    get href() {\n                      return currentWalletUI().aboutUrl;\n                    },\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.updateButton\",\n                            get translationValues() {\n                              return {\n                                name: currentWalletName()\n                              };\n                            },\n                            get children() {\n                              return [\"Update \", memo(() => currentWalletName())];\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }), createComponent(Link, {\n                    href: \"https://tonkeeper.helpscoutdocs.com/article/102-w5\",\n                    blank: true,\n                    get children() {\n                      return createComponent(Button, {\n                        get leftIcon() {\n                          return createComponent(LinkIcon, {});\n                        },\n                        get children() {\n                          return createComponent(Translation, {\n                            translationKey: \"walletModal.featureNotSupported.version.aboutW5\",\n                            children: \"About W5\"\n                          });\n                        }\n                      });\n                    }\n                  })];\n                }\n              })];\n            }\n          }), createComponent(Match, {\n            when: true,\n            get children() {\n              return [createComponent(Spacer, {}), createComponent(ErrorIconStyled, {\n                size: \"s\"\n              }), createComponent(TitleStyled, {\n                translationKey: \"walletModal.featureNotSupported.wallet.title\",\n                get translationValues() {\n                  return {\n                    name: currentWalletName()\n                  };\n                },\n                get children() {\n                  return [memo(() => currentWalletName()), \" doesnt support the requestedaction\"];\n                }\n              }), createComponent(Spacer, {})];\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst WalletsModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getWalletsModalIsOpened()) {\n      updateIsMobile();\n      refetchWallets();\n    } else {\n      setSelectedWalletInfo(null);\n      setSelectedTab(\"universal\");\n      setInfoTab(false);\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [fetchedWalletsList, {\n    refetch: refetchWallets\n  }] = createResource(() => {\n    return tonConnectUI.getWallets();\n  });\n  const [selectedWalletInfo, setSelectedWalletInfo] = createSignal(null);\n  const [selectedWalletError, setSelectedWalletError] = createSignal(null);\n  const [selectedTab, setSelectedTab] = createSignal(\"universal\");\n  const [infoTab, setInfoTab] = createSignal(false);\n  const walletsModalIsWalletNotSupportFeature = createMemo(() => {\n    const state = walletsModalState();\n    return \"type\" in state && state.type === \"wallet-not-support-feature\";\n  });\n  const walletsList = createMemo(() => {\n    var _a2;\n    if (fetchedWalletsList.state !== \"ready\") {\n      return null;\n    }\n    let walletsList2 = applyWalletsListConfiguration(fetchedWalletsList(), appState.walletsListConfiguration);\n    const injectedWallets = walletsList2.filter(isWalletInfoCurrentlyInjected);\n    const notInjectedWallets = walletsList2.filter((w) => !isWalletInfoCurrentlyInjected(w));\n    walletsList2 = (injectedWallets || []).concat(notInjectedWallets);\n    const preferredWalletAppName = appState.preferredWalletAppName;\n    const preferredWallet = walletsList2.find((item) => eqWalletName(item, preferredWalletAppName));\n    const someWalletsWithSameName = walletsList2.filter((item) => eqWalletName(item, preferredWalletAppName)).length >= 2;\n    if (preferredWalletAppName && preferredWallet && !someWalletsWithSameName) {\n      walletsList2 = [__spreadProps(__spreadValues({}, preferredWallet), {\n        isPreferred: true\n      })].concat(walletsList2.filter((item) => !eqWalletName(item, preferredWalletAppName)));\n    }\n    const atWallet = walletsList2.find((item) => eqWalletName(item, AT_WALLET_APP_NAME));\n    if (atWallet) {\n      walletsList2 = [atWallet].concat(walletsList2.filter((item) => !eqWalletName(item, AT_WALLET_APP_NAME)));\n    }\n    const walletsFeaturesRequested = (_a2 = tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) != null ? _a2 : tonConnectUI == null ? void 0 : tonConnectUI.walletsPreferredFeatures;\n    const uiWallets = walletsList2.map((wallet) => {\n      var _a3;\n      return __spreadProps(__spreadValues({}, wallet), {\n        isSupportRequiredFeatures: walletsFeaturesRequested ? checkRequiredWalletFeatures((_a3 = wallet.features) != null ? _a3 : [], walletsFeaturesRequested) : true\n      });\n    });\n    return uiWallets;\n  });\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  }, (err) => {\n    var _a2;\n    if (err instanceof WalletMissingRequiredFeaturesError) {\n      const errorAppName = err.cause.connectEvent.device.appName.toLowerCase();\n      const wallet = (_a2 = walletsList()) == null ? void 0 : _a2.find((w) => w.appName.toLowerCase() === errorAppName);\n      if (!wallet) {\n        throw new TonConnectError(\"Wallet not found\");\n      }\n      const walletErrorType = wallet.isSupportRequiredFeatures ? \"missing-features\" : \"not-supported\";\n      setSelectedWalletError(walletErrorType);\n      setSelectedWalletInfo(wallet);\n    }\n  });\n  const onSelectAllWallets = () => {\n    setSelectedTab(\"all-wallets\");\n  };\n  const onSelectUniversal = () => {\n    setSelectedTab(\"universal\");\n  };\n  const onSelectWallet = (wallet) => {\n    setSelectedWalletInfo(wallet);\n    widgetController.openWalletsModal();\n  };\n  const clearSelectedWalletInfo = () => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n  };\n  onCleanup(() => {\n    setSelectedWalletInfo(null);\n    setSelectedWalletError(null);\n    setInfoTab(false);\n  });\n  onCleanup(unsubscribe);\n  return createComponent(StyledModal, {\n    get opened() {\n      return getWalletsModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    get showFooter() {\n      return !walletsModalIsWalletNotSupportFeature();\n    },\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading() || !walletsList();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return memo(() => !!!additionalRequestLoading())() && walletsList();\n            },\n            get children() {\n              return createComponent(Switch, {\n                get children() {\n                  return [createComponent(Match, {\n                    get when() {\n                      return walletsModalIsWalletNotSupportFeature();\n                    },\n                    get children() {\n                      return createComponent(DesktopFeatureNotSupportModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get currentWallet() {\n                          return tonConnectUI == null ? void 0 : tonConnectUI.wallet;\n                        },\n                        onSelect: onSelectWallet,\n                        onSelectAllWallets,\n                        onDisconnect: () => connector.disconnect(),\n                        get walletsModalState() {\n                          return walletsModalState();\n                        },\n                        onClose: () => onClose(\"action-cancelled\")\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedWalletInfo();\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                        },\n                        get wallet() {\n                          return selectedWalletInfo();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onBackClick: clearSelectedWalletInfo,\n                        get defaultError() {\n                          return selectedWalletError();\n                        }\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"universal\";\n                    },\n                    get children() {\n                      return createComponent(Dynamic, {\n                        get component() {\n                          return isMobile() ? MobileUniversalModal : DesktopUniversalModal;\n                        },\n                        onSelect: setSelectedWalletInfo,\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get additionalRequest() {\n                          return additionalRequest();\n                        },\n                        onSelectAllWallets\n                      });\n                    }\n                  }), createComponent(Match, {\n                    get when() {\n                      return selectedTab() === \"all-wallets\";\n                    },\n                    get children() {\n                      return createComponent(AllWalletsListModal, {\n                        get walletsList() {\n                          return walletsList();\n                        },\n                        get featureCheckMode() {\n                          return (tonConnectUI == null ? void 0 : tonConnectUI.walletsRequiredFeatures) ? \"strict\" : \"soft\";\n                        },\n                        onBack: onSelectUniversal,\n                        onSelect: setSelectedWalletInfo\n                      });\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst ActionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 8px;\n`;\nconst H1Styled = styled(H1)`\n    margin-top: 16px;\n`;\nconst TextStyled = styled(Text)`\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n    text-align: center;\n    max-width: 250px;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst LoaderButtonStyled = styled(Button)`\n    min-width: 112px;\n    margin-top: 32px;\n`;\nconst LoaderIconStyled = styled(LoaderIcon)`\n    height: 16px;\n    width: 16px;\n`;\nconst ButtonStyled = styled(Button)`\n    margin-top: 32px;\n`;\nconst ActionModal = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [firstClick, setFirstClick] = createSignal(true);\n  const [sent, setSent] = createSignal(false);\n  const [signed, setSigned] = createSignal(false);\n  const [canceled, setCanceled] = createSignal(false);\n  createEffect(() => {\n    const currentAction = action();\n    setSent(!!currentAction && (\"sent\" in currentAction && currentAction.sent || currentAction.name === \"transaction-sent\"));\n    setSigned(!!currentAction && (\"signed\" in currentAction && currentAction.signed || currentAction.name === \"data-signed\"));\n    setCanceled(!!currentAction && (currentAction.name === \"transaction-canceled\" || currentAction.name === \"sign-data-canceled\"));\n  });\n  let universalLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"universalLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"universal-link\" || isTelegramUrl(tonConnectUI.wallet.universalLink) && isInTMA())) {\n    universalLink = tonConnectUI.wallet.universalLink;\n  }\n  let deepLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"deepLink\" in tonConnectUI.wallet && (tonConnectUI.wallet.openMethod === \"custom-deeplink\" || isTelegramUrl(tonConnectUI.wallet.deepLink) && isInTMA())) {\n    deepLink = tonConnectUI.wallet.deepLink;\n  }\n  const onOpenWallet = () => {\n    const currentAction = action();\n    const returnStrategy = \"returnStrategy\" in currentAction ? currentAction.returnStrategy : appState.returnStrategy;\n    const forceRedirect = !firstClick();\n    setFirstClick(false);\n    const linkWithSessionId = addSessionIdToUniversalLink(universalLink, currentAction.sessionId);\n    if (isTelegramUrl(universalLink)) {\n      redirectToTelegram(linkWithSessionId, {\n        returnStrategy,\n        twaReturnUrl: \"twaReturnUrl\" in currentAction ? currentAction.twaReturnUrl : appState.twaReturnUrl,\n        forceRedirect\n      });\n    } else {\n      redirectToWallet(linkWithSessionId, deepLink, {\n        returnStrategy,\n        forceRedirect\n      }, () => {\n      });\n    }\n  };\n  return createComponent(ActionModalStyled, mergeProps(dataAttrs, {\n    get children() {\n      return [memo(() => props.icon), createComponent(H1Styled, {\n        get translationKey() {\n          return props.headerTranslationKey;\n        },\n        get translationValues() {\n          return props.headerTranslationValues;\n        }\n      }), createComponent(TextStyled, {\n        get translationKey() {\n          return props.textTranslationKey;\n        },\n        get translationValues() {\n          return props.textTranslationValues;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !sent() && !signed() && !canceled() && (props.showButton === \"open-wallet\" && universalLink || props.showButton !== \"open-wallet\");\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return sent() || signed();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return props.showButton !== \"open-wallet\";\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: () => props.onClose(),\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.close\",\n                    children: \"Close\"\n                  });\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.showButton === \"open-wallet\" && universalLink;\n            },\n            get children() {\n              return createComponent(ButtonStyled, {\n                onClick: onOpenWallet,\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.openWallet\",\n                    children: \"Open wallet\"\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  }));\n};\nconst ConfirmTransactionModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.confirmTransaction.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.confirmTransaction.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-confirm-modal\": \"true\"\n  });\n};\nconst TransactionCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionCanceled.header\",\n    textTranslationKey: \"actionModal.transactionCanceled.text\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-canceled-modal\": \"true\"\n  });\n};\nconst TransactionSentModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionSent.header\",\n    textTranslationKey: \"actionModal.transactionSent.text\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    showButton: \"open-wallet\",\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-sent-modal\": \"true\"\n  });\n};\nconst ConfirmSignDataModal = (props) => {\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = () => tonConnectUI.wallet && \"name\" in tonConnectUI.wallet ? tonConnectUI.wallet.name : t2(\"common.yourWallet\", {}, \"Your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signData.header\",\n    get headerTranslationValues() {\n      return {\n        name: name()\n      };\n    },\n    textTranslationKey: \"actionModal.signData.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-sign-data-confirm-modal\": \"true\"\n  });\n};\nconst SignDataCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.signDataCanceled.header\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-sign-data-canceled-modal\": \"true\"\n  });\n};\nconst DataSignedModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.dataSigned.header\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-data-signed-modal\": \"true\"\n  });\n};\nconst ActionsModal = () => {\n  return createComponent(Modal, {\n    get opened() {\n      var _a2;\n      return memo(() => action() !== null)() && ((_a2 = action()) == null ? void 0 : _a2.openModal) === true;\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => setAction(null),\n    showFooter: false,\n    \"data-tc-actions-modal-container\": \"true\",\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-sent\";\n            },\n            get children() {\n              return createComponent(TransactionSentModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-canceled\";\n            },\n            get children() {\n              return createComponent(TransactionCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-transaction\";\n            },\n            get children() {\n              return createComponent(ConfirmTransactionModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"data-signed\";\n            },\n            get children() {\n              return createComponent(DataSignedModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"sign-data-canceled\";\n            },\n            get children() {\n              return createComponent(SignDataCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-sign-data\";\n            },\n            get children() {\n              return createComponent(ConfirmSignDataModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst SingleWalletModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  createEffect(() => {\n    if (getSingleWalletModalIsOpened()) {\n      updateIsMobile();\n    }\n  });\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [infoTab, setInfoTab] = createSignal(false);\n  const additionalRequestLoading = () => {\n    var _a2;\n    return ((_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a2;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a2 = appState.connectRequestParameters) == null ? void 0 : _a2.value;\n  });\n  const onClose = (closeReason) => {\n    tonConnectUI.closeSingleWalletModal(closeReason);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose(\"wallet-selected\");\n    }\n  });\n  onCleanup(unsubscribe);\n  onCleanup(() => {\n    setInfoTab(false);\n  });\n  return createComponent(StyledModal, {\n    get opened() {\n      return getSingleWalletModalIsOpened();\n    },\n    get enableAndroidBackHandler() {\n      return appState.enableAndroidBackHandler;\n    },\n    onClose: () => onClose(\"action-cancelled\"),\n    onClickQuestion: () => setInfoTab((v) => !v),\n    showFooter: true,\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return infoTab();\n        },\n        get children() {\n          return createComponent(InfoModal, {\n            onBackClick: () => setInfoTab(false)\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !infoTab();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return additionalRequestLoading();\n            },\n            get children() {\n              return [createComponent(H1Styled$a, {\n                translationKey: \"walletModal.loading\",\n                children: \"Wallets list is loading\"\n              }), createComponent(LoaderContainerStyled, {\n                get children() {\n                  return createComponent(LoaderIcon, {\n                    size: \"m\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return !additionalRequestLoading();\n            },\n            get children() {\n              return createComponent(Dynamic, {\n                get component() {\n                  return isMobile() ? MobileConnectionModal : DesktopConnectionModal;\n                },\n                get wallet() {\n                  return getSingleWalletModalWalletInfo();\n                },\n                get additionalRequest() {\n                  return additionalRequest();\n                },\n                onBackClick: () => {\n                },\n                backDisabled: true\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst App = (props) => {\n  const translations = createI18nContext(i18nDictionary, appState.language);\n  defineStylesRoot();\n  fixMobileSafariActiveTransition();\n  return createComponent(I18nContext.Provider, {\n    value: translations,\n    get children() {\n      return createComponent(TonConnectUiContext.Provider, {\n        get value() {\n          return props.tonConnectUI;\n        },\n        get children() {\n          return createComponent(ConnectorContext.Provider, {\n            get value() {\n              return appState.connector;\n            },\n            get children() {\n              return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {\n                theme: themeState,\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return appState.buttonRootId;\n                    },\n                    get children() {\n                      return createComponent(Portal, {\n                        get mount() {\n                          return document.getElementById(appState.buttonRootId);\n                        },\n                        get children() {\n                          return createComponent(AccountButton, {});\n                        }\n                      });\n                    }\n                  }), createComponent(Dynamic, {\n                    component: globalStylesTag,\n                    get children() {\n                      return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      });\n    }\n  });\n};\nconst widgetController = {\n  openWalletsModal: () => void setTimeout(() => setWalletsModalState({\n    status: \"opened\",\n    closeReason: null\n  })),\n  closeWalletsModal: (reason) => void setTimeout(() => setWalletsModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openSingleWalletModal: (walletInfo) => {\n    void setTimeout(() => setSingleWalletModalState({\n      status: \"opened\",\n      closeReason: null,\n      walletInfo\n    }));\n  },\n  closeSingleWalletModal: (reason) => void setTimeout(() => setSingleWalletModalState({\n    status: \"closed\",\n    closeReason: reason\n  })),\n  openWalletNotSupportFeatureModal: (cause) => void setTimeout(() => setWalletsModalState({\n    status: \"opened\",\n    closeReason: null,\n    type: \"wallet-not-support-feature\",\n    requiredFeature: cause.requiredFeature\n  })),\n  setAction: (action2) => void setTimeout(() => setAction(action2)),\n  clearAction: () => void setTimeout(() => setAction(null)),\n  getSelectedWalletInfo: () => lastSelectedWalletInfo(),\n  removeSelectedWalletInfo: () => setLastSelectedWalletInfo(null),\n  renderApp: (root, tonConnectUI) => render(() => createComponent(App, {\n    tonConnectUI\n  }), document.getElementById(root))\n};\nclass WalletsModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = walletsModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = walletsModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n  }\n  /**\n   * Opens the modal window.\n   */\n  open() {\n    return __async(this, null, function* () {\n      this.tracker.trackConnectionStarted();\n      const walletsList = yield this.connector.getWallets();\n      const embeddedWallet = walletsList.find(isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return this.connectEmbeddedWallet(embeddedWallet);\n      } else {\n        return this.openWalletsModal();\n      }\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeWalletsModal(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to an external wallet, and waits when modal window is opened.\n   * @internal\n   */\n  openWalletsModal() {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openWalletsModal();\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TransactionModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.connector = options.connector;\n    createEffect(() => {\n      const currentAction = action();\n      this.consumers.forEach((consumer) => consumer(currentAction));\n    });\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(consumer) {\n    this.consumers.push(consumer);\n    return () => {\n      this.consumers = this.consumers.filter((c2) => c2 !== consumer);\n    };\n  }\n}\nclass SingleWalletModalManager {\n  constructor(options) {\n    this.consumers = [];\n    this.state = singleWalletModalState();\n    this.connector = options.connector;\n    this.tracker = options.tracker;\n    this.setConnectRequestParametersCallback = options.setConnectRequestParametersCallback;\n    createEffect(() => {\n      const state = singleWalletModalState();\n      this.state = state;\n      this.consumers.forEach((consumer) => consumer(state));\n    });\n  }\n  /**\n   * Opens the modal window with the specified wallet.\n   * @param wallet - Wallet app name.\n   * @throws TonConnectUIError if the specified wallet is not found.\n   */\n  open(wallet) {\n    return __async(this, null, function* () {\n      this.tracker.trackConnectionStarted();\n      const fetchedWalletsList = yield this.connector.getWallets();\n      const walletsList = applyWalletsListConfiguration(\n        fetchedWalletsList,\n        appState.walletsListConfiguration\n      );\n      const embeddedWallet = walletsList.find(isWalletInfoCurrentlyEmbedded);\n      const isEmbeddedWalletExist = !!embeddedWallet;\n      if (isEmbeddedWalletExist) {\n        return this.connectEmbeddedWallet(embeddedWallet);\n      }\n      const externalWallets = walletsList.filter(isWalletInfoRemote);\n      const externalWallet = externalWallets.find((walletInfo) => eqWalletName(walletInfo, wallet));\n      const isExternalWalletExist = !!externalWallet;\n      if (isExternalWalletExist) {\n        return this.openSingleWalletModal(externalWallet);\n      }\n      const error = `Trying to open modal window with unknown wallet \"${wallet}\".`;\n      this.tracker.trackConnectionError(error);\n      throw new TonConnectUIError(error);\n    });\n  }\n  /**\n   * Closes the modal window.\n   * @default 'action-cancelled'\n   */\n  close(reason = \"action-cancelled\") {\n    if (reason === \"action-cancelled\") {\n      this.tracker.trackConnectionError(\"Connection was cancelled\");\n    }\n    widgetController.closeSingleWalletModal(\"action-cancelled\");\n  }\n  /**\n   * Subscribe to the modal window state changes, returns unsubscribe function.\n   */\n  onStateChange(onChange) {\n    this.consumers.push(onChange);\n    return () => {\n      this.consumers = this.consumers.filter((consumer) => consumer !== onChange);\n    };\n  }\n  /**\n   * Initiates a connection with an embedded wallet.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet) {\n    const connect = (parameters) => {\n      setLastSelectedWalletInfo(embeddedWallet);\n      this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n    };\n    const additionalRequest = appState.connectRequestParameters;\n    if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n      this.setConnectRequestParametersCallback(connect);\n    } else {\n      connect(additionalRequest == null ? void 0 : additionalRequest.value);\n    }\n  }\n  /**\n   * Opens the modal window to connect to a specified wallet, and waits when modal window is opened.\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      if (isInTMA()) {\n        sendExpand();\n      }\n      widgetController.openSingleWalletModal(wallet);\n      return new Promise((resolve) => {\n        const unsubscribe = this.onStateChange((state) => {\n          const { status } = state;\n          if (status === \"opened\") {\n            unsubscribe();\n            resolve();\n          }\n        });\n      });\n    });\n  }\n}\nclass TonConnectUITracker {\n  constructor(options) {\n    var _a2;\n    this.eventPrefix = \"ton-connect-ui-\";\n    this.tonConnectSdkVersion = null;\n    this.eventDispatcher = (_a2 = options == null ? void 0 : options.eventDispatcher) != null ? _a2 : new BrowserEventDispatcher();\n    this.tonConnectUiVersion = options.tonConnectUiVersion;\n    this.init().catch();\n  }\n  /**\n   * Version of the library.\n   */\n  get version() {\n    return createVersionInfo({\n      ton_connect_sdk_lib: this.tonConnectSdkVersion,\n      ton_connect_ui_lib: this.tonConnectUiVersion\n    });\n  }\n  /**\n   * Called once when the tracker is created and request version other libraries.\n   */\n  init() {\n    return __async(this, null, function* () {\n      try {\n        yield this.setRequestVersionHandler();\n        this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion();\n      } catch (e2) {\n      }\n    });\n  }\n  /**\n   * Set request version handler.\n   * @private\n   */\n  setRequestVersionHandler() {\n    return __async(this, null, function* () {\n      yield this.eventDispatcher.addEventListener(\"ton-connect-ui-request-version\", () => __async(this, null, function* () {\n        yield this.eventDispatcher.dispatchEvent(\n          \"ton-connect-ui-response-version\",\n          createResponseVersionEvent(this.tonConnectUiVersion)\n        );\n      }));\n    });\n  }\n  /**\n   * Request TonConnect SDK version.\n   * @private\n   */\n  requestTonConnectSdkVersion() {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => __async(this, null, function* () {\n        try {\n          yield this.eventDispatcher.addEventListener(\n            \"ton-connect-response-version\",\n            (event) => {\n              resolve(event.detail.version);\n            },\n            { once: true }\n          );\n          yield this.eventDispatcher.dispatchEvent(\n            \"ton-connect-request-version\",\n            createRequestVersionEvent()\n          );\n        } catch (e2) {\n          reject(e2);\n        }\n      }));\n    });\n  }\n  /**\n   * Emit user action event to the window.\n   * @param eventDetails\n   * @private\n   */\n  dispatchUserActionEvent(eventDetails) {\n    var _a2;\n    try {\n      (_a2 = this.eventDispatcher) == null ? void 0 : _a2.dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails).catch();\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection init event.\n   * @param args\n   */\n  trackConnectionStarted(...args) {\n    try {\n      const event = createConnectionStartedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection success event.\n   * @param args\n   */\n  trackConnectionCompleted(...args) {\n    try {\n      const event = createConnectionCompletedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection error event.\n   * @param args\n   */\n  trackConnectionError(...args) {\n    try {\n      const event = createConnectionErrorEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring init event.\n   * @param args\n   */\n  trackConnectionRestoringStarted(...args) {\n    try {\n      const event = createConnectionRestoringStartedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring success event.\n   * @param args\n   */\n  trackConnectionRestoringCompleted(...args) {\n    try {\n      const event = createConnectionRestoringCompletedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track connection restoring error event.\n   * @param args\n   */\n  trackConnectionRestoringError(...args) {\n    try {\n      const event = createConnectionRestoringErrorEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track disconnect event.\n   * @param args\n   */\n  trackDisconnection(...args) {\n    try {\n      const event = createDisconnectionEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction init event.\n   * @param args\n   */\n  trackTransactionSentForSignature(...args) {\n    try {\n      const event = createTransactionSentForSignatureEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction signed event.\n   * @param args\n   */\n  trackTransactionSigned(...args) {\n    try {\n      const event = createTransactionSignedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track transaction error event.\n   * @param args\n   */\n  trackTransactionSigningFailed(...args) {\n    try {\n      const event = createTransactionSigningFailedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data sent for signature event.\n   * @param args\n   */\n  trackDataSentForSignature(...args) {\n    try {\n      const event = createDataSentForSignatureEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signed event.\n   * @param args\n   */\n  trackDataSigned(...args) {\n    try {\n      const event = createDataSignedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n  /**\n   * Track data signing error event.\n   * @param args\n   */\n  trackDataSigningFailed(...args) {\n    try {\n      const event = createDataSigningFailedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e2) {\n    }\n  }\n}\nconst tonConnectUiVersion = \"2.3.1\";\nclass TonConnectUI {\n  // TODO: `actionsConfiguration.twaReturnUrl` is used only in `connectWallet` method, but it's not used in `sendTransaction` method, NEED TO FIX IT\n  constructor(options) {\n    this.walletInfoStorage = new WalletInfoStorage();\n    this.preferredWalletStorage = new PreferredWalletStorage();\n    this.walletInfo = null;\n    this.systemThemeChangeUnsubscribe = null;\n    this.connectionRestored = Promise.resolve(false);\n    if (options && \"connector\" in options && options.connector) {\n      this.connector = options.connector;\n    } else if (options && \"manifestUrl\" in options && options.manifestUrl) {\n      this.connector = new TonConnect({\n        manifestUrl: options.manifestUrl,\n        eventDispatcher: options.eventDispatcher,\n        walletsRequiredFeatures: options.walletsRequiredFeatures\n      });\n    } else {\n      throw new TonConnectUIError(\n        \"You have to specify a `manifestUrl` or a `connector` in the options.\"\n      );\n    }\n    this.tracker = new TonConnectUITracker({\n      eventDispatcher: options == null ? void 0 : options.eventDispatcher,\n      tonConnectUiVersion\n    });\n    this.modal = new WalletsModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.singleWalletModal = new SingleWalletModalManager({\n      connector: this.connector,\n      tracker: this.tracker,\n      setConnectRequestParametersCallback: (callback) => {\n        this.connectRequestParametersCallback = callback;\n      }\n    });\n    this.transactionModal = new TransactionModalManager({\n      connector: this.connector\n    });\n    this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    this.walletsList = this.getWallets();\n    this.walletsList.then((list) => preloadImages(uniq(list.map((item) => item.imageUrl))));\n    const rootId = this.normalizeWidgetRoot(options == null ? void 0 : options.widgetRootId);\n    this.subscribeToWalletChange();\n    if ((options == null ? void 0 : options.restoreConnection) !== false) {\n      this.connectionRestored = createMacrotaskAsync(() => __async(this, null, function* () {\n        this.tracker.trackConnectionRestoringStarted();\n        yield this.connector.restoreConnection();\n        if (!this.connector.connected) {\n          this.tracker.trackConnectionRestoringError(\"Connection was not restored\");\n          this.walletInfoStorage.removeWalletInfo();\n        } else {\n          this.tracker.trackConnectionRestoringCompleted(this.wallet);\n        }\n        return this.connector.connected;\n      }));\n    }\n    this.uiOptions = mergeOptions(options, { uiPreferences: { theme: \"SYSTEM\" } });\n    const preferredWalletName = this.preferredWalletStorage.getPreferredWalletAppName();\n    setAppState({\n      connector: this.connector,\n      preferredWalletAppName: preferredWalletName\n    });\n    widgetController.renderApp(rootId, this);\n  }\n  static getWallets() {\n    return TonConnect.getWallets();\n  }\n  get walletsRequiredFeatures() {\n    return this._walletsRequiredFeatures;\n  }\n  get walletsPreferredFeatures() {\n    return this._walletsPreferredFeatures;\n  }\n  /**\n   * Current connection status.\n   */\n  get connected() {\n    return this.connector.connected;\n  }\n  /**\n   * Current connected account or null.\n   */\n  get account() {\n    return this.connector.account;\n  }\n  /**\n   * Curren connected wallet app and its info or null.\n   */\n  get wallet() {\n    if (!this.connector.wallet) {\n      return null;\n    }\n    return __spreadValues(__spreadValues({}, this.connector.wallet), this.walletInfo);\n  }\n  /**\n   * Set and apply new UI options. Object with partial options should be passed. Passed options will be merged with current options.\n   * @param options\n   */\n  set uiOptions(options) {\n    var _a2, _b2, _c2, _d2, _e2;\n    this.checkButtonRootExist(options.buttonRootId);\n    this.actionsConfiguration = options.actionsConfiguration;\n    if (\"walletsRequiredFeatures\" in options) {\n      this._walletsRequiredFeatures = options.walletsRequiredFeatures;\n    }\n    if (\"walletsPreferredFeatures\" in options) {\n      this._walletsPreferredFeatures = options.walletsPreferredFeatures;\n    }\n    if ((_a2 = options.uiPreferences) == null ? void 0 : _a2.theme) {\n      if (((_b2 = options.uiPreferences) == null ? void 0 : _b2.theme) !== \"SYSTEM\") {\n        (_c2 = this.systemThemeChangeUnsubscribe) == null ? void 0 : _c2.call(this);\n        setTheme(options.uiPreferences.theme, options.uiPreferences.colorsSet);\n      } else {\n        setTheme(getSystemTheme(), options.uiPreferences.colorsSet);\n        if (!this.systemThemeChangeUnsubscribe) {\n          this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme);\n        }\n      }\n    } else {\n      if ((_d2 = options.uiPreferences) == null ? void 0 : _d2.colorsSet) {\n        setColors(options.uiPreferences.colorsSet);\n      }\n    }\n    if ((_e2 = options.uiPreferences) == null ? void 0 : _e2.borderRadius) {\n      setBorderRadius(options.uiPreferences.borderRadius);\n    }\n    setAppState((state) => {\n      var _a3, _b3;\n      const merged = mergeOptions(\n        __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, options.language && { language: options.language }), !!((_a3 = options.actionsConfiguration) == null ? void 0 : _a3.returnStrategy) && {\n          returnStrategy: options.actionsConfiguration.returnStrategy\n        }), !!((_b3 = options.actionsConfiguration) == null ? void 0 : _b3.twaReturnUrl) && {\n          twaReturnUrl: options.actionsConfiguration.twaReturnUrl\n        }), !!options.walletsListConfiguration && {\n          walletsListConfiguration: options.walletsListConfiguration\n        }),\n        unwrap(state)\n      );\n      if (options.buttonRootId !== void 0) {\n        merged.buttonRootId = options.buttonRootId;\n      }\n      if (options.enableAndroidBackHandler !== void 0) {\n        merged.enableAndroidBackHandler = options.enableAndroidBackHandler;\n      }\n      return merged;\n    });\n  }\n  /**\n   * Use it to customize ConnectRequest and add `tonProof` payload.\n   * You can call it multiply times to set updated tonProof payload if previous one is outdated.\n   * If `connectRequestParameters.state === 'loading'` loader will appear instead of the qr code in the wallets modal.\n   * If `connectRequestParameters.state` was changed to 'ready' or it's value has been changed, QR will be re-rendered.\n   */\n  setConnectRequestParameters(connectRequestParameters) {\n    var _a2;\n    setAppState({ connectRequestParameters });\n    if ((connectRequestParameters == null ? void 0 : connectRequestParameters.state) === \"ready\" || !connectRequestParameters) {\n      (_a2 = this.connectRequestParametersCallback) == null ? void 0 : _a2.call(this, connectRequestParameters == null ? void 0 : connectRequestParameters.value);\n    }\n  }\n  /**\n   * Returns available wallets list.\n   */\n  getWallets() {\n    return __async(this, null, function* () {\n      return this.connector.getWallets();\n    });\n  }\n  /**\n   * Subscribe to connection status change.\n   * @return function which has to be called to unsubscribe.\n   */\n  onStatusChange(callback, errorsHandler) {\n    return this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      if (wallet) {\n        const lastSelectedWalletInfo2 = yield this.getSelectedWalletInfo(wallet);\n        callback(__spreadValues(__spreadValues({}, wallet), lastSelectedWalletInfo2 || this.walletInfoStorage.getWalletInfo()));\n      } else {\n        callback(wallet);\n      }\n    }), errorsHandler);\n  }\n  /**\n   * Opens the modal window, returns a promise that resolves after the modal window is opened.\n   */\n  openModal() {\n    return __async(this, null, function* () {\n      return this.modal.open();\n    });\n  }\n  /**\n   * Closes the modal window.\n   */\n  closeModal(reason) {\n    this.modal.close(reason);\n  }\n  /**\n   * Subscribe to the modal window state changes, returns a function which has to be called to unsubscribe.\n   */\n  onModalStateChange(onChange) {\n    return this.modal.onStateChange(onChange);\n  }\n  /**\n   * Returns current modal window state.\n   */\n  get modalState() {\n    return this.modal.state;\n  }\n  /**\n   * Opens the single wallet modal window, returns a promise that resolves after the modal window is opened.\n   * @experimental\n   */\n  openSingleWalletModal(wallet) {\n    return __async(this, null, function* () {\n      return this.singleWalletModal.open(wallet);\n    });\n  }\n  /**\n   * Close the single wallet modal window.\n   * @experimental\n   */\n  closeSingleWalletModal(closeReason) {\n    this.singleWalletModal.close(closeReason);\n  }\n  /**\n   * Subscribe to the single wallet modal window state changes, returns a function which has to be called to unsubscribe.\n   * @experimental\n   */\n  onSingleWalletModalStateChange(onChange) {\n    return this.singleWalletModal.onStateChange(onChange);\n  }\n  /**\n   * Returns current single wallet modal window state.\n   * @experimental\n   */\n  get singleWalletModalState() {\n    return this.singleWalletModal.state;\n  }\n  /**\n   * @deprecated Use `tonConnectUI.openModal()` instead. Will be removed in the next major version.\n   * Opens the modal window and handles a wallet connection.\n   * @return Connected wallet.\n   * @throws TonConnectUIError if connection was aborted.\n   */\n  connectWallet() {\n    return __async(this, null, function* () {\n      const walletsList = yield this.getWallets();\n      const embeddedWallet = walletsList.find(isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        return yield this.connectEmbeddedWallet(embeddedWallet);\n      } else {\n        return yield this.connectExternalWallet();\n      }\n    });\n  }\n  /**\n   * Disconnect wallet and clean localstorage.\n   */\n  disconnect() {\n    this.tracker.trackDisconnection(this.wallet, \"dapp\");\n    widgetController.clearAction();\n    widgetController.removeSelectedWalletInfo();\n    this.walletInfoStorage.removeWalletInfo();\n    return this.connector.disconnect();\n  }\n  /**\n   * Opens the modal window and handles the transaction sending.\n   * @param tx transaction to send.\n   * @param options modal and notifications behaviour settings. Default is show only 'before' modal and all notifications.\n   */\n  sendTransaction(tx, options) {\n    return __async(this, null, function* () {\n      this.tracker.trackTransactionSentForSignature(this.wallet, tx);\n      if (!this.connected) {\n        this.tracker.trackTransactionSigningFailed(this.wallet, tx, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration(options);\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-transaction\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        sent: false,\n        sessionId: sessionId || void 0\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a2;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-transaction\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          sent: true,\n          sessionId: sessionId || void 0\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => __async(this, null, function* () {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          yield this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0\n          });\n        });\n        (_a2 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a2.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSendTransaction(\n          {\n            transaction: tx,\n            signal: abortController.signal\n          },\n          onRequestSent\n        );\n        this.tracker.trackTransactionSigned(this.wallet, tx, result);\n        widgetController.setAction({\n          name: \"transaction-sent\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\")\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause);\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"transaction-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\")\n        });\n        if (e2 instanceof TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Signs the data and returns the signature.\n   * @param data data to sign.\n   */\n  signData(data, options) {\n    return __async(this, null, function* () {\n      this.tracker.trackDataSentForSignature(this.wallet, data);\n      if (!this.connected) {\n        this.tracker.trackDataSigningFailed(this.wallet, data, \"Wallet was not connected\");\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      if (isInTMA()) {\n        sendExpand();\n      }\n      const { notifications: notifications2, modals, returnStrategy, twaReturnUrl } = this.getModalsAndNotificationsConfiguration();\n      const sessionId = yield this.getSessionId();\n      widgetController.setAction({\n        name: \"confirm-sign-data\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\"),\n        signed: false,\n        sessionId: sessionId || void 0\n      });\n      const abortController = new AbortController();\n      const onRequestSent = () => {\n        var _a2;\n        if (abortController.signal.aborted) {\n          return;\n        }\n        widgetController.setAction({\n          name: \"confirm-sign-data\",\n          showNotification: notifications2.includes(\"before\"),\n          openModal: modals.includes(\"before\"),\n          signed: true,\n          sessionId: sessionId || void 0\n        });\n        this.redirectAfterRequestSent({\n          returnStrategy,\n          twaReturnUrl,\n          sessionId: sessionId || void 0\n        });\n        let firstClick = true;\n        const redirectToWallet2 = () => {\n          if (abortController.signal.aborted) {\n            return;\n          }\n          const forceRedirect = !firstClick;\n          firstClick = false;\n          this.redirectAfterRequestSent({\n            returnStrategy,\n            twaReturnUrl,\n            forceRedirect,\n            sessionId: sessionId || void 0\n          });\n        };\n        (_a2 = options == null ? void 0 : options.onRequestSent) == null ? void 0 : _a2.call(options, redirectToWallet2);\n      };\n      const unsubscribe = this.onTransactionModalStateChange((action2) => {\n        if (action2 == null ? void 0 : action2.openModal) {\n          return;\n        }\n        unsubscribe();\n        if (!action2) {\n          abortController.abort();\n        }\n      });\n      try {\n        const result = yield this.waitForSignData(\n          {\n            data,\n            signal: new AbortController().signal\n          },\n          onRequestSent\n        );\n        this.tracker.trackDataSigned(this.wallet, data, result);\n        widgetController.setAction({\n          name: \"data-signed\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\")\n        });\n        return result;\n      } catch (e2) {\n        if (e2 instanceof WalletNotSupportFeatureError) {\n          widgetController.clearAction();\n          widgetController.openWalletNotSupportFeatureModal(e2.cause);\n          throw e2;\n        }\n        widgetController.setAction({\n          name: \"sign-data-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\")\n        });\n        if (e2 instanceof TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      } finally {\n        unsubscribe();\n      }\n    });\n  }\n  /**\n   * Gets the current session ID if available.\n   * @returns session ID string or null if not available.\n   */\n  getSessionId() {\n    return __async(this, null, function* () {\n      var _a2, _b2;\n      if (!this.connected) {\n        return null;\n      }\n      try {\n        const storage = (_a2 = this.connector.dappSettings) == null ? void 0 : _a2.storage;\n        if (storage) {\n          const stored = yield storage.getItem(\"ton-connect-storage_bridge-connection\");\n          if (stored) {\n            const connection = JSON.parse(stored);\n            if (connection.type === \"http\" && connection.sessionCrypto) {\n              const sessionCrypto = new SessionCrypto(connection.sessionCrypto);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            } else if (connection.type === \"http\" && ((_b2 = connection.session) == null ? void 0 : _b2.sessionKeyPair)) {\n              const sessionCrypto = new SessionCrypto(connection.session.sessionKeyPair);\n              const sessionId = sessionCrypto.sessionId;\n              return sessionId;\n            }\n          }\n        }\n      } catch (e2) {\n      }\n      return null;\n    });\n  }\n  redirectAfterRequestSent({\n    returnStrategy,\n    twaReturnUrl,\n    forceRedirect,\n    sessionId\n  }) {\n    if (this.walletInfo && \"universalLink\" in this.walletInfo && (this.walletInfo.openMethod === \"universal-link\" || this.walletInfo.openMethod === \"custom-deeplink\")) {\n      const linkWithSessionId = addSessionIdToUniversalLink(\n        this.walletInfo.universalLink,\n        sessionId\n      );\n      if (isTelegramUrl(this.walletInfo.universalLink)) {\n        redirectToTelegram(linkWithSessionId, {\n          returnStrategy,\n          twaReturnUrl: twaReturnUrl || appState.twaReturnUrl,\n          forceRedirect: forceRedirect || false\n        });\n      } else {\n        redirectToWallet(\n          linkWithSessionId,\n          this.walletInfo.deepLink,\n          {\n            returnStrategy,\n            forceRedirect: forceRedirect || false\n          },\n          () => {\n          }\n        );\n      }\n    }\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates a connection with an embedded wallet, awaits its completion, and returns the connected wallet information.\n   * @param embeddedWallet - Information about the embedded wallet to connect to.\n   * @throws Error if the connection process fails.\n   * @internal\n   */\n  connectEmbeddedWallet(embeddedWallet) {\n    return __async(this, null, function* () {\n      const connect = (parameters) => {\n        setLastSelectedWalletInfo(embeddedWallet);\n        this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n      };\n      const additionalRequest = appState.connectRequestParameters;\n      if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n        this.connectRequestParametersCallback = connect;\n      } else {\n        connect(additionalRequest == null ? void 0 : additionalRequest.value);\n      }\n      return yield this.waitForWalletConnection({\n        ignoreErrors: false\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Initiates the connection process for an external wallet by opening the wallet modal\n   * and returns the connected wallet information upon successful connection.\n   * @throws Error if the user cancels the connection process or if the connection process fails.\n   * @internal\n   */\n  connectExternalWallet() {\n    return __async(this, null, function* () {\n      const abortController = new AbortController();\n      widgetController.openWalletsModal();\n      const unsubscribe = this.onModalStateChange((state) => {\n        const { status, closeReason } = state;\n        if (status === \"opened\") {\n          return;\n        }\n        unsubscribe();\n        if (closeReason === \"action-cancelled\") {\n          abortController.abort();\n        }\n      });\n      return yield this.waitForWalletConnection({\n        ignoreErrors: true,\n        signal: abortController.signal\n      });\n    });\n  }\n  /**\n   * TODO: remove in the next major version.\n   * Waits for a wallet connection based on provided options, returning connected wallet information.\n   * @param options - Configuration for connection statuses and errors handling.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid wallet connects. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @throws TonConnectUIError if waiting is aborted or no valid wallet connection is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForWalletConnection(options) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        this.tracker.trackConnectionStarted();\n        const { ignoreErrors = false, signal = null } = options;\n        if (signal && signal.aborted) {\n          this.tracker.trackConnectionError(\"Connection was cancelled\");\n          return reject(new TonConnectUIError(\"Wallet was not connected\"));\n        }\n        const onStatusChangeHandler = (wallet) => __async(this, null, function* () {\n          if (!wallet) {\n            this.tracker.trackConnectionError(\"Connection was cancelled\");\n            if (ignoreErrors) {\n              return;\n            }\n            unsubscribe();\n            reject(new TonConnectUIError(\"Wallet was not connected\"));\n          } else {\n            this.tracker.trackConnectionCompleted(wallet);\n            unsubscribe();\n            resolve(wallet);\n          }\n        });\n        const onErrorsHandler = (reason) => {\n          this.tracker.trackConnectionError(reason.message);\n          if (ignoreErrors) {\n            return;\n          }\n          unsubscribe();\n          reject(reason);\n        };\n        const unsubscribe = this.onStatusChange(\n          (wallet) => onStatusChangeHandler(wallet),\n          (reason) => onErrorsHandler(reason)\n        );\n        if (signal) {\n          signal.addEventListener(\n            \"abort\",\n            () => {\n              unsubscribe();\n              reject(new TonConnectUIError(\"Wallet was not connected\"));\n            },\n            { once: true }\n          );\n        }\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSendTransaction(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { transaction, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          return reject(new TonConnectUIError(\"Transaction was not sent\"));\n        }\n        const onTransactionHandler = (transaction2) => __async(this, null, function* () {\n          resolve(transaction2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackTransactionSigningFailed(\n            this.wallet,\n            transaction,\n            \"Transaction was cancelled\"\n          );\n          reject(new TonConnectUIError(\"Transaction was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.sendTransaction(transaction, { onRequestSent, signal }).then((result) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onTransactionHandler(result);\n        }).catch((reason) => {\n          signal.removeEventListener(\"abort\", onCanceledHandler);\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Waits for a transaction to be sent based on provided options, returning the transaction response.\n   * @param options - Configuration for transaction statuses and errors handling.\n   * @options.transaction - Transaction to send.\n   * @options.ignoreErrors - If true, ignores errors during waiting, waiting continues until a valid transaction is sent. Default is false.\n   * @options.abortSignal - Optional AbortSignal for external cancellation. Throws TonConnectUIError if aborted.\n   * @param onRequestSent (optional) will be called after the transaction is sent to the wallet.\n   * @throws TonConnectUIError if waiting is aborted or no valid transaction response is received and ignoreErrors is false.\n   * @internal\n   */\n  waitForSignData(options, onRequestSent) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const { data, signal } = options;\n        if (signal.aborted) {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          return reject(new TonConnectUIError(\"SignData was not sent\"));\n        }\n        const onSignHandler = (data2) => __async(this, null, function* () {\n          resolve(data2);\n        });\n        const onErrorsHandler = (reason) => {\n          reject(reason);\n        };\n        const onCanceledHandler = () => {\n          this.tracker.trackDataSigningFailed(this.wallet, data, \"SignData was cancelled\");\n          reject(new TonConnectUIError(\"SignData was not sent\"));\n        };\n        signal.addEventListener(\"abort\", onCanceledHandler, { once: true });\n        this.connector.signData(data, { onRequestSent, signal }).then((result) => {\n          return onSignHandler(result);\n        }).catch((reason) => {\n          return onErrorsHandler(reason);\n        });\n      });\n    });\n  }\n  /**\n   * Subscribe to the transaction modal window state changes, returns a function which has to be called to unsubscribe.\n   * @internal\n   */\n  onTransactionModalStateChange(onChange) {\n    return this.transactionModal.onStateChange(onChange);\n  }\n  subscribeToWalletChange() {\n    this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      var _a2;\n      if (wallet) {\n        yield this.updateWalletInfo(wallet);\n        this.setPreferredWalletAppName(((_a2 = this.walletInfo) == null ? void 0 : _a2.appName) || wallet.device.appName);\n      } else {\n        this.walletInfoStorage.removeWalletInfo();\n      }\n    }));\n  }\n  setPreferredWalletAppName(value) {\n    this.preferredWalletStorage.setPreferredWalletAppName(value);\n    setAppState({ preferredWalletAppName: value });\n  }\n  getSelectedWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      let lastSelectedWalletInfo2 = widgetController.getSelectedWalletInfo();\n      if (!lastSelectedWalletInfo2) {\n        return null;\n      }\n      let fullLastSelectedWalletInfo;\n      if (!(\"name\" in lastSelectedWalletInfo2)) {\n        const walletsList = applyWalletsListConfiguration(\n          yield this.walletsList,\n          appState.walletsListConfiguration\n        );\n        const walletInfo = walletsList.find((item) => eqWalletName(item, wallet.device.appName));\n        if (!walletInfo) {\n          throw new TonConnectUIError(\n            `Cannot find WalletInfo for the '${wallet.device.appName}' wallet`\n          );\n        }\n        fullLastSelectedWalletInfo = __spreadValues(__spreadValues({}, walletInfo), lastSelectedWalletInfo2);\n      } else {\n        fullLastSelectedWalletInfo = lastSelectedWalletInfo2;\n      }\n      return fullLastSelectedWalletInfo;\n    });\n  }\n  updateWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      const selectedWalletInfo = yield this.getSelectedWalletInfo(wallet);\n      if (selectedWalletInfo) {\n        this.walletInfo = selectedWalletInfo;\n        this.walletInfoStorage.setWalletInfo(selectedWalletInfo);\n        return;\n      }\n      const storedWalletInfo = this.walletInfoStorage.getWalletInfo();\n      if (storedWalletInfo) {\n        this.walletInfo = storedWalletInfo;\n        return;\n      }\n      this.walletInfo = (yield this.walletsList).find(\n        (walletInfo) => eqWalletName(walletInfo, wallet.device.appName)\n      ) || null;\n    });\n  }\n  normalizeWidgetRoot(rootId) {\n    if (!rootId || !document.getElementById(rootId)) {\n      rootId = \"tc-widget-root\";\n      const rootElement = document.createElement(\"div\");\n      rootElement.id = rootId;\n      document.body.appendChild(rootElement);\n    }\n    return rootId;\n  }\n  checkButtonRootExist(buttonRootId) {\n    if (buttonRootId == null) {\n      return;\n    }\n    if (!document.getElementById(buttonRootId)) {\n      throw new TonConnectUIError(`${buttonRootId} element not found in the document.`);\n    }\n  }\n  // eslint-disable-next-line complexity\n  getModalsAndNotificationsConfiguration(options) {\n    var _a2, _b2, _c2, _d2, _e2, _f2;\n    const allActions = [\n      \"before\",\n      \"success\",\n      \"error\"\n    ];\n    let notifications2 = allActions;\n    if (((_a2 = this.actionsConfiguration) == null ? void 0 : _a2.notifications) && ((_b2 = this.actionsConfiguration) == null ? void 0 : _b2.notifications) !== \"all\") {\n      notifications2 = this.actionsConfiguration.notifications;\n    }\n    if (options == null ? void 0 : options.notifications) {\n      if (options.notifications === \"all\") {\n        notifications2 = allActions;\n      } else {\n        notifications2 = options.notifications;\n      }\n    }\n    let modals = [\"before\"];\n    if ((_c2 = this.actionsConfiguration) == null ? void 0 : _c2.modals) {\n      if (this.actionsConfiguration.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = this.actionsConfiguration.modals;\n      }\n    }\n    if (options == null ? void 0 : options.modals) {\n      if (options.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = options.modals;\n      }\n    }\n    const returnStrategy = (options == null ? void 0 : options.returnStrategy) || ((_d2 = this.actionsConfiguration) == null ? void 0 : _d2.returnStrategy) || \"back\";\n    const twaReturnUrl = (options == null ? void 0 : options.twaReturnUrl) || ((_e2 = this.actionsConfiguration) == null ? void 0 : _e2.twaReturnUrl);\n    let skipRedirectToWallet = (options == null ? void 0 : options.skipRedirectToWallet) || ((_f2 = this.actionsConfiguration) == null ? void 0 : _f2.skipRedirectToWallet) || \"ios\";\n    if (isInTMA()) {\n      skipRedirectToWallet = \"never\";\n    }\n    return {\n      notifications: notifications2,\n      modals,\n      returnStrategy,\n      twaReturnUrl,\n      skipRedirectToWallet\n    };\n  }\n}\nexport {\n  THEME,\n  TonConnectUI,\n  TonConnectUIError\n};\n//# sourceMappingURL=index.mjs.map\n","\"use client\";\nvar Z=e=>typeof e==\"function\",h=(e,t)=>Z(e)?e(t):e;var W=(()=>{let e=0;return()=>(++e).toString()})(),E=(()=>{let e;return()=>{if(e===void 0&&typeof window<\"u\"){let t=matchMedia(\"(prefers-reduced-motion: reduce)\");e=!t||t.matches}return e}})();import{useEffect as ee,useState as te,useRef as oe}from\"react\";var re=20,k=\"default\";var H=(e,t)=>{let{toastLimit:o}=e.settings;switch(t.type){case 0:return{...e,toasts:[t.toast,...e.toasts].slice(0,o)};case 1:return{...e,toasts:e.toasts.map(r=>r.id===t.toast.id?{...r,...t.toast}:r)};case 2:let{toast:s}=t;return H(e,{type:e.toasts.find(r=>r.id===s.id)?1:0,toast:s});case 3:let{toastId:a}=t;return{...e,toasts:e.toasts.map(r=>r.id===a||a===void 0?{...r,dismissed:!0,visible:!1}:r)};case 4:return t.toastId===void 0?{...e,toasts:[]}:{...e,toasts:e.toasts.filter(r=>r.id!==t.toastId)};case 5:return{...e,pausedAt:t.time};case 6:let i=t.time-(e.pausedAt||0);return{...e,pausedAt:void 0,toasts:e.toasts.map(r=>({...r,pauseDuration:r.pauseDuration+i}))}}},v=[],j={toasts:[],pausedAt:void 0,settings:{toastLimit:re}},f={},Y=(e,t=k)=>{f[t]=H(f[t]||j,e),v.forEach(([o,s])=>{o===t&&s(f[t])})},_=e=>Object.keys(f).forEach(t=>Y(e,t)),Q=e=>Object.keys(f).find(t=>f[t].toasts.some(o=>o.id===e)),S=(e=k)=>t=>{Y(t,e)},se={blank:4e3,error:4e3,success:2e3,loading:1/0,custom:4e3},V=(e={},t=k)=>{let[o,s]=te(f[t]||j),a=oe(f[t]);ee(()=>(a.current!==f[t]&&s(f[t]),v.push([t,s]),()=>{let r=v.findIndex(([l])=>l===t);r>-1&&v.splice(r,1)}),[t]);let i=o.toasts.map(r=>{var l,g,T;return{...e,...e[r.type],...r,removeDelay:r.removeDelay||((l=e[r.type])==null?void 0:l.removeDelay)||(e==null?void 0:e.removeDelay),duration:r.duration||((g=e[r.type])==null?void 0:g.duration)||(e==null?void 0:e.duration)||se[r.type],style:{...e.style,...(T=e[r.type])==null?void 0:T.style,...r.style}}});return{...o,toasts:i}};var ie=(e,t=\"blank\",o)=>({createdAt:Date.now(),visible:!0,dismissed:!1,type:t,ariaProps:{role:\"status\",\"aria-live\":\"polite\"},message:e,pauseDuration:0,...o,id:(o==null?void 0:o.id)||W()}),P=e=>(t,o)=>{let s=ie(t,e,o);return S(s.toasterId||Q(s.id))({type:2,toast:s}),s.id},n=(e,t)=>P(\"blank\")(e,t);n.error=P(\"error\");n.success=P(\"success\");n.loading=P(\"loading\");n.custom=P(\"custom\");n.dismiss=(e,t)=>{let o={type:3,toastId:e};t?S(t)(o):_(o)};n.dismissAll=e=>n.dismiss(void 0,e);n.remove=(e,t)=>{let o={type:4,toastId:e};t?S(t)(o):_(o)};n.removeAll=e=>n.remove(void 0,e);n.promise=(e,t,o)=>{let s=n.loading(t.loading,{...o,...o==null?void 0:o.loading});return typeof e==\"function\"&&(e=e()),e.then(a=>{let i=t.success?h(t.success,a):void 0;return i?n.success(i,{id:s,...o,...o==null?void 0:o.success}):n.dismiss(s),a}).catch(a=>{let i=t.error?h(t.error,a):void 0;i?n.error(i,{id:s,...o,...o==null?void 0:o.error}):n.dismiss(s)}),e};import{useEffect as X,useCallback as A,useRef as ne}from\"react\";var ce=1e3,w=(e,t=\"default\")=>{let{toasts:o,pausedAt:s}=V(e,t),a=ne(new Map).current,i=A((c,m=ce)=>{if(a.has(c))return;let p=setTimeout(()=>{a.delete(c),r({type:4,toastId:c})},m);a.set(c,p)},[]);X(()=>{if(s)return;let c=Date.now(),m=o.map(p=>{if(p.duration===1/0)return;let R=(p.duration||0)+p.pauseDuration-(c-p.createdAt);if(R<0){p.visible&&n.dismiss(p.id);return}return setTimeout(()=>n.dismiss(p.id,t),R)});return()=>{m.forEach(p=>p&&clearTimeout(p))}},[o,s,t]);let r=A(S(t),[t]),l=A(()=>{r({type:5,time:Date.now()})},[r]),g=A((c,m)=>{r({type:1,toast:{id:c,height:m}})},[r]),T=A(()=>{s&&r({type:6,time:Date.now()})},[s,r]),d=A((c,m)=>{let{reverseOrder:p=!1,gutter:R=8,defaultPosition:z}=m||{},O=o.filter(u=>(u.position||z)===(c.position||z)&&u.height),K=O.findIndex(u=>u.id===c.id),B=O.filter((u,I)=>I<K&&u.visible).length;return O.filter(u=>u.visible).slice(...p?[B+1]:[0,B]).reduce((u,I)=>u+(I.height||0)+R,0)},[o]);return X(()=>{o.forEach(c=>{if(c.dismissed)i(c.id,c.removeDelay);else{let m=a.get(c.id);m&&(clearTimeout(m),a.delete(c.id))}})},[o,i]),{toasts:o,handlers:{updateHeight:g,startPause:l,endPause:T,calculateOffset:d}}};import*as y from\"react\";import{styled as J,keyframes as G}from\"goober\";import*as b from\"react\";import{styled as U,keyframes as xe}from\"goober\";import{styled as pe,keyframes as M}from\"goober\";var de=M`\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n transform: scale(1) rotate(45deg);\n  opacity: 1;\n}`,me=M`\nfrom {\n  transform: scale(0);\n  opacity: 0;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}`,le=M`\nfrom {\n  transform: scale(0) rotate(90deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(90deg);\n\topacity: 1;\n}`,C=pe(\"div\")`\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ${e=>e.primary||\"#ff4b4b\"};\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ${de} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n\n  &:after,\n  &:before {\n    content: '';\n    animation: ${me} 0.15s ease-out forwards;\n    animation-delay: 150ms;\n    position: absolute;\n    border-radius: 3px;\n    opacity: 0;\n    background: ${e=>e.secondary||\"#fff\"};\n    bottom: 9px;\n    left: 4px;\n    height: 2px;\n    width: 12px;\n  }\n\n  &:before {\n    animation: ${le} 0.15s ease-out forwards;\n    animation-delay: 180ms;\n    transform: rotate(90deg);\n  }\n`;import{styled as ue,keyframes as fe}from\"goober\";var Te=fe`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`,F=ue(\"div\")`\n  width: 12px;\n  height: 12px;\n  box-sizing: border-box;\n  border: 2px solid;\n  border-radius: 100%;\n  border-color: ${e=>e.secondary||\"#e0e0e0\"};\n  border-right-color: ${e=>e.primary||\"#616161\"};\n  animation: ${Te} 1s linear infinite;\n`;import{styled as ye,keyframes as q}from\"goober\";var ge=q`\nfrom {\n  transform: scale(0) rotate(45deg);\n\topacity: 0;\n}\nto {\n  transform: scale(1) rotate(45deg);\n\topacity: 1;\n}`,he=q`\n0% {\n\theight: 0;\n\twidth: 0;\n\topacity: 0;\n}\n40% {\n  height: 0;\n\twidth: 6px;\n\topacity: 1;\n}\n100% {\n  opacity: 1;\n  height: 10px;\n}`,L=ye(\"div\")`\n  width: 20px;\n  opacity: 0;\n  height: 20px;\n  border-radius: 10px;\n  background: ${e=>e.primary||\"#61d345\"};\n  position: relative;\n  transform: rotate(45deg);\n\n  animation: ${ge} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n  animation-delay: 100ms;\n  &:after {\n    content: '';\n    box-sizing: border-box;\n    animation: ${he} 0.2s ease-out forwards;\n    opacity: 0;\n    animation-delay: 200ms;\n    position: absolute;\n    border-right: 2px solid;\n    border-bottom: 2px solid;\n    border-color: ${e=>e.secondary||\"#fff\"};\n    bottom: 6px;\n    left: 6px;\n    height: 10px;\n    width: 6px;\n  }\n`;var be=U(\"div\")`\n  position: absolute;\n`,Se=U(\"div\")`\n  position: relative;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-width: 20px;\n  min-height: 20px;\n`,Ae=xe`\nfrom {\n  transform: scale(0.6);\n  opacity: 0.4;\n}\nto {\n  transform: scale(1);\n  opacity: 1;\n}`,Pe=U(\"div\")`\n  position: relative;\n  transform: scale(0.6);\n  opacity: 0.4;\n  min-width: 20px;\n  animation: ${Ae} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)\n    forwards;\n`,$=({toast:e})=>{let{icon:t,type:o,iconTheme:s}=e;return t!==void 0?typeof t==\"string\"?b.createElement(Pe,null,t):t:o===\"blank\"?null:b.createElement(Se,null,b.createElement(F,{...s}),o!==\"loading\"&&b.createElement(be,null,o===\"error\"?b.createElement(C,{...s}):b.createElement(L,{...s})))};var Re=e=>`\n0% {transform: translate3d(0,${e*-200}%,0) scale(.6); opacity:.5;}\n100% {transform: translate3d(0,0,0) scale(1); opacity:1;}\n`,Ee=e=>`\n0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}\n100% {transform: translate3d(0,${e*-150}%,-1px) scale(.6); opacity:0;}\n`,ve=\"0%{opacity:0;} 100%{opacity:1;}\",De=\"0%{opacity:1;} 100%{opacity:0;}\",Oe=J(\"div\")`\n  display: flex;\n  align-items: center;\n  background: #fff;\n  color: #363636;\n  line-height: 1.3;\n  will-change: transform;\n  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);\n  max-width: 350px;\n  pointer-events: auto;\n  padding: 8px 10px;\n  border-radius: 8px;\n`,Ie=J(\"div\")`\n  display: flex;\n  justify-content: center;\n  margin: 4px 10px;\n  color: inherit;\n  flex: 1 1 auto;\n  white-space: pre-line;\n`,ke=(e,t)=>{let s=e.includes(\"top\")?1:-1,[a,i]=E()?[ve,De]:[Re(s),Ee(s)];return{animation:t?`${G(a)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards`:`${G(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`}},N=y.memo(({toast:e,position:t,style:o,children:s})=>{let a=e.height?ke(e.position||t||\"top-center\",e.visible):{opacity:0},i=y.createElement($,{toast:e}),r=y.createElement(Ie,{...e.ariaProps},h(e.message,e));return y.createElement(Oe,{className:e.className,style:{...a,...o,...e.style}},typeof s==\"function\"?s({icon:i,message:r}):y.createElement(y.Fragment,null,i,r))});import{css as _e,setup as Ve}from\"goober\";import*as x from\"react\";Ve(x.createElement);var we=({id:e,className:t,style:o,onHeightUpdate:s,children:a})=>{let i=x.useCallback(r=>{if(r){let l=()=>{let g=r.getBoundingClientRect().height;s(e,g)};l(),new MutationObserver(l).observe(r,{subtree:!0,childList:!0,characterData:!0})}},[e,s]);return x.createElement(\"div\",{ref:i,className:t,style:o},a)},Me=(e,t)=>{let o=e.includes(\"top\"),s=o?{top:0}:{bottom:0},a=e.includes(\"center\")?{justifyContent:\"center\"}:e.includes(\"right\")?{justifyContent:\"flex-end\"}:{};return{left:0,right:0,display:\"flex\",position:\"absolute\",transition:E()?void 0:\"all 230ms cubic-bezier(.21,1.02,.73,1)\",transform:`translateY(${t*(o?1:-1)}px)`,...s,...a}},Ce=_e`\n  z-index: 9999;\n  > * {\n    pointer-events: auto;\n  }\n`,D=16,Fe=({reverseOrder:e,position:t=\"top-center\",toastOptions:o,gutter:s,children:a,toasterId:i,containerStyle:r,containerClassName:l})=>{let{toasts:g,handlers:T}=w(o,i);return x.createElement(\"div\",{\"data-rht-toaster\":i||\"\",style:{position:\"fixed\",zIndex:9999,top:D,left:D,right:D,bottom:D,pointerEvents:\"none\",...r},className:l,onMouseEnter:T.startPause,onMouseLeave:T.endPause},g.map(d=>{let c=d.position||t,m=T.calculateOffset(d,{reverseOrder:e,gutter:s,defaultPosition:t}),p=Me(c,m);return x.createElement(we,{id:d.id,key:d.id,onHeightUpdate:T.updateHeight,className:d.visible?Ce:\"\",style:p},d.type===\"custom\"?h(d.message,d):a?a(d):x.createElement(N,{toast:d,position:c}))}))};var zt=n;export{L as CheckmarkIcon,C as ErrorIcon,F as LoaderIcon,N as ToastBar,$ as ToastIcon,Fe as Toaster,zt as default,h as resolveValue,n as toast,w as useToaster,V as useToasterStore};\n//# sourceMappingURL=index.mjs.map"],"names":[],"ignoreList":[],"sourceRoot":""}